{"ast":null,"code":"import { Loader, FileLoader, NumberKeyframeTrack, AnimationClip, BufferAttribute } from 'three';\n\n/**\n * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * number of frames (a single uint32)\n * number of vertices (a single uint32)\n * time values for each frame (sequence of float32)\n * vertex data for each frame (sequence of float32)\n */\n\nvar MDDLoader = function (manager) {\n  Loader.call(this, manager);\n};\nMDDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: MDDLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (data) {\n      onLoad(scope.parse(data));\n    }, onProgress, onError);\n  },\n  parse: function (data) {\n    var view = new DataView(data);\n    var totalFrames = view.getUint32(0);\n    var totalPoints = view.getUint32(4);\n    var offset = 8; // animation clip\n\n    var times = new Float32Array(totalFrames);\n    var values = new Float32Array(totalFrames * totalFrames).fill(0);\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset);\n      offset += 4;\n      values[totalFrames * i + i] = 1;\n    }\n    var track = new NumberKeyframeTrack('.morphTargetInfluences', times, values);\n    var clip = new AnimationClip('default', times[times.length - 1], [track]); // morph targets\n\n    var morphTargets = [];\n    for (let i = 0; i < totalFrames; i++) {\n      var morphTarget = new Float32Array(totalPoints * 3);\n      for (let j = 0; j < totalPoints; j++) {\n        var stride = j * 3;\n        morphTarget[stride + 0] = view.getFloat32(offset);\n        offset += 4; // x\n\n        morphTarget[stride + 1] = view.getFloat32(offset);\n        offset += 4; // y\n\n        morphTarget[stride + 2] = view.getFloat32(offset);\n        offset += 4; // z\n      }\n      var attribute = new BufferAttribute(morphTarget, 3);\n      attribute.name = 'morph_' + i;\n      morphTargets.push(attribute);\n    }\n    return {\n      morphTargets: morphTargets,\n      clip: clip\n    };\n  }\n});\nexport { MDDLoader };","map":{"version":3,"names":["Loader","FileLoader","NumberKeyframeTrack","AnimationClip","BufferAttribute","MDDLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","data","parse","view","DataView","totalFrames","getUint32","totalPoints","offset","times","Float32Array","values","fill","i","getFloat32","track","clip","length","morphTargets","morphTarget","j","stride","attribute","name","push"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/MDDLoader.js"],"sourcesContent":["import { Loader, FileLoader, NumberKeyframeTrack, AnimationClip, BufferAttribute } from 'three';\n\n/**\n * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * number of frames (a single uint32)\n * number of vertices (a single uint32)\n * time values for each frame (sequence of float32)\n * vertex data for each frame (sequence of float32)\n */\n\nvar MDDLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nMDDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: MDDLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (data) {\n      onLoad(scope.parse(data));\n    }, onProgress, onError);\n  },\n  parse: function (data) {\n    var view = new DataView(data);\n    var totalFrames = view.getUint32(0);\n    var totalPoints = view.getUint32(4);\n    var offset = 8; // animation clip\n\n    var times = new Float32Array(totalFrames);\n    var values = new Float32Array(totalFrames * totalFrames).fill(0);\n\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset);\n      offset += 4;\n      values[totalFrames * i + i] = 1;\n    }\n\n    var track = new NumberKeyframeTrack('.morphTargetInfluences', times, values);\n    var clip = new AnimationClip('default', times[times.length - 1], [track]); // morph targets\n\n    var morphTargets = [];\n\n    for (let i = 0; i < totalFrames; i++) {\n      var morphTarget = new Float32Array(totalPoints * 3);\n\n      for (let j = 0; j < totalPoints; j++) {\n        var stride = j * 3;\n        morphTarget[stride + 0] = view.getFloat32(offset);\n        offset += 4; // x\n\n        morphTarget[stride + 1] = view.getFloat32(offset);\n        offset += 4; // y\n\n        morphTarget[stride + 2] = view.getFloat32(offset);\n        offset += 4; // z\n      }\n\n      var attribute = new BufferAttribute(morphTarget, 3);\n      attribute.name = 'morph_' + i;\n      morphTargets.push(attribute);\n    }\n\n    return {\n      morphTargets: morphTargets,\n      clip: clip\n    };\n  }\n});\n\nexport { MDDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}