{"ast":null,"code":"import { Loader, FileLoader, Matrix3, Vector2, Vector3, BufferGeometry, Float32BufferAttribute, ShapePath, Path } from 'three';\nvar SVGLoader = function (manager) {\n  Loader.call(this, manager); // Default dots per inch\n\n  this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n  this.defaultUnit = 'px';\n};\nSVGLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: SVGLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (text) {\n    var scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      var transform = getNodeTransform(node);\n      var traverseChildNodes = true;\n      var path = null;\n      switch (node.nodeName) {\n        case 'svg':\n          break;\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case 'defs':\n          traverseChildNodes = false;\n          break;\n        case 'use':\n          style = parseStyle(node, style);\n          var usedNodeId = node.href.baseVal.substring(1);\n          var usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n      }\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n      if (traverseChildNodes) {\n        var nodes = node.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      var path = new ShapePath();\n      var point = new Vector2();\n      var control = new Vector2();\n      var firstPoint = new Vector2();\n      var isFirstPoint = true;\n      var doSetFirstPoint = false;\n      var d = node.getAttribute('d'); // console.log( d );\n\n      var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        var command = commands[i];\n        var type = command.charAt(0);\n        var data = command.substr(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        switch (type) {\n          case 'M':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'H':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'V':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'L':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'C':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'S':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'Q':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'T':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'A':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              var start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'm':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'h':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'v':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'l':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'c':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 's':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'q':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 't':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'a':\n            var numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              var start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        var stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      var dx2 = (start.x - end.x) / 2.0;\n      var dy2 = (start.y - end.y) / 2.0;\n      var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      var rxs = rx * rx;\n      var rys = ry * ry;\n      var x1ps = x1p * x1p;\n      var y1ps = y1p * y1p; // Ensure radii are large enough\n\n      var cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        var s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      var dq = rxs * y1ps + rys * x1ps;\n      var pq = (rxs * rys - dq) / dq;\n      var q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      var cxp = q * rx * y1p / ry;\n      var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      var dot = ux * vx + uy * vy;\n      var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n\n    function parseRectNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      var w = parseFloatWithUnits(node.getAttribute('width'));\n      var h = parseFloatWithUnits(node.getAttribute('height'));\n      var path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n      path.lineTo(x, y + 2 * ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var r = parseFloatWithUnits(node.getAttribute('r'));\n      var subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var rx = parseFloatWithUnits(node.getAttribute('rx'));\n      var ry = parseFloatWithUnits(node.getAttribute('ry'));\n      var subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      var x1 = parseFloatWithUnits(node.getAttribute('x1'));\n      var y1 = parseFloatWithUnits(node.getAttribute('y1'));\n      var x2 = parseFloatWithUnits(node.getAttribute('x2'));\n      var y2 = parseFloatWithUnits(node.getAttribute('y2'));\n      var path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      var stylesheetStyles = {};\n      if (node.hasAttribute('class')) {\n        var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n      var RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i\n      }; // States\n\n      var SEP = 0;\n      var INT = 1;\n      var FLOAT = 2;\n      var EXP = 3;\n      var state = SEP;\n      var seenComma = true;\n      var result = [],\n        number = '',\n        exponent = '';\n      function throwSyntaxError(current, i, partial) {\n        var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = '';\n        exponent = '';\n      }\n      var current,\n        i = 0,\n        length = input.length;\n      for (i = 0; i < length; i++) {\n        current = input[i]; // parse until next number\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        } // parse integer part\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n        if (state == EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n      newNumber();\n      return result;\n    } // Units\n\n    var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    var unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      var theUnit = 'px';\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          var u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      var scale = undefined;\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    } // Transforms\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n      var transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      var transform = new Matrix3();\n      var currentTransform = tempTransform0;\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        var tx = parseFloatWithUnits(node.getAttribute('x'));\n        var ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute('transform')) {\n        var transformsTexts = node.getAttribute('transform').split(')');\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          var transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          var openParPos = transformText.indexOf('(');\n          var closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            var transformType = transformText.substr(0, openParPos);\n            var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  var tx = array[0];\n                  var ty = tx;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform.translate(tx, ty);\n                }\n                break;\n              case 'rotate':\n                if (array.length >= 1) {\n                  var angle = 0;\n                  var cx = 0;\n                  var cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case 'scale':\n                if (array.length >= 1) {\n                  var scaleX = array[0];\n                  var scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform.scale(scaleX, scaleY);\n                }\n                break;\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      var isRotated = isTransformRotated(m);\n      var subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        var subPath = subPaths[i];\n        var curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          var curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n    function getTransformScaleX(m) {\n      var te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      var te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n    var paths = [];\n    var stylesheets = {};\n    var transformStack = [];\n    var tempTransform0 = new Matrix3();\n    var tempTransform1 = new Matrix3();\n    var tempTransform2 = new Matrix3();\n    var tempTransform3 = new Matrix3();\n    var tempV2 = new Vector2();\n    var tempV3 = new Vector3();\n    var currentTransform = new Matrix3();\n    var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    var data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n});\nSVGLoader.getStrokeStyle = function (width, color, lineJoin, lineCap, miterLimit) {\n  // Param width: Stroke width\n  // Param color: As returned by THREE.Color.getStyle()\n  // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n  // Param lineCap: One of \"round\", \"square\" or \"butt\"\n  // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n  // Returns style object\n  width = width !== undefined ? width : 1;\n  color = color !== undefined ? color : '#000';\n  lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n  lineCap = lineCap !== undefined ? lineCap : 'butt';\n  miterLimit = miterLimit !== undefined ? miterLimit : 4;\n  return {\n    strokeColor: color,\n    strokeWidth: width,\n    strokeLineJoin: lineJoin,\n    strokeLineCap: lineCap,\n    strokeMiterLimit: miterLimit\n  };\n};\nSVGLoader.pointsToStroke = function (points, style, arcDivisions, minDistance) {\n  // Generates a stroke with some witdh around the given path.\n  // The path can be open or closed (last point equals to first point)\n  // Param points: Array of Vector2D (the path). Minimum 2 points.\n  // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n  // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n  // Param minDistance: Points closer to this distance will be merged. (Optional)\n  // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n    return null;\n  }\n  var geometry = new BufferGeometry();\n  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  return geometry;\n};\nSVGLoader.pointsToStrokeWithBuffers = function () {\n  var tempV2_1 = new Vector2();\n  var tempV2_2 = new Vector2();\n  var tempV2_3 = new Vector2();\n  var tempV2_4 = new Vector2();\n  var tempV2_5 = new Vector2();\n  var tempV2_6 = new Vector2();\n  var tempV2_7 = new Vector2();\n  var lastPointL = new Vector2();\n  var lastPointR = new Vector2();\n  var point0L = new Vector2();\n  var point0R = new Vector2();\n  var currentPointL = new Vector2();\n  var currentPointR = new Vector2();\n  var nextPointL = new Vector2();\n  var nextPointR = new Vector2();\n  var innerPoint = new Vector2();\n  var outerPoint = new Vector2();\n  return function (points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    var numPoints = points.length;\n    if (numPoints < 2) return 0;\n    var isClosed = points[0].equals(points[numPoints - 1]);\n    var currentPoint;\n    var previousPoint = points[0];\n    var nextPoint;\n    var strokeWidth2 = style.strokeWidth / 2;\n    var deltaU = 1 / (numPoints - 1);\n    var u0 = 0;\n    var innerSideModified;\n    var joinIsOnLeftSide;\n    var isMiter;\n    var initialJoinIsOnLeftSide = false;\n    var numVertices = 0;\n    var currentCoordinate = vertexOffset * 3;\n    var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n      var normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      var u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          var miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          var miterLength2 = tempV2_5.length();\n          var segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          var segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case 'miter':\n            case 'miter-clip':\n            default:\n              var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      var lastOuter = outerPoint;\n      var lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      var angle = Math.PI;\n      var dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            var vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      var dupPoints = false;\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints) return points;\n      var newPoints = [];\n      newPoints.push(points[0]);\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  };\n}();\nexport { SVGLoader };","map":{"version":3,"names":["Loader","FileLoader","Matrix3","Vector2","Vector3","BufferGeometry","Float32BufferAttribute","ShapePath","Path","SVGLoader","manager","call","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","usedNodeId","href","baseVal","substring","usedNode","viewportElement","getElementById","warn","fill","undefined","color","setStyle","transformPath","currentTransform","paths","push","userData","nodes","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","stylesheets","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","SEP","INT","FLOAT","state","seenComma","result","number","exponent","throwSyntaxError","current","partial","SyntaxError","newNumber","Number","pow","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","vertexOffset","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","center","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/SVGLoader.js"],"sourcesContent":["import { Loader, FileLoader, Matrix3, Vector2, Vector3, BufferGeometry, Float32BufferAttribute, ShapePath, Path } from 'three';\n\nvar SVGLoader = function (manager) {\n  Loader.call(this, manager); // Default dots per inch\n\n  this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n  this.defaultUnit = 'px';\n};\n\nSVGLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: SVGLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (text) {\n    var scope = this;\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      var transform = getNodeTransform(node);\n      var traverseChildNodes = true;\n      var path = null;\n\n      switch (node.nodeName) {\n        case 'svg':\n          break;\n\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case 'defs':\n          traverseChildNodes = false;\n          break;\n\n        case 'use':\n          style = parseStyle(node, style);\n          var usedNodeId = node.href.baseVal.substring(1);\n          var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n\n          break;\n\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n\n      if (traverseChildNodes) {\n        var nodes = node.childNodes;\n\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      var path = new ShapePath();\n      var point = new Vector2();\n      var control = new Vector2();\n      var firstPoint = new Vector2();\n      var isFirstPoint = true;\n      var doSetFirstPoint = false;\n      var d = node.getAttribute('d'); // console.log( d );\n\n      var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        var command = commands[i];\n        var type = command.charAt(0);\n        var data = command.substr(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        switch (type) {\n          case 'M':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'H':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'V':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'L':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'C':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'S':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Q':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'T':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'A':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              var start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'm':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'h':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'v':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'l':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'c':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 's':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'q':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 't':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x);\n              var ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'a':\n            var numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              var start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        var stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      var dx2 = (start.x - end.x) / 2.0;\n      var dy2 = (start.y - end.y) / 2.0;\n      var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      var rxs = rx * rx;\n      var rys = ry * ry;\n      var x1ps = x1p * x1p;\n      var y1ps = y1p * y1p; // Ensure radii are large enough\n\n      var cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        var s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      var dq = rxs * y1ps + rys * x1ps;\n      var pq = (rxs * rys - dq) / dq;\n      var q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      var cxp = q * rx * y1p / ry;\n      var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      var dot = ux * vx + uy * vy;\n      var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n\n\n    function parseRectNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      var w = parseFloatWithUnits(node.getAttribute('width'));\n      var h = parseFloatWithUnits(node.getAttribute('height'));\n      var path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n\n      path.lineTo(x, y + 2 * ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        var x = parseFloatWithUnits(a);\n        var y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      var path = new ShapePath();\n      var index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var r = parseFloatWithUnits(node.getAttribute('r'));\n      var subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      var x = parseFloatWithUnits(node.getAttribute('cx'));\n      var y = parseFloatWithUnits(node.getAttribute('cy'));\n      var rx = parseFloatWithUnits(node.getAttribute('rx'));\n      var ry = parseFloatWithUnits(node.getAttribute('ry'));\n      var subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      var path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseLineNode(node) {\n      var x1 = parseFloatWithUnits(node.getAttribute('x1'));\n      var y1 = parseFloatWithUnits(node.getAttribute('y1'));\n      var x2 = parseFloatWithUnits(node.getAttribute('x2'));\n      var y2 = parseFloatWithUnits(node.getAttribute('y2'));\n      var path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      var stylesheetStyles = {};\n\n      if (node.hasAttribute('class')) {\n        var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n    function parseFloats(input) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n\n      var RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i\n      }; // States\n\n      var SEP = 0;\n      var INT = 1;\n      var FLOAT = 2;\n      var EXP = 3;\n      var state = SEP;\n      var seenComma = true;\n      var result = [],\n          number = '',\n          exponent = '';\n\n      function throwSyntaxError(current, i, partial) {\n        var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = '';\n        exponent = '';\n      }\n\n      var current,\n          i = 0,\n          length = input.length;\n\n      for (i = 0; i < length; i++) {\n        current = input[i]; // parse until next number\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        } // parse integer part\n\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n\n        if (state == EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n\n      newNumber();\n      return result;\n    } // Units\n\n\n    var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    var unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n\n    function parseFloatWithUnits(string) {\n      var theUnit = 'px';\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          var u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      var scale = undefined;\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    } // Transforms\n\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n\n      var transform = parseNodeTransform(node);\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n\n    function parseNodeTransform(node) {\n      var transform = new Matrix3();\n      var currentTransform = tempTransform0;\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        var tx = parseFloatWithUnits(node.getAttribute('x'));\n        var ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n\n      if (node.hasAttribute('transform')) {\n        var transformsTexts = node.getAttribute('transform').split(')');\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          var transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          var openParPos = transformText.indexOf('(');\n          var closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            var transformType = transformText.substr(0, openParPos);\n            var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  var tx = array[0];\n                  var ty = tx;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                }\n\n                break;\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  var angle = 0;\n                  var cx = 0;\n                  var cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n\n                break;\n\n              case 'scale':\n                if (array.length >= 1) {\n                  var scaleX = array[0];\n                  var scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n\n      var isRotated = isTransformRotated(m);\n      var subPaths = path.subPaths;\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        var subPath = subPaths[i];\n        var curves = subPath.curves;\n\n        for (let j = 0; j < curves.length; j++) {\n          var curve = curves[j];\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n\n    function getTransformScaleX(m) {\n      var te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n\n    function getTransformScaleY(m) {\n      var te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n\n    var paths = [];\n    var stylesheets = {};\n    var transformStack = [];\n    var tempTransform0 = new Matrix3();\n    var tempTransform1 = new Matrix3();\n    var tempTransform2 = new Matrix3();\n    var tempTransform3 = new Matrix3();\n    var tempV2 = new Vector2();\n    var tempV3 = new Vector3();\n    var currentTransform = new Matrix3();\n    var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    var data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n});\n\nSVGLoader.getStrokeStyle = function (width, color, lineJoin, lineCap, miterLimit) {\n  // Param width: Stroke width\n  // Param color: As returned by THREE.Color.getStyle()\n  // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n  // Param lineCap: One of \"round\", \"square\" or \"butt\"\n  // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n  // Returns style object\n  width = width !== undefined ? width : 1;\n  color = color !== undefined ? color : '#000';\n  lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n  lineCap = lineCap !== undefined ? lineCap : 'butt';\n  miterLimit = miterLimit !== undefined ? miterLimit : 4;\n  return {\n    strokeColor: color,\n    strokeWidth: width,\n    strokeLineJoin: lineJoin,\n    strokeLineCap: lineCap,\n    strokeMiterLimit: miterLimit\n  };\n};\n\nSVGLoader.pointsToStroke = function (points, style, arcDivisions, minDistance) {\n  // Generates a stroke with some witdh around the given path.\n  // The path can be open or closed (last point equals to first point)\n  // Param points: Array of Vector2D (the path). Minimum 2 points.\n  // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n  // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n  // Param minDistance: Points closer to this distance will be merged. (Optional)\n  // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n\n  if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n    return null;\n  }\n\n  var geometry = new BufferGeometry();\n  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  return geometry;\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n  var tempV2_1 = new Vector2();\n  var tempV2_2 = new Vector2();\n  var tempV2_3 = new Vector2();\n  var tempV2_4 = new Vector2();\n  var tempV2_5 = new Vector2();\n  var tempV2_6 = new Vector2();\n  var tempV2_7 = new Vector2();\n  var lastPointL = new Vector2();\n  var lastPointR = new Vector2();\n  var point0L = new Vector2();\n  var point0R = new Vector2();\n  var currentPointL = new Vector2();\n  var currentPointR = new Vector2();\n  var nextPointL = new Vector2();\n  var nextPointR = new Vector2();\n  var innerPoint = new Vector2();\n  var outerPoint = new Vector2();\n  return function (points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    var numPoints = points.length;\n    if (numPoints < 2) return 0;\n    var isClosed = points[0].equals(points[numPoints - 1]);\n    var currentPoint;\n    var previousPoint = points[0];\n    var nextPoint;\n    var strokeWidth2 = style.strokeWidth / 2;\n    var deltaU = 1 / (numPoints - 1);\n    var u0 = 0;\n    var innerSideModified;\n    var joinIsOnLeftSide;\n    var isMiter;\n    var initialJoinIsOnLeftSide = false;\n    var numVertices = 0;\n    var currentCoordinate = vertexOffset * 3;\n    var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n\n      var normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      var u1 = u0 + deltaU;\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          var miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          var miterLength2 = tempV2_5.length();\n          var segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          var segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n\n              break;\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      var lastOuter = outerPoint;\n      var lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      var angle = Math.PI;\n      var dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            var vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      var dupPoints = false;\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n      var newPoints = [];\n      newPoints.push(points[0]);\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  };\n}();\n\nexport { SVGLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}