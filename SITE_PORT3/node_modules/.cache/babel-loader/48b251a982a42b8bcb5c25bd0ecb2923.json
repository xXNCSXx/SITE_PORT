{"ast":null,"code":"import { Loader, LoaderUtils, Interpolant, Quaternion, FileLoader, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Euler } from 'three';\nimport { TGALoader } from './TGALoader.js';\nimport { Parser } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\nvar MMDLoader = function () {\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n  function MMDLoader(manager) {\n    Loader.call(this, manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null; // lazy generation\n\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  MMDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: MMDLoader,\n    /**\n     * @param {string} animationPath\n     * @return {MMDLoader}\n     */\n    setAnimationPath: function (animationPath) {\n      this.animationPath = animationPath;\n      return this;\n    },\n    // Load MMD assets as Three.js Object\n\n    /**\n     * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n     *\n     * @param {string} url - url to Model(.pmd or .pmx) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    load: function (url, onLoad, onProgress, onError) {\n      var builder = this.meshBuilder.setCrossOrigin(this.crossOrigin); // resource path\n\n      var resourcePath;\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      }\n      var modelExtension = this._extractExtension(url).toLowerCase(); // Should I detect by seeing header?\n\n      if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n        if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'));\n        return;\n      }\n      this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](url, function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      }, onProgress, onError);\n    },\n    /**\n     * Loads Motion file(s) (.vmd) as a AnimationClip.\n     * If two or more files are specified, they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n     * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadAnimation: function (url, object, onLoad, onProgress, onError) {\n      var builder = this.animationBuilder;\n      this.loadVMD(url, function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      }, onProgress, onError);\n    },\n    /**\n     * Loads mode file and motion file(s) as an object containing\n     * a SkinnedMesh and a AnimationClip.\n     * Tracks of AnimationClip are fitting to the model.\n     *\n     * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n     * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadWithAnimation: function (modelUrl, vmdUrl, onLoad, onProgress, onError) {\n      var scope = this;\n      this.load(modelUrl, function (mesh) {\n        scope.loadAnimation(vmdUrl, mesh, function (animation) {\n          onLoad({\n            mesh: mesh,\n            animation: animation\n          });\n        }, onProgress, onError);\n      }, onProgress, onError);\n    },\n    // Load MMD assets as Object data parsed by MMDParser\n\n    /**\n     * Loads .pmd file as an Object.\n     *\n     * @param {string} url - url to .pmd file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadPMD: function (url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      }, onProgress, onError);\n    },\n    /**\n     * Loads .pmx file as an Object.\n     *\n     * @param {string} url - url to .pmx file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadPMX: function (url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      }, onProgress, onError);\n    },\n    /**\n     * Loads .vmd file as an Object. If two or more files are specified\n     * they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to .vmd file(s)\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadVMD: function (url, onLoad, onProgress, onError) {\n      var urls = Array.isArray(url) ? url : [url];\n      var vmds = [];\n      var vmdNum = urls.length;\n      var parser = this._getParser();\n      this.loader.setMimeType(undefined).setPath(this.animationPath).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n      for (let i = 0, il = urls.length; i < il; i++) {\n        this.loader.load(urls[i], function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n        }, onProgress, onError);\n      }\n    },\n    /**\n     * Loads .vpd file as an Object.\n     *\n     * @param {string} url - url to .vpd file\n     * @param {boolean} isUnicode\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadVPD: function (url, isUnicode, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis').setPath(this.animationPath).setResponseType('text').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n        onLoad(parser.parseVpd(text, true));\n      }, onProgress, onError);\n    },\n    // private methods\n    _extractExtension: function (url) {\n      var index = url.lastIndexOf('.');\n      return index < 0 ? '' : url.slice(index + 1);\n    },\n    _getParser: function () {\n      if (this.parser === null) {\n        this.parser = new Parser(); // eslint-disable-line no-undef\n      }\n      return this.parser;\n    }\n  }); // Utilities\n\n  /*\n   * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n   * We don't need to request external toon image files.\n   * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n   */\n\n  var DEFAULT_TOON_TEXTURES = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=']; // Builders. They build Three.js object from Object data parsed by MMDParser.\n\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n\n  function MeshBuilder(manager) {\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  MeshBuilder.prototype = {\n    constructor: MeshBuilder,\n    crossOrigin: 'anonymous',\n    /**\n     * @param {string} crossOrigin\n     * @return {MeshBuilder}\n     */\n    setCrossOrigin: function (crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    },\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {string} resourcePath\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {SkinnedMesh}\n     */\n    build: function (data, resourcePath, onProgress, onError) {\n      var geometry = this.geometryBuilder.build(data);\n      var material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n      var mesh = new SkinnedMesh(geometry, material);\n      var skeleton = new Skeleton(initBones(mesh));\n      mesh.bind(skeleton); // console.log( mesh ); // for console debug\n\n      return mesh;\n    }\n  }; // TODO: Try to remove this function\n\n  function initBones(mesh) {\n    var geometry = mesh.geometry;\n    var bones = [],\n      bone,\n      gbone;\n    var i, il;\n    if (geometry && geometry.bones !== undefined) {\n      // first, create array of 'Bone' objects from geometry data\n      for (i = 0, il = geometry.bones.length; i < il; i++) {\n        gbone = geometry.bones[i]; // create new 'Bone' object\n\n        bone = new Bone();\n        bones.push(bone); // apply values\n\n        bone.name = gbone.name;\n        bone.position.fromArray(gbone.pos);\n        bone.quaternion.fromArray(gbone.rotq);\n        if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n      } // second, create bone hierarchy\n\n      for (i = 0, il = geometry.bones.length; i < il; i++) {\n        gbone = geometry.bones[i];\n        if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n          // subsequent bones in the hierarchy\n          bones[gbone.parent].add(bones[i]);\n        } else {\n          // topmost bone, immediate child of the skinned mesh\n          mesh.add(bones[i]);\n        }\n      }\n    } // now the bones are part of the scene graph and children of the skinned mesh.\n    // let's update the corresponding matrices\n\n    mesh.updateMatrixWorld(true);\n    return bones;\n  } //\n\n  function GeometryBuilder() {}\n  GeometryBuilder.prototype = {\n    constructor: GeometryBuilder,\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @return {BufferGeometry}\n     */\n    build: function (data) {\n      // for geometry\n      var positions = [];\n      var uvs = [];\n      var normals = [];\n      var indices = [];\n      var groups = [];\n      var bones = [];\n      var skinIndices = [];\n      var skinWeights = [];\n      var morphTargets = [];\n      var morphPositions = [];\n      var iks = [];\n      var grants = [];\n      var rigidBodies = [];\n      var constraints = []; // for work\n\n      var offset = 0;\n      var boneTypeTable = {}; // positions, normals, uvs, skinIndices, skinWeights\n\n      for (let i = 0; i < data.metadata.vertexCount; i++) {\n        var v = data.vertices[i];\n        for (let j = 0, jl = v.position.length; j < jl; j++) {\n          positions.push(v.position[j]);\n        }\n        for (let j = 0, jl = v.normal.length; j < jl; j++) {\n          normals.push(v.normal[j]);\n        }\n        for (let j = 0, jl = v.uv.length; j < jl; j++) {\n          uvs.push(v.uv[j]);\n        }\n        for (let j = 0; j < 4; j++) {\n          skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n        }\n        for (let j = 0; j < 4; j++) {\n          skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n        }\n      } // indices\n\n      for (let i = 0; i < data.metadata.faceCount; i++) {\n        var face = data.faces[i];\n        for (let j = 0, jl = face.indices.length; j < jl; j++) {\n          indices.push(face.indices[j]);\n        }\n      } // groups\n\n      for (let i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        groups.push({\n          offset: offset * 3,\n          count: material.faceCount * 3\n        });\n        offset += material.faceCount;\n      } // bones\n\n      for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n        var body = data.rigidBodies[i];\n        var value = boneTypeTable[body.boneIndex]; // keeps greater number if already value is set without any special reasons\n\n        value = value === undefined ? body.type : Math.max(body.type, value);\n        boneTypeTable[body.boneIndex] = value;\n      }\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        var boneData = data.bones[i];\n        var bone = {\n          parent: boneData.parentIndex,\n          name: boneData.name,\n          pos: boneData.position.slice(0, 3),\n          rotq: [0, 0, 0, 1],\n          scl: [1, 1, 1],\n          rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1\n        };\n        if (bone.parent !== -1) {\n          bone.pos[0] -= data.bones[bone.parent].position[0];\n          bone.pos[1] -= data.bones[bone.parent].position[1];\n          bone.pos[2] -= data.bones[bone.parent].position[2];\n        }\n        bones.push(bone);\n      } // iks\n      // TODO: remove duplicated codes between PMD and PMX\n\n      if (data.metadata.format === 'pmd') {\n        for (let i = 0; i < data.metadata.ikCount; i++) {\n          var ik = data.iks[i];\n          var param = {\n            target: ik.target,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle * 4,\n            links: []\n          };\n          for (let j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = {};\n            link.index = ik.links[j].index;\n            link.enabled = true;\n            if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n              link.limitation = new Vector3(1.0, 0.0, 0.0);\n            }\n            param.links.push(link);\n          }\n          iks.push(param);\n        }\n      } else {\n        for (let i = 0; i < data.metadata.boneCount; i++) {\n          var ik = data.bones[i].ik;\n          if (ik === undefined) continue;\n          var param = {\n            target: i,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle,\n            links: []\n          };\n          for (let j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = {};\n            link.index = ik.links[j].index;\n            link.enabled = true;\n            if (ik.links[j].angleLimitation === 1) {\n              // Revert if rotationMin/Max doesn't work well\n              // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n              var rotationMin = ik.links[j].lowerLimitationAngle;\n              var rotationMax = ik.links[j].upperLimitationAngle; // Convert Left to Right coordinate by myself because\n              // MMDParser doesn't convert. It's a MMDParser's bug\n\n              var tmp1 = -rotationMax[0];\n              var tmp2 = -rotationMax[1];\n              rotationMax[0] = -rotationMin[0];\n              rotationMax[1] = -rotationMin[1];\n              rotationMin[0] = tmp1;\n              rotationMin[1] = tmp2;\n              link.rotationMin = new Vector3().fromArray(rotationMin);\n              link.rotationMax = new Vector3().fromArray(rotationMax);\n            }\n            param.links.push(link);\n          }\n          iks.push(param);\n        }\n      } // grants\n\n      if (data.metadata.format === 'pmx') {\n        for (let i = 0; i < data.metadata.boneCount; i++) {\n          var boneData = data.bones[i];\n          var grant = boneData.grant;\n          if (grant === undefined) continue;\n          var param = {\n            index: i,\n            parentIndex: grant.parentIndex,\n            ratio: grant.ratio,\n            isLocal: grant.isLocal,\n            affectRotation: grant.affectRotation,\n            affectPosition: grant.affectPosition,\n            transformationClass: boneData.transformationClass\n          };\n          grants.push(param);\n        }\n        grants.sort(function (a, b) {\n          return a.transformationClass - b.transformationClass;\n        });\n      } // morph\n\n      function updateAttributes(attribute, morph, ratio) {\n        for (let i = 0; i < morph.elementCount; i++) {\n          var element = morph.elements[i];\n          var index;\n          if (data.metadata.format === 'pmd') {\n            index = data.morphs[0].elements[element.index].index;\n          } else {\n            index = element.index;\n          }\n          attribute.array[index * 3 + 0] += element.position[0] * ratio;\n          attribute.array[index * 3 + 1] += element.position[1] * ratio;\n          attribute.array[index * 3 + 2] += element.position[2] * ratio;\n        }\n      }\n      for (let i = 0; i < data.metadata.morphCount; i++) {\n        var morph = data.morphs[i];\n        var params = {\n          name: morph.name\n        };\n        var attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n        attribute.name = morph.name;\n        for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n          attribute.array[j] = positions[j];\n        }\n        if (data.metadata.format === 'pmd') {\n          if (i !== 0) {\n            updateAttributes(attribute, morph, 1.0);\n          }\n        } else {\n          if (morph.type === 0) {\n            // group\n            for (let j = 0; j < morph.elementCount; j++) {\n              var morph2 = data.morphs[morph.elements[j].index];\n              var ratio = morph.elements[j].ratio;\n              if (morph2.type === 1) {\n                updateAttributes(attribute, morph2, ratio);\n              }\n            }\n          } else if (morph.type === 1) {\n            // vertex\n            updateAttributes(attribute, morph, 1.0);\n          } else if (morph.type === 2) ;else if (morph.type === 3) ;else if (morph.type === 4) ;else if (morph.type === 5) ;else if (morph.type === 6) ;else if (morph.type === 7) ;else if (morph.type === 8) ;\n        }\n        morphTargets.push(params);\n        morphPositions.push(attribute);\n      } // rigid bodies from rigidBodies field.\n\n      for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n        var rigidBody = data.rigidBodies[i];\n        var params = {};\n        for (let key in rigidBody) {\n          params[key] = rigidBody[key];\n        }\n        /*\n         * RigidBody position parameter in PMX seems global position\n         * while the one in PMD seems offset from corresponding bone.\n         * So unify being offset.\n         */\n\n        if (data.metadata.format === 'pmx') {\n          if (params.boneIndex !== -1) {\n            var bone = data.bones[params.boneIndex];\n            params.position[0] -= bone.position[0];\n            params.position[1] -= bone.position[1];\n            params.position[2] -= bone.position[2];\n          }\n        }\n        rigidBodies.push(params);\n      } // constraints from constraints field.\n\n      for (let i = 0; i < data.metadata.constraintCount; i++) {\n        var constraint = data.constraints[i];\n        var params = {};\n        for (let key in constraint) {\n          params[key] = constraint[key];\n        }\n        var bodyA = rigidBodies[params.rigidBodyIndex1];\n        var bodyB = rigidBodies[params.rigidBodyIndex2]; // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\n        if (bodyA.type !== 0 && bodyB.type === 2) {\n          if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n            bodyB.type = 1;\n          }\n        }\n        constraints.push(params);\n      } // build BufferGeometry.\n\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n      geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n      geometry.setIndex(indices);\n      for (let i = 0, il = groups.length; i < il; i++) {\n        geometry.addGroup(groups[i].offset, groups[i].count, i);\n      }\n      geometry.bones = bones;\n      geometry.morphTargets = morphTargets;\n      geometry.morphAttributes.position = morphPositions;\n      geometry.morphTargetsRelative = false;\n      geometry.userData.MMD = {\n        bones: bones,\n        iks: iks,\n        grants: grants,\n        rigidBodies: rigidBodies,\n        constraints: constraints,\n        format: data.metadata.format\n      };\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n  }; //\n\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n\n  function MaterialBuilder(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null; // lazy generation\n  }\n  MaterialBuilder.prototype = {\n    constructor: MaterialBuilder,\n    crossOrigin: 'anonymous',\n    resourcePath: undefined,\n    /**\n     * @param {string} crossOrigin\n     * @return {MaterialBuilder}\n     */\n    setCrossOrigin: function (crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    },\n    /**\n     * @param {string} resourcePath\n     * @return {MaterialBuilder}\n     */\n    setResourcePath: function (resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    },\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {BufferGeometry} geometry - some properties are dependend on geometry\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {Array<MeshToonMaterial>}\n     */\n    build: function (data, geometry\n    /*, onProgress, onError */) {\n      var materials = [];\n      var textures = {};\n      this.textureLoader.setCrossOrigin(this.crossOrigin); // materials\n\n      for (let i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        var params = {\n          userData: {}\n        };\n        if (material.name !== undefined) params.name = material.name;\n        /*\n         * Color\n         *\n         * MMD         MeshToonMaterial\n         * diffuse  -  color\n         * ambient  -  emissive * a\n         *               (a = 1.0 without map texture or 0.2 with map texture)\n         *\n         * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n         * It'll be too bright if material has map texture so using coef 0.2.\n         */\n\n        params.color = new Color().fromArray(material.diffuse);\n        params.opacity = material.diffuse[3];\n        params.emissive = new Color().fromArray(material.ambient);\n        params.transparent = params.opacity !== 1.0; //\n\n        params.skinning = geometry.bones.length > 0 ? true : false;\n        params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n        params.fog = true; // blend\n\n        params.blending = CustomBlending;\n        params.blendSrc = SrcAlphaFactor;\n        params.blendDst = OneMinusSrcAlphaFactor;\n        params.blendSrcAlpha = SrcAlphaFactor;\n        params.blendDstAlpha = DstAlphaFactor; // side\n\n        if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n          params.side = DoubleSide;\n        } else {\n          params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n        }\n        if (data.metadata.format === 'pmd') {\n          // map, envMap\n          if (material.fileName) {\n            var fileName = material.fileName;\n            var fileNames = fileName.split('*'); // fileNames[ 0 ]: mapFileName\n            // fileNames[ 1 ]: envMapFileName( optional )\n\n            params.map = this._loadTexture(fileNames[0], textures);\n            if (fileNames.length > 1) {\n              var extension = fileNames[1].slice(-4).toLowerCase();\n              params.envMap = this._loadTexture(fileNames[1], textures);\n              params.combine = extension === '.sph' ? MultiplyOperation : AddOperation;\n            }\n          } // gradientMap\n\n          var toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName;\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n          }); // parameters for OutlineEffect\n\n          params.userData.outlineParameters = {\n            thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n            color: [0, 0, 0],\n            alpha: 1.0,\n            visible: material.edgeFlag === 1\n          };\n        } else {\n          // map\n          if (material.textureIndex !== -1) {\n            params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n          } // envMap TODO: support m.envFlag === 3\n\n          if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n            params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n            params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n          } // gradientMap\n\n          var toonFileName, isDefaultToon;\n          if (material.toonIndex === -1 || material.toonFlag !== 0) {\n            toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp';\n            isDefaultToon = true;\n          } else {\n            toonFileName = data.textures[material.toonIndex];\n            isDefaultToon = false;\n          }\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: isDefaultToon\n          }); // parameters for OutlineEffect\n\n          params.userData.outlineParameters = {\n            thickness: material.edgeSize / 300,\n            // TODO: better calculation?\n            color: material.edgeColor.slice(0, 3),\n            alpha: material.edgeColor[3],\n            visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0\n          };\n        }\n        if (params.map !== undefined) {\n          if (!params.transparent) {\n            this._checkImageTransparency(params.map, geometry, i);\n          }\n          params.emissive.multiplyScalar(0.2);\n        }\n        materials.push(new MeshToonMaterial(params));\n      }\n      if (data.metadata.format === 'pmx') {\n        // set transparent true if alpha morph is defined.\n        function checkAlphaMorph(elements, materials) {\n          for (let i = 0, il = elements.length; i < il; i++) {\n            var element = elements[i];\n            if (element.index === -1) continue;\n            var material = materials[element.index];\n            if (material.opacity !== element.diffuse[3]) {\n              material.transparent = true;\n            }\n          }\n        }\n        for (let i = 0, il = data.morphs.length; i < il; i++) {\n          var morph = data.morphs[i];\n          var elements = morph.elements;\n          if (morph.type === 0) {\n            for (let j = 0, jl = elements.length; j < jl; j++) {\n              var morph2 = data.morphs[elements[j].index];\n              if (morph2.type !== 8) continue;\n              checkAlphaMorph(morph2.elements, materials);\n            }\n          } else if (morph.type === 8) {\n            checkAlphaMorph(elements, materials);\n          }\n        }\n      }\n      return materials;\n    },\n    // private methods\n    _getTGALoader: function () {\n      if (this.tgaLoader === null) {\n        if (TGALoader === undefined) {\n          throw new Error('THREE.MMDLoader: Import TGALoader');\n        }\n        this.tgaLoader = new TGALoader(this.manager);\n      }\n      return this.tgaLoader;\n    },\n    _isDefaultToonTexture: function (name) {\n      if (name.length !== 10) return false;\n      return /toon(10|0[0-9])\\.bmp/.test(name);\n    },\n    _loadTexture: function (filePath, textures, params, onProgress, onError) {\n      params = params || {};\n      var scope = this;\n      var fullPath;\n      if (params.isDefaultToonTexture === true) {\n        var index;\n        try {\n          index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n        } catch (e) {\n          console.warn('THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.');\n          index = 0;\n        }\n        fullPath = DEFAULT_TOON_TEXTURES[index];\n      } else {\n        fullPath = this.resourcePath + filePath;\n      }\n      if (textures[fullPath] !== undefined) return textures[fullPath];\n      var loader = this.manager.getHandler(fullPath);\n      if (loader === null) {\n        loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader;\n      }\n      var texture = loader.load(fullPath, function (t) {\n        // MMD toon texture is Axis-Y oriented\n        // but Three.js gradient map is Axis-X oriented.\n        // So here replaces the toon texture image with the rotated one.\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n        delete texture.readyCallbacks;\n      }, onProgress, onError);\n      texture.readyCallbacks = [];\n      textures[fullPath] = texture;\n      return texture;\n    },\n    _getRotatedImage: function (image) {\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var width = image.width;\n      var height = image.height;\n      canvas.width = width;\n      canvas.height = height;\n      context.clearRect(0, 0, width, height);\n      context.translate(width / 2.0, height / 2.0);\n      context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\n      context.translate(-width / 2.0, -height / 2.0);\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, width, height);\n    },\n    // Check if the partial image area used by the texture is transparent.\n    _checkImageTransparency: function (map, geometry, groupIndex) {\n      map.readyCallbacks.push(function (texture) {\n        // Is there any efficient ways?\n        function createImageData(image) {\n          var canvas = document.createElement('canvas');\n          canvas.width = image.width;\n          canvas.height = image.height;\n          var context = canvas.getContext('2d');\n          context.drawImage(image, 0, 0);\n          return context.getImageData(0, 0, canvas.width, canvas.height);\n        }\n        function detectImageTransparency(image, uvs, indices) {\n          var width = image.width;\n          var height = image.height;\n          var data = image.data;\n          var threshold = 253;\n          if (data.length / (width * height) !== 4) return false;\n          for (let i = 0; i < indices.length; i += 3) {\n            var centerUV = {\n              x: 0.0,\n              y: 0.0\n            };\n            for (let j = 0; j < 3; j++) {\n              var index = indices[i * 3 + j];\n              var uv = {\n                x: uvs[index * 2 + 0],\n                y: uvs[index * 2 + 1]\n              };\n              if (getAlphaByUv(image, uv) < threshold) return true;\n              centerUV.x += uv.x;\n              centerUV.y += uv.y;\n            }\n            centerUV.x /= 3;\n            centerUV.y /= 3;\n            if (getAlphaByUv(image, centerUV) < threshold) return true;\n          }\n          return false;\n        }\n        /*\n         * This method expects\n         *   texture.flipY = false\n         *   texture.wrapS = RepeatWrapping\n         *   texture.wrapT = RepeatWrapping\n         * TODO: more precise\n         */\n\n        function getAlphaByUv(image, uv) {\n          var width = image.width;\n          var height = image.height;\n          var x = Math.round(uv.x * width) % width;\n          var y = Math.round(uv.y * height) % height;\n          if (x < 0) x += width;\n          if (y < 0) y += height;\n          var index = y * width + x;\n          return image.data[index * 4 + 3];\n        }\n        var imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image);\n        var group = geometry.groups[groupIndex];\n        if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n          map.transparent = true;\n        }\n      });\n    }\n  }; //\n\n  function AnimationBuilder() {}\n  AnimationBuilder.prototype = {\n    constructor: AnimationBuilder,\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    build: function (vmd, mesh) {\n      // combine skeletal and morph animations\n      var tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n      var tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n      for (let i = 0, il = tracks2.length; i < il; i++) {\n        tracks.push(tracks2[i]);\n      }\n      return new AnimationClip('', -1, tracks);\n    },\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    buildSkeletalAnimation: function (vmd, mesh) {\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index + 0] / 127); // x1\n\n        array.push(interpolation[index + 8] / 127); // x2\n\n        array.push(interpolation[index + 4] / 127); // y1\n\n        array.push(interpolation[index + 12] / 127); // y2\n      }\n      var tracks = [];\n      var motions = {};\n      var bones = mesh.skeleton.bones;\n      var boneNameDictionary = {};\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = true;\n      }\n      for (let i = 0; i < vmd.metadata.motionCount; i++) {\n        var motion = vmd.motions[i];\n        var boneName = motion.boneName;\n        if (boneNameDictionary[boneName] === undefined) continue;\n        motions[boneName] = motions[boneName] || [];\n        motions[boneName].push(motion);\n      }\n      for (let key in motions) {\n        var array = motions[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var positions = [];\n        var rotations = [];\n        var pInterpolations = [];\n        var rInterpolations = [];\n        var basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n        for (let i = 0, il = array.length; i < il; i++) {\n          var time = array[i].frameNum / 30;\n          var position = array[i].position;\n          var rotation = array[i].rotation;\n          var interpolation = array[i].interpolation;\n          times.push(time);\n          for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n          for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n          for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n          pushInterpolation(rInterpolations, interpolation, 3);\n        }\n        var targetName = '.bones[' + key + ']';\n        tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations));\n        tracks.push(this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations));\n      }\n      return new AnimationClip('', -1, tracks);\n    },\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    buildMorphAnimation: function (vmd, mesh) {\n      var tracks = [];\n      var morphs = {};\n      var morphTargetDictionary = mesh.morphTargetDictionary;\n      for (let i = 0; i < vmd.metadata.morphCount; i++) {\n        var morph = vmd.morphs[i];\n        var morphName = morph.morphName;\n        if (morphTargetDictionary[morphName] === undefined) continue;\n        morphs[morphName] = morphs[morphName] || [];\n        morphs[morphName].push(morph);\n      }\n      for (let key in morphs) {\n        var array = morphs[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var values = [];\n        for (let i = 0, il = array.length; i < il; i++) {\n          times.push(array[i].frameNum / 30);\n          values.push(array[i].weight);\n        }\n        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values));\n      }\n      return new AnimationClip('', -1, tracks);\n    },\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @return {AnimationClip}\n     */\n    buildCameraAnimation: function (vmd) {\n      function pushVector3(array, vec) {\n        array.push(vec.x);\n        array.push(vec.y);\n        array.push(vec.z);\n      }\n      function pushQuaternion(array, q) {\n        array.push(q.x);\n        array.push(q.y);\n        array.push(q.z);\n        array.push(q.w);\n      }\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index * 4 + 0] / 127); // x1\n\n        array.push(interpolation[index * 4 + 1] / 127); // x2\n\n        array.push(interpolation[index * 4 + 2] / 127); // y1\n\n        array.push(interpolation[index * 4 + 3] / 127); // y2\n      }\n      var tracks = [];\n      var cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n      cameras.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      var times = [];\n      var centers = [];\n      var quaternions = [];\n      var positions = [];\n      var fovs = [];\n      var cInterpolations = [];\n      var qInterpolations = [];\n      var pInterpolations = [];\n      var fInterpolations = [];\n      var quaternion = new Quaternion();\n      var euler = new Euler();\n      var position = new Vector3();\n      var center = new Vector3();\n      for (let i = 0, il = cameras.length; i < il; i++) {\n        var motion = cameras[i];\n        var time = motion.frameNum / 30;\n        var pos = motion.position;\n        var rot = motion.rotation;\n        var distance = motion.distance;\n        var fov = motion.fov;\n        var interpolation = motion.interpolation;\n        times.push(time);\n        position.set(0, 0, -distance);\n        center.set(pos[0], pos[1], pos[2]);\n        euler.set(-rot[0], -rot[1], -rot[2]);\n        quaternion.setFromEuler(euler);\n        position.add(center);\n        position.applyQuaternion(quaternion);\n        pushVector3(centers, center);\n        pushQuaternion(quaternions, quaternion);\n        pushVector3(positions, position);\n        fovs.push(fov);\n        for (let j = 0; j < 3; j++) {\n          pushInterpolation(cInterpolations, interpolation, j);\n        }\n        pushInterpolation(qInterpolations, interpolation, 3); // use the same parameter for x, y, z axis.\n\n        for (let j = 0; j < 3; j++) {\n          pushInterpolation(pInterpolations, interpolation, 4);\n        }\n        pushInterpolation(fInterpolations, interpolation, 5);\n      }\n      var tracks = []; // I expect an object whose name 'target' exists under THREE.Camera\n\n      tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations));\n      tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n      tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations));\n      return new AnimationClip('', -1, tracks);\n    },\n    // private method\n    _createTrack: function (node, typedKeyframeTrack, times, values, interpolations) {\n      /*\n       * optimizes here not to let KeyframeTrackPrototype optimize\n       * because KeyframeTrackPrototype optimizes times and values but\n       * doesn't optimize interpolations.\n       */\n      if (times.length > 2) {\n        times = times.slice();\n        values = values.slice();\n        interpolations = interpolations.slice();\n        var stride = values.length / times.length;\n        var interpolateStride = interpolations.length / times.length;\n        var index = 1;\n        for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n          for (let i = 0; i < stride; i++) {\n            if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n              index++;\n              break;\n            }\n          }\n          if (aheadIndex > index) {\n            times[index] = times[aheadIndex];\n            for (let i = 0; i < stride; i++) {\n              values[index * stride + i] = values[aheadIndex * stride + i];\n            }\n            for (let i = 0; i < interpolateStride; i++) {\n              interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n            }\n          }\n        }\n        times.length = index + 1;\n        values.length = (index + 1) * stride;\n        interpolations.length = (index + 1) * interpolateStride;\n      }\n      var track = new typedKeyframeTrack(node, times, values);\n      track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n        return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n      };\n      return track;\n    }\n  }; // interpolation\n\n  function CubicBezierInterpolation(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  CubicBezierInterpolation.prototype = Object.assign(Object.create(Interpolant.prototype), {\n    constructor: CubicBezierInterpolation,\n    interpolate_: function (i1, t0, t, t1) {\n      var result = this.resultBuffer;\n      var values = this.sampleValues;\n      var stride = this.valueSize;\n      var params = this.interpolationParams;\n      var offset1 = i1 * stride;\n      var offset0 = offset1 - stride; // No interpolation if next key frame is in one frame in 30fps.\n      // This is from MMD animation spec.\n      // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\n      var weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n      if (stride === 4) {\n        // Quaternion\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n        Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n      } else if (stride === 3) {\n        // Vector3\n        for (let i = 0; i !== stride; ++i) {\n          var x1 = params[i1 * 12 + i * 4 + 0];\n          var x2 = params[i1 * 12 + i * 4 + 1];\n          var y1 = params[i1 * 12 + i * 4 + 2];\n          var y2 = params[i1 * 12 + i * 4 + 3];\n          var ratio = this._calculate(x1, x2, y1, y2, weight1);\n          result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n        }\n      } else {\n        // Number\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n      }\n      return result;\n    },\n    _calculate: function (x1, x2, y1, y2, x) {\n      /*\n       * Cubic Bezier curves\n       *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n       *\n       * B(t) = ( 1 - t ) ^ 3 * P0\n       *      + 3 * ( 1 - t ) ^ 2 * t * P1\n       *      + 3 * ( 1 - t ) * t^2 * P2\n       *      + t ^ 3 * P3\n       *      ( 0 <= t <= 1 )\n       *\n       * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n       *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n       *\n       *    x = ( 1 - t ) ^ 3 * x0\n       *      + 3 * ( 1 - t ) ^ 2 * t * x1\n       *      + 3 * ( 1 - t ) * t^2 * x2\n       *      + t ^ 3 * x3\n       *    y = ( 1 - t ) ^ 3 * y0\n       *      + 3 * ( 1 - t ) ^ 2 * t * y1\n       *      + 3 * ( 1 - t ) * t^2 * y2\n       *      + t ^ 3 * y3\n       *      ( x0 = 0, y0 = 0 )\n       *      ( x3 = 1, y3 = 1 )\n       *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n       *\n       * Here solves this equation with Bisection method,\n       *   https://en.wikipedia.org/wiki/Bisection_method\n       * gets t, and then calculate y.\n       *\n       * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n       *      + 3 * ( 1 - t ) * t^2 * x2\n       *      + t ^ 3 - x = 0\n       *\n       * (Another option: Newton's method\n       *    https://en.wikipedia.org/wiki/Newton%27s_method)\n       */\n      var c = 0.5;\n      var t = c;\n      var s = 1.0 - t;\n      var loop = 15;\n      var eps = 1e-5;\n      var math = Math;\n      var sst3, stt3, ttt;\n      for (let i = 0; i < loop; i++) {\n        sst3 = 3.0 * s * s * t;\n        stt3 = 3.0 * s * t * t;\n        ttt = t * t * t;\n        var ft = sst3 * x1 + stt3 * x2 + ttt - x;\n        if (math.abs(ft) < eps) break;\n        c /= 2.0;\n        t += ft < 0 ? c : -c;\n        s = 1.0 - t;\n      }\n      return sst3 * y1 + stt3 * y2 + ttt;\n    }\n  });\n  return MMDLoader;\n}();\nexport { MMDLoader };","map":{"version":3,"names":["Loader","LoaderUtils","Interpolant","Quaternion","FileLoader","SkinnedMesh","Skeleton","Bone","Vector3","Float32BufferAttribute","BufferGeometry","Uint16BufferAttribute","TextureLoader","Color","CustomBlending","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","DoubleSide","FrontSide","MultiplyOperation","AddOperation","MeshToonMaterial","NearestFilter","RepeatWrapping","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","NumberKeyframeTrack","Euler","TGALoader","Parser","MMDLoader","manager","call","loader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","prototype","Object","assign","create","constructor","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","undefined","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","skeleton","initBones","bind","bones","bone","gbone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","grant","ratio","isLocal","affectRotation","affectPosition","transformationClass","sort","a","b","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","setAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","tgaLoader","textures","color","diffuse","opacity","emissive","ambient","transparent","skinning","fog","blending","blendSrc","blendDst","blendSrcAlpha","blendDstAlpha","flag","side","fileName","fileNames","split","map","_loadTexture","extension","envMap","combine","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","textureIndex","envTextureIndex","envFlag","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","checkAlphaMorph","_getTGALoader","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","minFilter","flipY","wrapS","wrapT","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","morphTargetDictionary","morphName","values","weight","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","parameterPositions","sampleValues","sampleSize","resultBuffer","interpolationParams","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/MMDLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, Interpolant, Quaternion, FileLoader, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Euler } from 'three';\nimport { TGALoader } from './TGALoader.js';\nimport { Parser } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\nvar MMDLoader = function () {\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n  function MMDLoader(manager) {\n    Loader.call(this, manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null; // lazy generation\n\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n\n  MMDLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: MMDLoader,\n\n    /**\n     * @param {string} animationPath\n     * @return {MMDLoader}\n     */\n    setAnimationPath: function (animationPath) {\n      this.animationPath = animationPath;\n      return this;\n    },\n    // Load MMD assets as Three.js Object\n\n    /**\n     * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n     *\n     * @param {string} url - url to Model(.pmd or .pmx) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    load: function (url, onLoad, onProgress, onError) {\n      var builder = this.meshBuilder.setCrossOrigin(this.crossOrigin); // resource path\n\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      }\n\n      var modelExtension = this._extractExtension(url).toLowerCase(); // Should I detect by seeing header?\n\n\n      if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n        if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'));\n        return;\n      }\n\n      this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](url, function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      }, onProgress, onError);\n    },\n\n    /**\n     * Loads Motion file(s) (.vmd) as a AnimationClip.\n     * If two or more files are specified, they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n     * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadAnimation: function (url, object, onLoad, onProgress, onError) {\n      var builder = this.animationBuilder;\n      this.loadVMD(url, function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      }, onProgress, onError);\n    },\n\n    /**\n     * Loads mode file and motion file(s) as an object containing\n     * a SkinnedMesh and a AnimationClip.\n     * Tracks of AnimationClip are fitting to the model.\n     *\n     * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n     * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadWithAnimation: function (modelUrl, vmdUrl, onLoad, onProgress, onError) {\n      var scope = this;\n      this.load(modelUrl, function (mesh) {\n        scope.loadAnimation(vmdUrl, mesh, function (animation) {\n          onLoad({\n            mesh: mesh,\n            animation: animation\n          });\n        }, onProgress, onError);\n      }, onProgress, onError);\n    },\n    // Load MMD assets as Object data parsed by MMDParser\n\n    /**\n     * Loads .pmd file as an Object.\n     *\n     * @param {string} url - url to .pmd file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadPMD: function (url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      }, onProgress, onError);\n    },\n\n    /**\n     * Loads .pmx file as an Object.\n     *\n     * @param {string} url - url to .pmx file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadPMX: function (url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      }, onProgress, onError);\n    },\n\n    /**\n     * Loads .vmd file as an Object. If two or more files are specified\n     * they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to .vmd file(s)\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadVMD: function (url, onLoad, onProgress, onError) {\n      var urls = Array.isArray(url) ? url : [url];\n      var vmds = [];\n      var vmdNum = urls.length;\n\n      var parser = this._getParser();\n\n      this.loader.setMimeType(undefined).setPath(this.animationPath).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n\n      for (let i = 0, il = urls.length; i < il; i++) {\n        this.loader.load(urls[i], function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n        }, onProgress, onError);\n      }\n    },\n\n    /**\n     * Loads .vpd file as an Object.\n     *\n     * @param {string} url - url to .vpd file\n     * @param {boolean} isUnicode\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n    loadVPD: function (url, isUnicode, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis').setPath(this.animationPath).setResponseType('text').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n        onLoad(parser.parseVpd(text, true));\n      }, onProgress, onError);\n    },\n    // private methods\n    _extractExtension: function (url) {\n      var index = url.lastIndexOf('.');\n      return index < 0 ? '' : url.slice(index + 1);\n    },\n    _getParser: function () {\n      if (this.parser === null) {\n        this.parser = new Parser(); // eslint-disable-line no-undef\n      }\n\n      return this.parser;\n    }\n  }); // Utilities\n\n  /*\n   * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n   * We don't need to request external toon image files.\n   * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n   */\n\n  var DEFAULT_TOON_TEXTURES = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=']; // Builders. They build Three.js object from Object data parsed by MMDParser.\n\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n\n  function MeshBuilder(manager) {\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n\n  MeshBuilder.prototype = {\n    constructor: MeshBuilder,\n    crossOrigin: 'anonymous',\n\n    /**\n     * @param {string} crossOrigin\n     * @return {MeshBuilder}\n     */\n    setCrossOrigin: function (crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    },\n\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {string} resourcePath\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {SkinnedMesh}\n     */\n    build: function (data, resourcePath, onProgress, onError) {\n      var geometry = this.geometryBuilder.build(data);\n      var material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n      var mesh = new SkinnedMesh(geometry, material);\n      var skeleton = new Skeleton(initBones(mesh));\n      mesh.bind(skeleton); // console.log( mesh ); // for console debug\n\n      return mesh;\n    }\n  }; // TODO: Try to remove this function\n\n  function initBones(mesh) {\n    var geometry = mesh.geometry;\n    var bones = [],\n        bone,\n        gbone;\n    var i, il;\n\n    if (geometry && geometry.bones !== undefined) {\n      // first, create array of 'Bone' objects from geometry data\n      for (i = 0, il = geometry.bones.length; i < il; i++) {\n        gbone = geometry.bones[i]; // create new 'Bone' object\n\n        bone = new Bone();\n        bones.push(bone); // apply values\n\n        bone.name = gbone.name;\n        bone.position.fromArray(gbone.pos);\n        bone.quaternion.fromArray(gbone.rotq);\n        if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n      } // second, create bone hierarchy\n\n\n      for (i = 0, il = geometry.bones.length; i < il; i++) {\n        gbone = geometry.bones[i];\n\n        if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n          // subsequent bones in the hierarchy\n          bones[gbone.parent].add(bones[i]);\n        } else {\n          // topmost bone, immediate child of the skinned mesh\n          mesh.add(bones[i]);\n        }\n      }\n    } // now the bones are part of the scene graph and children of the skinned mesh.\n    // let's update the corresponding matrices\n\n\n    mesh.updateMatrixWorld(true);\n    return bones;\n  } //\n\n\n  function GeometryBuilder() {}\n\n  GeometryBuilder.prototype = {\n    constructor: GeometryBuilder,\n\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @return {BufferGeometry}\n     */\n    build: function (data) {\n      // for geometry\n      var positions = [];\n      var uvs = [];\n      var normals = [];\n      var indices = [];\n      var groups = [];\n      var bones = [];\n      var skinIndices = [];\n      var skinWeights = [];\n      var morphTargets = [];\n      var morphPositions = [];\n      var iks = [];\n      var grants = [];\n      var rigidBodies = [];\n      var constraints = []; // for work\n\n      var offset = 0;\n      var boneTypeTable = {}; // positions, normals, uvs, skinIndices, skinWeights\n\n      for (let i = 0; i < data.metadata.vertexCount; i++) {\n        var v = data.vertices[i];\n\n        for (let j = 0, jl = v.position.length; j < jl; j++) {\n          positions.push(v.position[j]);\n        }\n\n        for (let j = 0, jl = v.normal.length; j < jl; j++) {\n          normals.push(v.normal[j]);\n        }\n\n        for (let j = 0, jl = v.uv.length; j < jl; j++) {\n          uvs.push(v.uv[j]);\n        }\n\n        for (let j = 0; j < 4; j++) {\n          skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n        }\n\n        for (let j = 0; j < 4; j++) {\n          skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n        }\n      } // indices\n\n\n      for (let i = 0; i < data.metadata.faceCount; i++) {\n        var face = data.faces[i];\n\n        for (let j = 0, jl = face.indices.length; j < jl; j++) {\n          indices.push(face.indices[j]);\n        }\n      } // groups\n\n\n      for (let i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        groups.push({\n          offset: offset * 3,\n          count: material.faceCount * 3\n        });\n        offset += material.faceCount;\n      } // bones\n\n\n      for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n        var body = data.rigidBodies[i];\n        var value = boneTypeTable[body.boneIndex]; // keeps greater number if already value is set without any special reasons\n\n        value = value === undefined ? body.type : Math.max(body.type, value);\n        boneTypeTable[body.boneIndex] = value;\n      }\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        var boneData = data.bones[i];\n        var bone = {\n          parent: boneData.parentIndex,\n          name: boneData.name,\n          pos: boneData.position.slice(0, 3),\n          rotq: [0, 0, 0, 1],\n          scl: [1, 1, 1],\n          rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1\n        };\n\n        if (bone.parent !== -1) {\n          bone.pos[0] -= data.bones[bone.parent].position[0];\n          bone.pos[1] -= data.bones[bone.parent].position[1];\n          bone.pos[2] -= data.bones[bone.parent].position[2];\n        }\n\n        bones.push(bone);\n      } // iks\n      // TODO: remove duplicated codes between PMD and PMX\n\n\n      if (data.metadata.format === 'pmd') {\n        for (let i = 0; i < data.metadata.ikCount; i++) {\n          var ik = data.iks[i];\n          var param = {\n            target: ik.target,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle * 4,\n            links: []\n          };\n\n          for (let j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = {};\n            link.index = ik.links[j].index;\n            link.enabled = true;\n\n            if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n              link.limitation = new Vector3(1.0, 0.0, 0.0);\n            }\n\n            param.links.push(link);\n          }\n\n          iks.push(param);\n        }\n      } else {\n        for (let i = 0; i < data.metadata.boneCount; i++) {\n          var ik = data.bones[i].ik;\n          if (ik === undefined) continue;\n          var param = {\n            target: i,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle,\n            links: []\n          };\n\n          for (let j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = {};\n            link.index = ik.links[j].index;\n            link.enabled = true;\n\n            if (ik.links[j].angleLimitation === 1) {\n              // Revert if rotationMin/Max doesn't work well\n              // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n              var rotationMin = ik.links[j].lowerLimitationAngle;\n              var rotationMax = ik.links[j].upperLimitationAngle; // Convert Left to Right coordinate by myself because\n              // MMDParser doesn't convert. It's a MMDParser's bug\n\n              var tmp1 = -rotationMax[0];\n              var tmp2 = -rotationMax[1];\n              rotationMax[0] = -rotationMin[0];\n              rotationMax[1] = -rotationMin[1];\n              rotationMin[0] = tmp1;\n              rotationMin[1] = tmp2;\n              link.rotationMin = new Vector3().fromArray(rotationMin);\n              link.rotationMax = new Vector3().fromArray(rotationMax);\n            }\n\n            param.links.push(link);\n          }\n\n          iks.push(param);\n        }\n      } // grants\n\n\n      if (data.metadata.format === 'pmx') {\n        for (let i = 0; i < data.metadata.boneCount; i++) {\n          var boneData = data.bones[i];\n          var grant = boneData.grant;\n          if (grant === undefined) continue;\n          var param = {\n            index: i,\n            parentIndex: grant.parentIndex,\n            ratio: grant.ratio,\n            isLocal: grant.isLocal,\n            affectRotation: grant.affectRotation,\n            affectPosition: grant.affectPosition,\n            transformationClass: boneData.transformationClass\n          };\n          grants.push(param);\n        }\n\n        grants.sort(function (a, b) {\n          return a.transformationClass - b.transformationClass;\n        });\n      } // morph\n\n\n      function updateAttributes(attribute, morph, ratio) {\n        for (let i = 0; i < morph.elementCount; i++) {\n          var element = morph.elements[i];\n          var index;\n\n          if (data.metadata.format === 'pmd') {\n            index = data.morphs[0].elements[element.index].index;\n          } else {\n            index = element.index;\n          }\n\n          attribute.array[index * 3 + 0] += element.position[0] * ratio;\n          attribute.array[index * 3 + 1] += element.position[1] * ratio;\n          attribute.array[index * 3 + 2] += element.position[2] * ratio;\n        }\n      }\n\n      for (let i = 0; i < data.metadata.morphCount; i++) {\n        var morph = data.morphs[i];\n        var params = {\n          name: morph.name\n        };\n        var attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n        attribute.name = morph.name;\n\n        for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n          attribute.array[j] = positions[j];\n        }\n\n        if (data.metadata.format === 'pmd') {\n          if (i !== 0) {\n            updateAttributes(attribute, morph, 1.0);\n          }\n        } else {\n          if (morph.type === 0) {\n            // group\n            for (let j = 0; j < morph.elementCount; j++) {\n              var morph2 = data.morphs[morph.elements[j].index];\n              var ratio = morph.elements[j].ratio;\n\n              if (morph2.type === 1) {\n                updateAttributes(attribute, morph2, ratio);\n              }\n            }\n          } else if (morph.type === 1) {\n            // vertex\n            updateAttributes(attribute, morph, 1.0);\n          } else if (morph.type === 2) ; else if (morph.type === 3) ; else if (morph.type === 4) ; else if (morph.type === 5) ; else if (morph.type === 6) ; else if (morph.type === 7) ; else if (morph.type === 8) ;\n        }\n\n        morphTargets.push(params);\n        morphPositions.push(attribute);\n      } // rigid bodies from rigidBodies field.\n\n\n      for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n        var rigidBody = data.rigidBodies[i];\n        var params = {};\n\n        for (let key in rigidBody) {\n          params[key] = rigidBody[key];\n        }\n        /*\n         * RigidBody position parameter in PMX seems global position\n         * while the one in PMD seems offset from corresponding bone.\n         * So unify being offset.\n         */\n\n\n        if (data.metadata.format === 'pmx') {\n          if (params.boneIndex !== -1) {\n            var bone = data.bones[params.boneIndex];\n            params.position[0] -= bone.position[0];\n            params.position[1] -= bone.position[1];\n            params.position[2] -= bone.position[2];\n          }\n        }\n\n        rigidBodies.push(params);\n      } // constraints from constraints field.\n\n\n      for (let i = 0; i < data.metadata.constraintCount; i++) {\n        var constraint = data.constraints[i];\n        var params = {};\n\n        for (let key in constraint) {\n          params[key] = constraint[key];\n        }\n\n        var bodyA = rigidBodies[params.rigidBodyIndex1];\n        var bodyB = rigidBodies[params.rigidBodyIndex2]; // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\n        if (bodyA.type !== 0 && bodyB.type === 2) {\n          if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n            bodyB.type = 1;\n          }\n        }\n\n        constraints.push(params);\n      } // build BufferGeometry.\n\n\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n      geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n      geometry.setIndex(indices);\n\n      for (let i = 0, il = groups.length; i < il; i++) {\n        geometry.addGroup(groups[i].offset, groups[i].count, i);\n      }\n\n      geometry.bones = bones;\n      geometry.morphTargets = morphTargets;\n      geometry.morphAttributes.position = morphPositions;\n      geometry.morphTargetsRelative = false;\n      geometry.userData.MMD = {\n        bones: bones,\n        iks: iks,\n        grants: grants,\n        rigidBodies: rigidBodies,\n        constraints: constraints,\n        format: data.metadata.format\n      };\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n  }; //\n\n  /**\n   * @param {THREE.LoadingManager} manager\n   */\n\n  function MaterialBuilder(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null; // lazy generation\n  }\n\n  MaterialBuilder.prototype = {\n    constructor: MaterialBuilder,\n    crossOrigin: 'anonymous',\n    resourcePath: undefined,\n\n    /**\n     * @param {string} crossOrigin\n     * @return {MaterialBuilder}\n     */\n    setCrossOrigin: function (crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    },\n\n    /**\n     * @param {string} resourcePath\n     * @return {MaterialBuilder}\n     */\n    setResourcePath: function (resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    },\n\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {BufferGeometry} geometry - some properties are dependend on geometry\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {Array<MeshToonMaterial>}\n     */\n    build: function (data, geometry\n    /*, onProgress, onError */\n    ) {\n      var materials = [];\n      var textures = {};\n      this.textureLoader.setCrossOrigin(this.crossOrigin); // materials\n\n      for (let i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        var params = {\n          userData: {}\n        };\n        if (material.name !== undefined) params.name = material.name;\n        /*\n         * Color\n         *\n         * MMD         MeshToonMaterial\n         * diffuse  -  color\n         * ambient  -  emissive * a\n         *               (a = 1.0 without map texture or 0.2 with map texture)\n         *\n         * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n         * It'll be too bright if material has map texture so using coef 0.2.\n         */\n\n        params.color = new Color().fromArray(material.diffuse);\n        params.opacity = material.diffuse[3];\n        params.emissive = new Color().fromArray(material.ambient);\n        params.transparent = params.opacity !== 1.0; //\n\n        params.skinning = geometry.bones.length > 0 ? true : false;\n        params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n        params.fog = true; // blend\n\n        params.blending = CustomBlending;\n        params.blendSrc = SrcAlphaFactor;\n        params.blendDst = OneMinusSrcAlphaFactor;\n        params.blendSrcAlpha = SrcAlphaFactor;\n        params.blendDstAlpha = DstAlphaFactor; // side\n\n        if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n          params.side = DoubleSide;\n        } else {\n          params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n        }\n\n        if (data.metadata.format === 'pmd') {\n          // map, envMap\n          if (material.fileName) {\n            var fileName = material.fileName;\n            var fileNames = fileName.split('*'); // fileNames[ 0 ]: mapFileName\n            // fileNames[ 1 ]: envMapFileName( optional )\n\n            params.map = this._loadTexture(fileNames[0], textures);\n\n            if (fileNames.length > 1) {\n              var extension = fileNames[1].slice(-4).toLowerCase();\n              params.envMap = this._loadTexture(fileNames[1], textures);\n              params.combine = extension === '.sph' ? MultiplyOperation : AddOperation;\n            }\n          } // gradientMap\n\n\n          var toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName;\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n          }); // parameters for OutlineEffect\n\n          params.userData.outlineParameters = {\n            thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n            color: [0, 0, 0],\n            alpha: 1.0,\n            visible: material.edgeFlag === 1\n          };\n        } else {\n          // map\n          if (material.textureIndex !== -1) {\n            params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n          } // envMap TODO: support m.envFlag === 3\n\n\n          if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n            params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n            params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n          } // gradientMap\n\n\n          var toonFileName, isDefaultToon;\n\n          if (material.toonIndex === -1 || material.toonFlag !== 0) {\n            toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp';\n            isDefaultToon = true;\n          } else {\n            toonFileName = data.textures[material.toonIndex];\n            isDefaultToon = false;\n          }\n\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: isDefaultToon\n          }); // parameters for OutlineEffect\n\n          params.userData.outlineParameters = {\n            thickness: material.edgeSize / 300,\n            // TODO: better calculation?\n            color: material.edgeColor.slice(0, 3),\n            alpha: material.edgeColor[3],\n            visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0\n          };\n        }\n\n        if (params.map !== undefined) {\n          if (!params.transparent) {\n            this._checkImageTransparency(params.map, geometry, i);\n          }\n\n          params.emissive.multiplyScalar(0.2);\n        }\n\n        materials.push(new MeshToonMaterial(params));\n      }\n\n      if (data.metadata.format === 'pmx') {\n        // set transparent true if alpha morph is defined.\n        function checkAlphaMorph(elements, materials) {\n          for (let i = 0, il = elements.length; i < il; i++) {\n            var element = elements[i];\n            if (element.index === -1) continue;\n            var material = materials[element.index];\n\n            if (material.opacity !== element.diffuse[3]) {\n              material.transparent = true;\n            }\n          }\n        }\n\n        for (let i = 0, il = data.morphs.length; i < il; i++) {\n          var morph = data.morphs[i];\n          var elements = morph.elements;\n\n          if (morph.type === 0) {\n            for (let j = 0, jl = elements.length; j < jl; j++) {\n              var morph2 = data.morphs[elements[j].index];\n              if (morph2.type !== 8) continue;\n              checkAlphaMorph(morph2.elements, materials);\n            }\n          } else if (morph.type === 8) {\n            checkAlphaMorph(elements, materials);\n          }\n        }\n      }\n\n      return materials;\n    },\n    // private methods\n    _getTGALoader: function () {\n      if (this.tgaLoader === null) {\n        if (TGALoader === undefined) {\n          throw new Error('THREE.MMDLoader: Import TGALoader');\n        }\n\n        this.tgaLoader = new TGALoader(this.manager);\n      }\n\n      return this.tgaLoader;\n    },\n    _isDefaultToonTexture: function (name) {\n      if (name.length !== 10) return false;\n      return /toon(10|0[0-9])\\.bmp/.test(name);\n    },\n    _loadTexture: function (filePath, textures, params, onProgress, onError) {\n      params = params || {};\n      var scope = this;\n      var fullPath;\n\n      if (params.isDefaultToonTexture === true) {\n        var index;\n\n        try {\n          index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n        } catch (e) {\n          console.warn('THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.');\n          index = 0;\n        }\n\n        fullPath = DEFAULT_TOON_TEXTURES[index];\n      } else {\n        fullPath = this.resourcePath + filePath;\n      }\n\n      if (textures[fullPath] !== undefined) return textures[fullPath];\n      var loader = this.manager.getHandler(fullPath);\n\n      if (loader === null) {\n        loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader;\n      }\n\n      var texture = loader.load(fullPath, function (t) {\n        // MMD toon texture is Axis-Y oriented\n        // but Three.js gradient map is Axis-X oriented.\n        // So here replaces the toon texture image with the rotated one.\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n\n        delete texture.readyCallbacks;\n      }, onProgress, onError);\n      texture.readyCallbacks = [];\n      textures[fullPath] = texture;\n      return texture;\n    },\n    _getRotatedImage: function (image) {\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var width = image.width;\n      var height = image.height;\n      canvas.width = width;\n      canvas.height = height;\n      context.clearRect(0, 0, width, height);\n      context.translate(width / 2.0, height / 2.0);\n      context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\n      context.translate(-width / 2.0, -height / 2.0);\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, width, height);\n    },\n    // Check if the partial image area used by the texture is transparent.\n    _checkImageTransparency: function (map, geometry, groupIndex) {\n      map.readyCallbacks.push(function (texture) {\n        // Is there any efficient ways?\n        function createImageData(image) {\n          var canvas = document.createElement('canvas');\n          canvas.width = image.width;\n          canvas.height = image.height;\n          var context = canvas.getContext('2d');\n          context.drawImage(image, 0, 0);\n          return context.getImageData(0, 0, canvas.width, canvas.height);\n        }\n\n        function detectImageTransparency(image, uvs, indices) {\n          var width = image.width;\n          var height = image.height;\n          var data = image.data;\n          var threshold = 253;\n          if (data.length / (width * height) !== 4) return false;\n\n          for (let i = 0; i < indices.length; i += 3) {\n            var centerUV = {\n              x: 0.0,\n              y: 0.0\n            };\n\n            for (let j = 0; j < 3; j++) {\n              var index = indices[i * 3 + j];\n              var uv = {\n                x: uvs[index * 2 + 0],\n                y: uvs[index * 2 + 1]\n              };\n              if (getAlphaByUv(image, uv) < threshold) return true;\n              centerUV.x += uv.x;\n              centerUV.y += uv.y;\n            }\n\n            centerUV.x /= 3;\n            centerUV.y /= 3;\n            if (getAlphaByUv(image, centerUV) < threshold) return true;\n          }\n\n          return false;\n        }\n        /*\n         * This method expects\n         *   texture.flipY = false\n         *   texture.wrapS = RepeatWrapping\n         *   texture.wrapT = RepeatWrapping\n         * TODO: more precise\n         */\n\n\n        function getAlphaByUv(image, uv) {\n          var width = image.width;\n          var height = image.height;\n          var x = Math.round(uv.x * width) % width;\n          var y = Math.round(uv.y * height) % height;\n          if (x < 0) x += width;\n          if (y < 0) y += height;\n          var index = y * width + x;\n          return image.data[index * 4 + 3];\n        }\n\n        var imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image);\n        var group = geometry.groups[groupIndex];\n\n        if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n          map.transparent = true;\n        }\n      });\n    }\n  }; //\n\n  function AnimationBuilder() {}\n\n  AnimationBuilder.prototype = {\n    constructor: AnimationBuilder,\n\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    build: function (vmd, mesh) {\n      // combine skeletal and morph animations\n      var tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n      var tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n\n      for (let i = 0, il = tracks2.length; i < il; i++) {\n        tracks.push(tracks2[i]);\n      }\n\n      return new AnimationClip('', -1, tracks);\n    },\n\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    buildSkeletalAnimation: function (vmd, mesh) {\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index + 0] / 127); // x1\n\n        array.push(interpolation[index + 8] / 127); // x2\n\n        array.push(interpolation[index + 4] / 127); // y1\n\n        array.push(interpolation[index + 12] / 127); // y2\n      }\n\n      var tracks = [];\n      var motions = {};\n      var bones = mesh.skeleton.bones;\n      var boneNameDictionary = {};\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = true;\n      }\n\n      for (let i = 0; i < vmd.metadata.motionCount; i++) {\n        var motion = vmd.motions[i];\n        var boneName = motion.boneName;\n        if (boneNameDictionary[boneName] === undefined) continue;\n        motions[boneName] = motions[boneName] || [];\n        motions[boneName].push(motion);\n      }\n\n      for (let key in motions) {\n        var array = motions[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var positions = [];\n        var rotations = [];\n        var pInterpolations = [];\n        var rInterpolations = [];\n        var basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n\n        for (let i = 0, il = array.length; i < il; i++) {\n          var time = array[i].frameNum / 30;\n          var position = array[i].position;\n          var rotation = array[i].rotation;\n          var interpolation = array[i].interpolation;\n          times.push(time);\n\n          for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n\n          for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n\n          for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n\n          pushInterpolation(rInterpolations, interpolation, 3);\n        }\n\n        var targetName = '.bones[' + key + ']';\n        tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations));\n        tracks.push(this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations));\n      }\n\n      return new AnimationClip('', -1, tracks);\n    },\n\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    buildMorphAnimation: function (vmd, mesh) {\n      var tracks = [];\n      var morphs = {};\n      var morphTargetDictionary = mesh.morphTargetDictionary;\n\n      for (let i = 0; i < vmd.metadata.morphCount; i++) {\n        var morph = vmd.morphs[i];\n        var morphName = morph.morphName;\n        if (morphTargetDictionary[morphName] === undefined) continue;\n        morphs[morphName] = morphs[morphName] || [];\n        morphs[morphName].push(morph);\n      }\n\n      for (let key in morphs) {\n        var array = morphs[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var values = [];\n\n        for (let i = 0, il = array.length; i < il; i++) {\n          times.push(array[i].frameNum / 30);\n          values.push(array[i].weight);\n        }\n\n        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values));\n      }\n\n      return new AnimationClip('', -1, tracks);\n    },\n\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @return {AnimationClip}\n     */\n    buildCameraAnimation: function (vmd) {\n      function pushVector3(array, vec) {\n        array.push(vec.x);\n        array.push(vec.y);\n        array.push(vec.z);\n      }\n\n      function pushQuaternion(array, q) {\n        array.push(q.x);\n        array.push(q.y);\n        array.push(q.z);\n        array.push(q.w);\n      }\n\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index * 4 + 0] / 127); // x1\n\n        array.push(interpolation[index * 4 + 1] / 127); // x2\n\n        array.push(interpolation[index * 4 + 2] / 127); // y1\n\n        array.push(interpolation[index * 4 + 3] / 127); // y2\n      }\n\n      var tracks = [];\n      var cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n      cameras.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      var times = [];\n      var centers = [];\n      var quaternions = [];\n      var positions = [];\n      var fovs = [];\n      var cInterpolations = [];\n      var qInterpolations = [];\n      var pInterpolations = [];\n      var fInterpolations = [];\n      var quaternion = new Quaternion();\n      var euler = new Euler();\n      var position = new Vector3();\n      var center = new Vector3();\n\n      for (let i = 0, il = cameras.length; i < il; i++) {\n        var motion = cameras[i];\n        var time = motion.frameNum / 30;\n        var pos = motion.position;\n        var rot = motion.rotation;\n        var distance = motion.distance;\n        var fov = motion.fov;\n        var interpolation = motion.interpolation;\n        times.push(time);\n        position.set(0, 0, -distance);\n        center.set(pos[0], pos[1], pos[2]);\n        euler.set(-rot[0], -rot[1], -rot[2]);\n        quaternion.setFromEuler(euler);\n        position.add(center);\n        position.applyQuaternion(quaternion);\n        pushVector3(centers, center);\n        pushQuaternion(quaternions, quaternion);\n        pushVector3(positions, position);\n        fovs.push(fov);\n\n        for (let j = 0; j < 3; j++) {\n          pushInterpolation(cInterpolations, interpolation, j);\n        }\n\n        pushInterpolation(qInterpolations, interpolation, 3); // use the same parameter for x, y, z axis.\n\n        for (let j = 0; j < 3; j++) {\n          pushInterpolation(pInterpolations, interpolation, 4);\n        }\n\n        pushInterpolation(fInterpolations, interpolation, 5);\n      }\n\n      var tracks = []; // I expect an object whose name 'target' exists under THREE.Camera\n\n      tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations));\n      tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n      tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations));\n      return new AnimationClip('', -1, tracks);\n    },\n    // private method\n    _createTrack: function (node, typedKeyframeTrack, times, values, interpolations) {\n      /*\n       * optimizes here not to let KeyframeTrackPrototype optimize\n       * because KeyframeTrackPrototype optimizes times and values but\n       * doesn't optimize interpolations.\n       */\n      if (times.length > 2) {\n        times = times.slice();\n        values = values.slice();\n        interpolations = interpolations.slice();\n        var stride = values.length / times.length;\n        var interpolateStride = interpolations.length / times.length;\n        var index = 1;\n\n        for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n          for (let i = 0; i < stride; i++) {\n            if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n              index++;\n              break;\n            }\n          }\n\n          if (aheadIndex > index) {\n            times[index] = times[aheadIndex];\n\n            for (let i = 0; i < stride; i++) {\n              values[index * stride + i] = values[aheadIndex * stride + i];\n            }\n\n            for (let i = 0; i < interpolateStride; i++) {\n              interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n            }\n          }\n        }\n\n        times.length = index + 1;\n        values.length = (index + 1) * stride;\n        interpolations.length = (index + 1) * interpolateStride;\n      }\n\n      var track = new typedKeyframeTrack(node, times, values);\n\n      track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n        return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n      };\n\n      return track;\n    }\n  }; // interpolation\n\n  function CubicBezierInterpolation(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n\n  CubicBezierInterpolation.prototype = Object.assign(Object.create(Interpolant.prototype), {\n    constructor: CubicBezierInterpolation,\n    interpolate_: function (i1, t0, t, t1) {\n      var result = this.resultBuffer;\n      var values = this.sampleValues;\n      var stride = this.valueSize;\n      var params = this.interpolationParams;\n      var offset1 = i1 * stride;\n      var offset0 = offset1 - stride; // No interpolation if next key frame is in one frame in 30fps.\n      // This is from MMD animation spec.\n      // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\n      var weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n\n      if (stride === 4) {\n        // Quaternion\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n        Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n      } else if (stride === 3) {\n        // Vector3\n        for (let i = 0; i !== stride; ++i) {\n          var x1 = params[i1 * 12 + i * 4 + 0];\n          var x2 = params[i1 * 12 + i * 4 + 1];\n          var y1 = params[i1 * 12 + i * 4 + 2];\n          var y2 = params[i1 * 12 + i * 4 + 3];\n\n          var ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n          result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n        }\n      } else {\n        // Number\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n        result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n      }\n\n      return result;\n    },\n    _calculate: function (x1, x2, y1, y2, x) {\n      /*\n       * Cubic Bezier curves\n       *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n       *\n       * B(t) = ( 1 - t ) ^ 3 * P0\n       *      + 3 * ( 1 - t ) ^ 2 * t * P1\n       *      + 3 * ( 1 - t ) * t^2 * P2\n       *      + t ^ 3 * P3\n       *      ( 0 <= t <= 1 )\n       *\n       * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n       *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n       *\n       *    x = ( 1 - t ) ^ 3 * x0\n       *      + 3 * ( 1 - t ) ^ 2 * t * x1\n       *      + 3 * ( 1 - t ) * t^2 * x2\n       *      + t ^ 3 * x3\n       *    y = ( 1 - t ) ^ 3 * y0\n       *      + 3 * ( 1 - t ) ^ 2 * t * y1\n       *      + 3 * ( 1 - t ) * t^2 * y2\n       *      + t ^ 3 * y3\n       *      ( x0 = 0, y0 = 0 )\n       *      ( x3 = 1, y3 = 1 )\n       *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n       *\n       * Here solves this equation with Bisection method,\n       *   https://en.wikipedia.org/wiki/Bisection_method\n       * gets t, and then calculate y.\n       *\n       * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n       *      + 3 * ( 1 - t ) * t^2 * x2\n       *      + t ^ 3 - x = 0\n       *\n       * (Another option: Newton's method\n       *    https://en.wikipedia.org/wiki/Newton%27s_method)\n       */\n      var c = 0.5;\n      var t = c;\n      var s = 1.0 - t;\n      var loop = 15;\n      var eps = 1e-5;\n      var math = Math;\n      var sst3, stt3, ttt;\n\n      for (let i = 0; i < loop; i++) {\n        sst3 = 3.0 * s * s * t;\n        stt3 = 3.0 * s * t * t;\n        ttt = t * t * t;\n        var ft = sst3 * x1 + stt3 * x2 + ttt - x;\n        if (math.abs(ft) < eps) break;\n        c /= 2.0;\n        t += ft < 0 ? c : -c;\n        s = 1.0 - t;\n      }\n\n      return sst3 * y1 + stt3 * y2 + ttt;\n    }\n  });\n  return MMDLoader;\n}();\n\nexport { MMDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}