{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\nvar DRACOLoader = function (manager) {\n  Loader.call(this, manager);\n  this.decoderPath = '';\n  this.decoderConfig = {};\n  this.decoderBinary = null;\n  this.decoderPending = null;\n  this.workerLimit = 4;\n  this.workerPool = [];\n  this.workerNextTaskID = 1;\n  this.workerSourceURL = '';\n  this.defaultAttributeIDs = {\n    position: 'POSITION',\n    normal: 'NORMAL',\n    color: 'COLOR',\n    uv: 'TEX_COORD'\n  };\n  this.defaultAttributeTypes = {\n    position: 'Float32Array',\n    normal: 'Float32Array',\n    color: 'Float32Array',\n    uv: 'Float32Array'\n  };\n};\nDRACOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: DRACOLoader,\n  setDecoderPath: function (path) {\n    this.decoderPath = path;\n    return this;\n  },\n  setDecoderConfig: function (config) {\n    this.decoderConfig = config;\n    return this;\n  },\n  setWorkerLimit: function (workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  },\n  /** @deprecated */\n  setVerbosity: function () {\n    console.warn('THREE.DRACOLoader: The .setVerbosity() method has been removed.');\n  },\n  /** @deprecated */\n  setDrawMode: function () {\n    console.warn('THREE.DRACOLoader: The .setDrawMode() method has been removed.');\n  },\n  /** @deprecated */\n  setSkipDequantization: function () {\n    console.warn('THREE.DRACOLoader: The .setSkipDequantization() method has been removed.');\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      var taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  },\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile: function (buffer, callback, attributeIDs, attributeTypes) {\n    var taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  },\n  decodeGeometry: function (buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (let attribute in taskConfig.attributeTypes) {\n      var type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n    var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (DRACOLoader.taskCache.has(buffer)) {\n      var cachedTask = DRACOLoader.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n    var worker;\n    var taskID = this.workerNextTaskID++;\n    var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    var geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n      }\n    }); // Cache the task result.\n\n    DRACOLoader.taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  },\n  _createGeometry: function (geometryData) {\n    var geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      var attribute = geometryData.attributes[i];\n      var name = attribute.name;\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  },\n  _loadLibrary: function (url, responseType) {\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  },\n  preload: function () {\n    this._initDecoder();\n    return this;\n  },\n  _initDecoder: function () {\n    if (this.decoderPending) return this.decoderPending;\n    var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    var librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      var jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      var fn = DRACOLoader.DRACOWorker.toString();\n      var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  },\n  _getWorker: function (taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        var worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n        worker.onmessage = function (e) {\n          var message = e.data;\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n              break;\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      var worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  },\n  _releaseTask: function (worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  },\n  debug: function () {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  },\n  dispose: function () {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n});\n/* WEB WORKER */\n\nDRACOLoader.DRACOWorker = function () {\n  var decoderConfig;\n  var decoderPending;\n  onmessage = function (e) {\n    var message = e.data;\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (let attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute;\n      var attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n    var ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n    var ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n};\nDRACOLoader.taskCache = new WeakMap();\n/** Deprecated static methods */\n\n/** @deprecated */\n\nDRACOLoader.setDecoderPath = function () {\n  console.warn('THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\nDRACOLoader.setDecoderConfig = function () {\n  console.warn('THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\nDRACOLoader.releaseDecoderModule = function () {\n  console.warn('THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\nDRACOLoader.getDecoderModule = function () {\n  console.warn('THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.');\n};\nexport { DRACOLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","DRACOLoader","manager","call","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","prototype","Object","assign","create","constructor","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","setVerbosity","console","warn","setDrawMode","setSkipDequantization","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","type","BYTES_PER_ELEMENT","undefined","name","taskKey","JSON","stringify","taskCache","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","error","sort","a","b","debug","log","map","dispose","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32","WeakMap","releaseDecoderModule","getDecoderModule"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/DRACOLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\nvar DRACOLoader = function (manager) {\n  Loader.call(this, manager);\n  this.decoderPath = '';\n  this.decoderConfig = {};\n  this.decoderBinary = null;\n  this.decoderPending = null;\n  this.workerLimit = 4;\n  this.workerPool = [];\n  this.workerNextTaskID = 1;\n  this.workerSourceURL = '';\n  this.defaultAttributeIDs = {\n    position: 'POSITION',\n    normal: 'NORMAL',\n    color: 'COLOR',\n    uv: 'TEX_COORD'\n  };\n  this.defaultAttributeTypes = {\n    position: 'Float32Array',\n    normal: 'Float32Array',\n    color: 'Float32Array',\n    uv: 'Float32Array'\n  };\n};\n\nDRACOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: DRACOLoader,\n  setDecoderPath: function (path) {\n    this.decoderPath = path;\n    return this;\n  },\n  setDecoderConfig: function (config) {\n    this.decoderConfig = config;\n    return this;\n  },\n  setWorkerLimit: function (workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  },\n\n  /** @deprecated */\n  setVerbosity: function () {\n    console.warn('THREE.DRACOLoader: The .setVerbosity() method has been removed.');\n  },\n\n  /** @deprecated */\n  setDrawMode: function () {\n    console.warn('THREE.DRACOLoader: The .setDrawMode() method has been removed.');\n  },\n\n  /** @deprecated */\n  setSkipDequantization: function () {\n    console.warn('THREE.DRACOLoader: The .setSkipDequantization() method has been removed.');\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      var taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  },\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile: function (buffer, callback, attributeIDs, attributeTypes) {\n    var taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  },\n  decodeGeometry: function (buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (let attribute in taskConfig.attributeTypes) {\n      var type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n\n    var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (DRACOLoader.taskCache.has(buffer)) {\n      var cachedTask = DRACOLoader.taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    var worker;\n    var taskID = this.workerNextTaskID++;\n    var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    var geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    DRACOLoader.taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  },\n  _createGeometry: function (geometryData) {\n    var geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      var attribute = geometryData.attributes[i];\n      var name = attribute.name;\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  },\n  _loadLibrary: function (url, responseType) {\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  },\n  preload: function () {\n    this._initDecoder();\n\n    return this;\n  },\n  _initDecoder: function () {\n    if (this.decoderPending) return this.decoderPending;\n    var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    var librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      var jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      var fn = DRACOLoader.DRACOWorker.toString();\n      var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  },\n  _getWorker: function (taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        var worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          var message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      var worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  },\n  _releaseTask: function (worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  },\n  debug: function () {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  },\n  dispose: function () {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n});\n/* WEB WORKER */\n\nDRACOLoader.DRACOWorker = function () {\n  var decoderConfig;\n  var decoderPending;\n\n  onmessage = function (e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (let attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute;\n      var attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n};\n\nDRACOLoader.taskCache = new WeakMap();\n/** Deprecated static methods */\n\n/** @deprecated */\n\nDRACOLoader.setDecoderPath = function () {\n  console.warn('THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nDRACOLoader.setDecoderConfig = function () {\n  console.warn('THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nDRACOLoader.releaseDecoderModule = function () {\n  console.warn('THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nDRACOLoader.getDecoderModule = function () {\n  console.warn('THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.');\n};\n\nexport { DRACOLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}