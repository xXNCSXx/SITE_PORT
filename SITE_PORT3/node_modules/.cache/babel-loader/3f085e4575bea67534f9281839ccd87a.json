{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\nReflectNode.prototype.getType = function () /* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n  return this.type;\n};\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n  if (builder.isShader('fragment')) {\n    var result;\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = `reflect( -normalize( ${viewPosition} ), ${viewNormal} )`;\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = `normalize( mix( ${method}, ${viewNormal}, ${roughness} * ${roughness} ) )`;\n        }\n        var code = `inverseTransformDirection( ${method}, viewMatrix )`;\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectVec = ${code};`);\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n        break;\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectCubeVec = ${code};`);\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n        break;\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n        if (isUnique) {\n          builder.addNodeCode(`vec2 reflectSphereVec = ${code};`);\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n        break;\n    }\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n  return data;\n};\nexport { ReflectNode };","map":{"version":3,"names":["TempNode","PositionNode","NormalNode","ReflectNode","scope","call","CUBE","SPHERE","VECTOR","prototype","Object","create","constructor","nodeType","getUnique","builder","context","viewNormal","getType","type","generate","output","isUnique","isShader","result","viewNormalNode","VIEW","roughnessNode","roughness","build","viewPosition","undefined","method","code","addNodeCode","reflectVec","format","console","warn","shader","toJSON","meta","data","getJSONNode","createJSONNode"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/accessors/ReflectNode.js"],"sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = `reflect( -normalize( ${viewPosition} ), ${viewNormal} )`;\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = `normalize( mix( ${method}, ${viewNormal}, ${roughness} * ${roughness} ) )`;\n        }\n\n        var code = `inverseTransformDirection( ${method}, viewMatrix )`;\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectVec = ${code};`);\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectCubeVec = ${code};`);\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec2 reflectSphereVec = ${code};`);\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}