{"ast":null,"code":"import { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from 'three';\nvar OBJLoader = function () {\n  // o object_name | g group_name\n  var object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\n\n  var material_library_pattern = /^mtllib /; // usemtl material_name\n\n  var material_use_pattern = /^usemtl /; // usemap map_name\n\n  var map_use_pattern = /^usemap /;\n  var vA = new Vector3();\n  var vB = new Vector3();\n  var vC = new Vector3();\n  var ab = new Vector3();\n  var cb = new Vector3();\n  function ParserState() {\n    var state = {\n      objects: [],\n      object: {},\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: [],\n      materials: {},\n      materialLibraries: [],\n      startObject: function (name, fromDeclaration) {\n        // If the current object (initial from reset) is not from a g/o declaration in the parsed\n        // file. We need to use it for the first parsed g/o to keep things in sync.\n        if (this.object && this.object.fromDeclaration === false) {\n          this.object.name = name;\n          this.object.fromDeclaration = fromDeclaration !== false;\n          return;\n        }\n        var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n        this.object = {\n          name: name || '',\n          fromDeclaration: fromDeclaration !== false,\n          geometry: {\n            vertices: [],\n            normals: [],\n            colors: [],\n            uvs: [],\n            hasUVIndices: false\n          },\n          materials: [],\n          smooth: true,\n          startMaterial: function (name, libraries) {\n            var previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\n            // after the material, then it must be preserved for proper MultiMaterial continuation.\n\n            if (previous && (previous.inherited || previous.groupCount <= 0)) {\n              this.materials.splice(previous.index, 1);\n            }\n            var material = {\n              index: this.materials.length,\n              name: name || '',\n              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n              smooth: previous !== undefined ? previous.smooth : this.smooth,\n              groupStart: previous !== undefined ? previous.groupEnd : 0,\n              groupEnd: -1,\n              groupCount: -1,\n              inherited: false,\n              clone: function (index) {\n                var cloned = {\n                  index: typeof index === 'number' ? index : this.index,\n                  name: this.name,\n                  mtllib: this.mtllib,\n                  smooth: this.smooth,\n                  groupStart: 0,\n                  groupEnd: -1,\n                  groupCount: -1,\n                  inherited: false\n                };\n                cloned.clone = this.clone.bind(cloned);\n                return cloned;\n              }\n            };\n            this.materials.push(material);\n            return material;\n          },\n          currentMaterial: function () {\n            if (this.materials.length > 0) {\n              return this.materials[this.materials.length - 1];\n            }\n            return undefined;\n          },\n          _finalize: function (end) {\n            var lastMultiMaterial = this.currentMaterial();\n            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n              lastMultiMaterial.inherited = false;\n            } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\n            if (end && this.materials.length > 1) {\n              for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n                if (this.materials[mi].groupCount <= 0) {\n                  this.materials.splice(mi, 1);\n                }\n              }\n            } // Guarantee at least one empty material, this makes the creation later more straight forward.\n\n            if (end && this.materials.length === 0) {\n              this.materials.push({\n                name: '',\n                smooth: this.smooth\n              });\n            }\n            return lastMultiMaterial;\n          }\n        }; // Inherit previous objects material.\n        // Spec tells us that a declared material must be set to all objects until a new material is declared.\n        // If a usemtl declaration is encountered while this new object is being parsed, it will\n        // overwrite the inherited material. Exception being that there was already face declarations\n        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n          var declared = previousMaterial.clone(0);\n          declared.inherited = true;\n          this.object.materials.push(declared);\n        }\n        this.objects.push(this.object);\n      },\n      finalize: function () {\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n      },\n      parseVertexIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseNormalIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseUVIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 2) * 2;\n      },\n      addVertex: function (a, b, c) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addVertexPoint: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addVertexLine: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addNormal: function (a, b, c) {\n        var src = this.normals;\n        var dst = this.object.geometry.normals;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addFaceNormal: function (a, b, c) {\n        var src = this.vertices;\n        var dst = this.object.geometry.normals;\n        vA.fromArray(src, a);\n        vB.fromArray(src, b);\n        vC.fromArray(src, c);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        dst.push(cb.x, cb.y, cb.z);\n        dst.push(cb.x, cb.y, cb.z);\n        dst.push(cb.x, cb.y, cb.z);\n      },\n      addColor: function (a, b, c) {\n        var src = this.colors;\n        var dst = this.object.geometry.colors;\n        if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addUV: function (a, b, c) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n        dst.push(src[b + 0], src[b + 1]);\n        dst.push(src[c + 0], src[c + 1]);\n      },\n      addDefaultUV: function () {\n        var dst = this.object.geometry.uvs;\n        dst.push(0, 0);\n        dst.push(0, 0);\n        dst.push(0, 0);\n      },\n      addUVLine: function (a) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n      },\n      addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n        var vLen = this.vertices.length;\n        var ia = this.parseVertexIndex(a, vLen);\n        var ib = this.parseVertexIndex(b, vLen);\n        var ic = this.parseVertexIndex(c, vLen);\n        this.addVertex(ia, ib, ic);\n        this.addColor(ia, ib, ic); // normals\n\n        if (na !== undefined && na !== '') {\n          var nLen = this.normals.length;\n          ia = this.parseNormalIndex(na, nLen);\n          ib = this.parseNormalIndex(nb, nLen);\n          ic = this.parseNormalIndex(nc, nLen);\n          this.addNormal(ia, ib, ic);\n        } else {\n          this.addFaceNormal(ia, ib, ic);\n        } // uvs\n\n        if (ua !== undefined && ua !== '') {\n          var uvLen = this.uvs.length;\n          ia = this.parseUVIndex(ua, uvLen);\n          ib = this.parseUVIndex(ub, uvLen);\n          ic = this.parseUVIndex(uc, uvLen);\n          this.addUV(ia, ib, ic);\n          this.object.geometry.hasUVIndices = true;\n        } else {\n          // add placeholder values (for inconsistent face definitions)\n          this.addDefaultUV();\n        }\n      },\n      addPointGeometry: function (vertices) {\n        this.object.geometry.type = 'Points';\n        var vLen = this.vertices.length;\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          var index = this.parseVertexIndex(vertices[vi], vLen);\n          this.addVertexPoint(index);\n          this.addColor(index);\n        }\n      },\n      addLineGeometry: function (vertices, uvs) {\n        this.object.geometry.type = 'Line';\n        var vLen = this.vertices.length;\n        var uvLen = this.uvs.length;\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n        }\n        for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n        }\n      }\n    };\n    state.startObject('', false);\n    return state;\n  } //\n\n  function OBJLoader(manager) {\n    Loader.call(this, manager);\n    this.materials = null;\n  }\n  OBJLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: OBJLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    setMaterials: function (materials) {\n      this.materials = materials;\n      return this;\n    },\n    parse: function (text) {\n      var state = new ParserState();\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n      if (text.indexOf('\\\\\\n') !== -1) {\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n      }\n      var lines = text.split('\\n');\n      var line = '',\n        lineFirstChar = '';\n      var lineLength = 0;\n      var result = []; // Faster to just trim left side of the line. Use if available.\n\n      var trimLeft = typeof ''.trimLeft === 'function';\n      for (let i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0) continue;\n        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\n\n        if (lineFirstChar === '#') continue;\n        if (lineFirstChar === 'v') {\n          var data = line.split(/\\s+/);\n          switch (data[0]) {\n            case 'v':\n              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              if (data.length >= 7) {\n                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n              } else {\n                // if no colors are defined, add placeholders so color and vertex indices match\n                state.colors.push(undefined, undefined, undefined);\n              }\n              break;\n            case 'vn':\n              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              break;\n            case 'vt':\n              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n              break;\n          }\n        } else if (lineFirstChar === 'f') {\n          var lineData = line.substr(1).trim();\n          var vertexData = lineData.split(/\\s+/);\n          var faceVertices = []; // Parse the face vertex data into an easy to work with format\n\n          for (let j = 0, jl = vertexData.length; j < jl; j++) {\n            var vertex = vertexData[j];\n            if (vertex.length > 0) {\n              var vertexParts = vertex.split('/');\n              faceVertices.push(vertexParts);\n            }\n          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n          var v1 = faceVertices[0];\n          for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n            var v2 = faceVertices[j];\n            var v3 = faceVertices[j + 1];\n            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n          }\n        } else if (lineFirstChar === 'l') {\n          var lineParts = line.substring(1).trim().split(' ');\n          var lineVertices = [],\n            lineUVs = [];\n          if (line.indexOf('/') === -1) {\n            lineVertices = lineParts;\n          } else {\n            for (let li = 0, llen = lineParts.length; li < llen; li++) {\n              var parts = lineParts[li].split('/');\n              if (parts[0] !== '') lineVertices.push(parts[0]);\n              if (parts[1] !== '') lineUVs.push(parts[1]);\n            }\n          }\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if (lineFirstChar === 'p') {\n          var lineData = line.substr(1).trim();\n          var pointData = lineData.split(' ');\n          state.addPointGeometry(pointData);\n        } else if ((result = object_pattern.exec(line)) !== null) {\n          // o object_name\n          // or\n          // g group_name\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // var name = result[ 0 ].substr( 1 ).trim();\n          var name = (' ' + result[0].substr(1).trim()).substr(1);\n          state.startObject(name);\n        } else if (material_use_pattern.test(line)) {\n          // material\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (material_library_pattern.test(line)) {\n          // mtl file\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if (map_use_pattern.test(line)) {\n          // the line is parsed but ignored since the loader assumes textures are defined MTL files\n          // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n          console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n        } else if (lineFirstChar === 's') {\n          result = line.split(' '); // smooth shading\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          /*\n           * http://paulbourke.net/dataformats/obj/\n           * or\n           * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n           *\n           * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n           * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n           * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n           * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n           * than 0.\"\n           */\n\n          if (result.length > 1) {\n            var value = result[1].trim().toLowerCase();\n            state.object.smooth = value !== '0' && value !== 'off';\n          } else {\n            // ZBrush can produce \"s\" lines #11707\n            state.object.smooth = true;\n          }\n          var material = state.object.currentMaterial();\n          if (material) material.smooth = state.object.smooth;\n        } else {\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n          console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n        }\n      }\n      state.finalize();\n      var container = new Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n      var hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n      if (hasPrimitives === true) {\n        for (let i = 0, l = state.objects.length; i < l; i++) {\n          var object = state.objects[i];\n          var geometry = object.geometry;\n          var materials = object.materials;\n          var isLine = geometry.type === 'Line';\n          var isPoints = geometry.type === 'Points';\n          var hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\n\n          if (geometry.vertices.length === 0) continue;\n          var buffergeometry = new BufferGeometry();\n          buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));\n          if (geometry.normals.length > 0) {\n            buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));\n          }\n          if (geometry.colors.length > 0) {\n            hasVertexColors = true;\n            buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));\n          }\n          if (geometry.hasUVIndices === true) {\n            buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));\n          } // Create materials\n\n          var createdMaterials = [];\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            var sourceMaterial = materials[mi];\n            var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n            var material = state.materials[materialHash];\n            if (this.materials !== null) {\n              material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\n              if (isLine && material && !(material instanceof LineBasicMaterial)) {\n                var materialLine = new LineBasicMaterial();\n                Material.prototype.copy.call(materialLine, material);\n                materialLine.color.copy(material.color);\n                material = materialLine;\n              } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n                var materialPoints = new PointsMaterial({\n                  size: 10,\n                  sizeAttenuation: false\n                });\n                Material.prototype.copy.call(materialPoints, material);\n                materialPoints.color.copy(material.color);\n                materialPoints.map = material.map;\n                material = materialPoints;\n              }\n            }\n            if (material === undefined) {\n              if (isLine) {\n                material = new LineBasicMaterial();\n              } else if (isPoints) {\n                material = new PointsMaterial({\n                  size: 1,\n                  sizeAttenuation: false\n                });\n              } else {\n                material = new MeshPhongMaterial();\n              }\n              material.name = sourceMaterial.name;\n              material.flatShading = sourceMaterial.smooth ? false : true;\n              material.vertexColors = hasVertexColors;\n              state.materials[materialHash] = material;\n            }\n            createdMaterials.push(material);\n          } // Create mesh\n\n          var mesh;\n          if (createdMaterials.length > 1) {\n            for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n              var sourceMaterial = materials[mi];\n              buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n            }\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials);\n            }\n          } else {\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials[0]);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials[0]);\n            }\n          }\n          mesh.name = object.name;\n          container.add(mesh);\n        }\n      } else {\n        // if there is only the default parser state object with no geometry data, interpret data as point cloud\n        if (state.vertices.length > 0) {\n          var material = new PointsMaterial({\n            size: 1,\n            sizeAttenuation: false\n          });\n          var buffergeometry = new BufferGeometry();\n          buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));\n          if (state.colors.length > 0 && state.colors[0] !== undefined) {\n            buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));\n            material.vertexColors = true;\n          }\n          var points = new Points(buffergeometry, material);\n          container.add(points);\n        }\n      }\n      return container;\n    }\n  });\n  return OBJLoader;\n}();\nexport { OBJLoader };","map":{"version":3,"names":["Vector3","Loader","FileLoader","Group","BufferGeometry","Float32BufferAttribute","LineBasicMaterial","Material","PointsMaterial","MeshPhongMaterial","LineSegments","Points","Mesh","OBJLoader","object_pattern","material_library_pattern","material_use_pattern","map_use_pattern","vA","vB","vC","ab","cb","ParserState","state","objects","object","vertices","normals","colors","uvs","materials","materialLibraries","startObject","name","fromDeclaration","previousMaterial","currentMaterial","undefined","_finalize","geometry","hasUVIndices","smooth","startMaterial","libraries","previous","inherited","groupCount","splice","index","material","length","mtllib","Array","isArray","groupStart","groupEnd","clone","cloned","bind","push","end","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","value","len","parseInt","parseNormalIndex","parseUVIndex","addVertex","a","b","c","src","dst","addVertexPoint","addVertexLine","addNormal","addFaceNormal","fromArray","subVectors","cross","normalize","x","y","z","addColor","addUV","addDefaultUV","addUVLine","addFace","ua","ub","uc","na","nb","nc","vLen","ia","ib","ic","nLen","uvLen","addPointGeometry","type","vi","l","addLineGeometry","uvi","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterials","indexOf","replace","lines","split","line","lineFirstChar","lineLength","result","trimLeft","i","trim","charAt","data","parseFloat","lineData","substr","vertexData","faceVertices","j","jl","vertex","vertexParts","v1","v2","v3","lineParts","substring","lineVertices","lineUVs","li","llen","parts","pointData","exec","test","warn","toLowerCase","container","concat","hasPrimitives","isLine","isPoints","hasVertexColors","buffergeometry","setAttribute","createdMaterials","miLen","sourceMaterial","materialHash","materialLine","copy","color","materialPoints","size","sizeAttenuation","map","flatShading","vertexColors","mesh","addGroup","add","points"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/OBJLoader.js"],"sourcesContent":["import { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from 'three';\n\nvar OBJLoader = function () {\n  // o object_name | g group_name\n  var object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\n\n  var material_library_pattern = /^mtllib /; // usemtl material_name\n\n  var material_use_pattern = /^usemtl /; // usemap map_name\n\n  var map_use_pattern = /^usemap /;\n  var vA = new Vector3();\n  var vB = new Vector3();\n  var vC = new Vector3();\n  var ab = new Vector3();\n  var cb = new Vector3();\n\n  function ParserState() {\n    var state = {\n      objects: [],\n      object: {},\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: [],\n      materials: {},\n      materialLibraries: [],\n      startObject: function (name, fromDeclaration) {\n        // If the current object (initial from reset) is not from a g/o declaration in the parsed\n        // file. We need to use it for the first parsed g/o to keep things in sync.\n        if (this.object && this.object.fromDeclaration === false) {\n          this.object.name = name;\n          this.object.fromDeclaration = fromDeclaration !== false;\n          return;\n        }\n\n        var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n\n        this.object = {\n          name: name || '',\n          fromDeclaration: fromDeclaration !== false,\n          geometry: {\n            vertices: [],\n            normals: [],\n            colors: [],\n            uvs: [],\n            hasUVIndices: false\n          },\n          materials: [],\n          smooth: true,\n          startMaterial: function (name, libraries) {\n            var previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\n            // after the material, then it must be preserved for proper MultiMaterial continuation.\n\n\n            if (previous && (previous.inherited || previous.groupCount <= 0)) {\n              this.materials.splice(previous.index, 1);\n            }\n\n            var material = {\n              index: this.materials.length,\n              name: name || '',\n              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n              smooth: previous !== undefined ? previous.smooth : this.smooth,\n              groupStart: previous !== undefined ? previous.groupEnd : 0,\n              groupEnd: -1,\n              groupCount: -1,\n              inherited: false,\n              clone: function (index) {\n                var cloned = {\n                  index: typeof index === 'number' ? index : this.index,\n                  name: this.name,\n                  mtllib: this.mtllib,\n                  smooth: this.smooth,\n                  groupStart: 0,\n                  groupEnd: -1,\n                  groupCount: -1,\n                  inherited: false\n                };\n                cloned.clone = this.clone.bind(cloned);\n                return cloned;\n              }\n            };\n            this.materials.push(material);\n            return material;\n          },\n          currentMaterial: function () {\n            if (this.materials.length > 0) {\n              return this.materials[this.materials.length - 1];\n            }\n\n            return undefined;\n          },\n          _finalize: function (end) {\n            var lastMultiMaterial = this.currentMaterial();\n\n            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n              lastMultiMaterial.inherited = false;\n            } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\n\n            if (end && this.materials.length > 1) {\n              for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n                if (this.materials[mi].groupCount <= 0) {\n                  this.materials.splice(mi, 1);\n                }\n              }\n            } // Guarantee at least one empty material, this makes the creation later more straight forward.\n\n\n            if (end && this.materials.length === 0) {\n              this.materials.push({\n                name: '',\n                smooth: this.smooth\n              });\n            }\n\n            return lastMultiMaterial;\n          }\n        }; // Inherit previous objects material.\n        // Spec tells us that a declared material must be set to all objects until a new material is declared.\n        // If a usemtl declaration is encountered while this new object is being parsed, it will\n        // overwrite the inherited material. Exception being that there was already face declarations\n        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n          var declared = previousMaterial.clone(0);\n          declared.inherited = true;\n          this.object.materials.push(declared);\n        }\n\n        this.objects.push(this.object);\n      },\n      finalize: function () {\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n      },\n      parseVertexIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseNormalIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseUVIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 2) * 2;\n      },\n      addVertex: function (a, b, c) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addVertexPoint: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addVertexLine: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addNormal: function (a, b, c) {\n        var src = this.normals;\n        var dst = this.object.geometry.normals;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addFaceNormal: function (a, b, c) {\n        var src = this.vertices;\n        var dst = this.object.geometry.normals;\n        vA.fromArray(src, a);\n        vB.fromArray(src, b);\n        vC.fromArray(src, c);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        dst.push(cb.x, cb.y, cb.z);\n        dst.push(cb.x, cb.y, cb.z);\n        dst.push(cb.x, cb.y, cb.z);\n      },\n      addColor: function (a, b, c) {\n        var src = this.colors;\n        var dst = this.object.geometry.colors;\n        if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addUV: function (a, b, c) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n        dst.push(src[b + 0], src[b + 1]);\n        dst.push(src[c + 0], src[c + 1]);\n      },\n      addDefaultUV: function () {\n        var dst = this.object.geometry.uvs;\n        dst.push(0, 0);\n        dst.push(0, 0);\n        dst.push(0, 0);\n      },\n      addUVLine: function (a) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n      },\n      addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n        var vLen = this.vertices.length;\n        var ia = this.parseVertexIndex(a, vLen);\n        var ib = this.parseVertexIndex(b, vLen);\n        var ic = this.parseVertexIndex(c, vLen);\n        this.addVertex(ia, ib, ic);\n        this.addColor(ia, ib, ic); // normals\n\n        if (na !== undefined && na !== '') {\n          var nLen = this.normals.length;\n          ia = this.parseNormalIndex(na, nLen);\n          ib = this.parseNormalIndex(nb, nLen);\n          ic = this.parseNormalIndex(nc, nLen);\n          this.addNormal(ia, ib, ic);\n        } else {\n          this.addFaceNormal(ia, ib, ic);\n        } // uvs\n\n\n        if (ua !== undefined && ua !== '') {\n          var uvLen = this.uvs.length;\n          ia = this.parseUVIndex(ua, uvLen);\n          ib = this.parseUVIndex(ub, uvLen);\n          ic = this.parseUVIndex(uc, uvLen);\n          this.addUV(ia, ib, ic);\n          this.object.geometry.hasUVIndices = true;\n        } else {\n          // add placeholder values (for inconsistent face definitions)\n          this.addDefaultUV();\n        }\n      },\n      addPointGeometry: function (vertices) {\n        this.object.geometry.type = 'Points';\n        var vLen = this.vertices.length;\n\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          var index = this.parseVertexIndex(vertices[vi], vLen);\n          this.addVertexPoint(index);\n          this.addColor(index);\n        }\n      },\n      addLineGeometry: function (vertices, uvs) {\n        this.object.geometry.type = 'Line';\n        var vLen = this.vertices.length;\n        var uvLen = this.uvs.length;\n\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n        }\n\n        for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n        }\n      }\n    };\n    state.startObject('', false);\n    return state;\n  } //\n\n\n  function OBJLoader(manager) {\n    Loader.call(this, manager);\n    this.materials = null;\n  }\n\n  OBJLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: OBJLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    setMaterials: function (materials) {\n      this.materials = materials;\n      return this;\n    },\n    parse: function (text) {\n      var state = new ParserState();\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      if (text.indexOf('\\\\\\n') !== -1) {\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n      }\n\n      var lines = text.split('\\n');\n      var line = '',\n          lineFirstChar = '';\n      var lineLength = 0;\n      var result = []; // Faster to just trim left side of the line. Use if available.\n\n      var trimLeft = typeof ''.trimLeft === 'function';\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0) continue;\n        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\n\n        if (lineFirstChar === '#') continue;\n\n        if (lineFirstChar === 'v') {\n          var data = line.split(/\\s+/);\n\n          switch (data[0]) {\n            case 'v':\n              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\n              if (data.length >= 7) {\n                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n              } else {\n                // if no colors are defined, add placeholders so color and vertex indices match\n                state.colors.push(undefined, undefined, undefined);\n              }\n\n              break;\n\n            case 'vn':\n              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              break;\n\n            case 'vt':\n              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n              break;\n          }\n        } else if (lineFirstChar === 'f') {\n          var lineData = line.substr(1).trim();\n          var vertexData = lineData.split(/\\s+/);\n          var faceVertices = []; // Parse the face vertex data into an easy to work with format\n\n          for (let j = 0, jl = vertexData.length; j < jl; j++) {\n            var vertex = vertexData[j];\n\n            if (vertex.length > 0) {\n              var vertexParts = vertex.split('/');\n              faceVertices.push(vertexParts);\n            }\n          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\n          var v1 = faceVertices[0];\n\n          for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n            var v2 = faceVertices[j];\n            var v3 = faceVertices[j + 1];\n            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n          }\n        } else if (lineFirstChar === 'l') {\n          var lineParts = line.substring(1).trim().split(' ');\n          var lineVertices = [],\n              lineUVs = [];\n\n          if (line.indexOf('/') === -1) {\n            lineVertices = lineParts;\n          } else {\n            for (let li = 0, llen = lineParts.length; li < llen; li++) {\n              var parts = lineParts[li].split('/');\n              if (parts[0] !== '') lineVertices.push(parts[0]);\n              if (parts[1] !== '') lineUVs.push(parts[1]);\n            }\n          }\n\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if (lineFirstChar === 'p') {\n          var lineData = line.substr(1).trim();\n          var pointData = lineData.split(' ');\n          state.addPointGeometry(pointData);\n        } else if ((result = object_pattern.exec(line)) !== null) {\n          // o object_name\n          // or\n          // g group_name\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // var name = result[ 0 ].substr( 1 ).trim();\n          var name = (' ' + result[0].substr(1).trim()).substr(1);\n          state.startObject(name);\n        } else if (material_use_pattern.test(line)) {\n          // material\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (material_library_pattern.test(line)) {\n          // mtl file\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if (map_use_pattern.test(line)) {\n          // the line is parsed but ignored since the loader assumes textures are defined MTL files\n          // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n          console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n        } else if (lineFirstChar === 's') {\n          result = line.split(' '); // smooth shading\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          /*\n           * http://paulbourke.net/dataformats/obj/\n           * or\n           * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n           *\n           * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n           * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n           * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n           * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n           * than 0.\"\n           */\n\n          if (result.length > 1) {\n            var value = result[1].trim().toLowerCase();\n            state.object.smooth = value !== '0' && value !== 'off';\n          } else {\n            // ZBrush can produce \"s\" lines #11707\n            state.object.smooth = true;\n          }\n\n          var material = state.object.currentMaterial();\n          if (material) material.smooth = state.object.smooth;\n        } else {\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n          console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n        }\n      }\n\n      state.finalize();\n      var container = new Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n      var hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n\n      if (hasPrimitives === true) {\n        for (let i = 0, l = state.objects.length; i < l; i++) {\n          var object = state.objects[i];\n          var geometry = object.geometry;\n          var materials = object.materials;\n          var isLine = geometry.type === 'Line';\n          var isPoints = geometry.type === 'Points';\n          var hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\n\n          if (geometry.vertices.length === 0) continue;\n          var buffergeometry = new BufferGeometry();\n          buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));\n\n          if (geometry.normals.length > 0) {\n            buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));\n          }\n\n          if (geometry.colors.length > 0) {\n            hasVertexColors = true;\n            buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));\n          }\n\n          if (geometry.hasUVIndices === true) {\n            buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));\n          } // Create materials\n\n\n          var createdMaterials = [];\n\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            var sourceMaterial = materials[mi];\n            var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n            var material = state.materials[materialHash];\n\n            if (this.materials !== null) {\n              material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\n              if (isLine && material && !(material instanceof LineBasicMaterial)) {\n                var materialLine = new LineBasicMaterial();\n                Material.prototype.copy.call(materialLine, material);\n                materialLine.color.copy(material.color);\n                material = materialLine;\n              } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n                var materialPoints = new PointsMaterial({\n                  size: 10,\n                  sizeAttenuation: false\n                });\n                Material.prototype.copy.call(materialPoints, material);\n                materialPoints.color.copy(material.color);\n                materialPoints.map = material.map;\n                material = materialPoints;\n              }\n            }\n\n            if (material === undefined) {\n              if (isLine) {\n                material = new LineBasicMaterial();\n              } else if (isPoints) {\n                material = new PointsMaterial({\n                  size: 1,\n                  sizeAttenuation: false\n                });\n              } else {\n                material = new MeshPhongMaterial();\n              }\n\n              material.name = sourceMaterial.name;\n              material.flatShading = sourceMaterial.smooth ? false : true;\n              material.vertexColors = hasVertexColors;\n              state.materials[materialHash] = material;\n            }\n\n            createdMaterials.push(material);\n          } // Create mesh\n\n\n          var mesh;\n\n          if (createdMaterials.length > 1) {\n            for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n              var sourceMaterial = materials[mi];\n              buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n            }\n\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials);\n            }\n          } else {\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials[0]);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials[0]);\n            }\n          }\n\n          mesh.name = object.name;\n          container.add(mesh);\n        }\n      } else {\n        // if there is only the default parser state object with no geometry data, interpret data as point cloud\n        if (state.vertices.length > 0) {\n          var material = new PointsMaterial({\n            size: 1,\n            sizeAttenuation: false\n          });\n          var buffergeometry = new BufferGeometry();\n          buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));\n\n          if (state.colors.length > 0 && state.colors[0] !== undefined) {\n            buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));\n            material.vertexColors = true;\n          }\n\n          var points = new Points(buffergeometry, material);\n          container.add(points);\n        }\n      }\n\n      return container;\n    }\n  });\n  return OBJLoader;\n}();\n\nexport { OBJLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}