{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { Parser, createToken, Lexer } from 'chevrotain';\nvar VRMLLoader = function () {\n  // class definitions\n  function VRMLLoader(manager) {\n    Loader.call(this, manager);\n  }\n  VRMLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: VRMLLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (data, path) {\n      var nodeMap = {};\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = createToken({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform',\n        // grouping nodes\n        'Inline', 'LOD', 'Switch',\n        // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo',\n        // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor',\n        // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere',\n        // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate',\n        // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform',\n        // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator',\n        // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint',\n        // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = createToken({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = createToken({\n          name: 'StringLiteral',\n          pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n        });\n        var HexLiteral = createToken({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = createToken({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n        });\n        var tokens = [WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n        for (let i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function (ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n            if (ctx.route) {\n              for (let i = 0, l = ctx.route.length; i < l; i++) {\n                var route = ctx.route[i];\n                data.routes.push(this.visit(route));\n              }\n            }\n            return data;\n          },\n          version: function (ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function (ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n            if (ctx.field) {\n              for (let i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n            return data;\n          },\n          field: function (ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function (ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function (ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          route: function (ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n          if (ctx.node) {\n            field.type = 'node';\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n          if (ctx.use) {\n            field.type = 'use';\n            for (let i = 0, l = ctx.use.length; i < l; i++) {\n              var use = ctx.use[i];\n              field.values.push(scope.visit(use));\n            }\n          }\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n            for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n              var stringLiteral = ctx.StringLiteral[i];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n            for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n              var numberLiteral = ctx.NumberLiteral[i];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n            for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n              var hexLiteral = ctx.HexLiteral[i];\n              field.values.push(hexLiteral.image);\n            }\n          }\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n            for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n              var trueLiteral = ctx.TrueLiteral[i];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n            for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n              var falseLiteral = ctx.FalseLiteral[i];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n          return field;\n        }\n        return new VRMLToASTVisitor();\n      }\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          var object = getNode(node);\n          if (object instanceof Object3D) scene.add(object);\n          if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n        return scene;\n      }\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n            for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n        return build;\n      }\n      function buildGroupingNode(node) {\n        var object = new Group(); //\n\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n            case 'bboxSize':\n              // field not supported\n              break;\n            case 'center':\n              // field not supported\n              break;\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n            case 'collide':\n              // field not supported\n              break;\n            case 'rotation':\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'scaleOrientation':\n              // field not supported\n              break;\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'proxy':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return object;\n      }\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n            case 'backUrl':\n              // field not supported\n              break;\n            case 'bottomUrl':\n              // field not supported\n              break;\n            case 'frontUrl':\n              // field not supported\n              break;\n            case 'leftUrl':\n              // field not supported\n              break;\n            case 'rightUrl':\n              // field not supported\n              break;\n            case 'topUrl':\n              // field not supported\n              break;\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n              break;\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n        var object;\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new PointsMaterial({\n              color: 0xffffff\n            });\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new LineBasicMaterial({\n              color: 0xffffff\n            });\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            } // check for vertex colors\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n        return object;\n      }\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n              break;\n            case 'texture':\n              var textureNode = fieldValues[0];\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n              break;\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n            delete material.map.__type;\n          } // apply texture transform\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n        return material;\n      }\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n            case 'diffuseColor':\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'emissiveColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n            case 'specularColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return materialData;\n      }\n      function parseHexColor(hex, textureType, color) {\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            var value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            break;\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            var value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            break;\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n      function getTextureType(num_components) {\n        var type;\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n        return type;\n      }\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var useAlpha = num_components === 2 || num_components === 4;\n              var textureType = getTextureType(num_components);\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\n              var data = new Uint8Array(size);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n              for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n                if (useAlpha === true) {\n                  var stride = k * 4;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                  data[stride + 3] = color.a;\n                } else {\n                  var stride = k * 3;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                }\n              }\n              texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return transformData;\n      }\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return worldInfo;\n      }\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n          solid = true,\n          creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n          normalPerVertex = true;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case 'normal':\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'convex':\n              // field not supported\n              break;\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var positionAttribute;\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            }\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n        var geometry = new BufferGeometry();\n        positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n      function buildPointSetNode(node) {\n        var geometry;\n        var color, coord;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n      function buildConeNode(node) {\n        var radius = 1,\n          height = 2,\n          openEnded = false;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n            case 'height':\n              height = fieldValues[0];\n              break;\n            case 'side':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n      function buildCylinderNode(node) {\n        var radius = 1,\n          height = 2;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n            case 'height':\n              height = fieldValues[0];\n              break;\n            case 'side':\n              // field not supported\n              break;\n            case 'top':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'normal':\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case 'height':\n              height = fieldValues;\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n        for (let i = 0; i < zDimension; i++) {\n          for (let j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = i * xDimension + j; // vertices\n\n            var x = xSpacing * i;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n        var indices = [];\n        for (let i = 0; i < xDimension - 1; i++) {\n          for (let j = 0; j < zDimension - 1; j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = i + j * xDimension;\n            var b = i + (j + 1) * xDimension;\n            var c = i + 1 + (j + 1) * xDimension;\n            var d = i + 1 + j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var r = color[index * 3 + 0];\n                var g = color[index * 3 + 1];\n                var b = color[index * 3 + 2]; // one color per quad\n\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n              }\n            }\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var xn = normal[index * 3 + 0];\n                var yn = normal[index * 3 + 1];\n                var zn = normal[index * 3 + 2]; // one normal per quad\n\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n              }\n            }\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'convex':\n              // field not supported\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n            case 'scale':\n              scale = fieldValues;\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n        for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, i);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n          for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n        for (let i = 0; i < spineCount - 1; i++) {\n          for (let j = 0; j < crossSectionCount - 1; j++) {\n            var a = j + i * crossSectionCount;\n            var b = j + 1 + i * crossSectionCount;\n            var c = j + (i + 1) * crossSectionCount;\n            var d = j + 1 + (i + 1) * crossSectionCount;\n            if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = i * crossSectionCount;\n              d = (i + 1) * crossSectionCount;\n            }\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n          for (let i = 0, l = crossSection.length; i < l; i += 2) {\n            contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n          }\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n          for (let i = 0, l = faces.length; i < l; i++) {\n            var face = faces[i];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n          if (beginCap === true) {\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n              } else {\n                indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n              }\n            }\n          } // end cap\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n              }\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n      function parseFieldChildren(children, owner) {\n        for (let i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n        return indices;\n      }\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      function flattenData(data, index) {\n        var flattenData = [];\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n        return flattenData;\n      }\n      function expandLineIndex(index) {\n        var indices = [];\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n        return indices;\n      }\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n        return new Float32BufferAttribute(array, itemSize);\n      }\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n        for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n        for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n          index2 = 0;\n        for (let i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n      var ab = new Vector3();\n      var cb = new Vector3();\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (let i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n        var normals = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          var face = faces[i];\n          var nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n          vA.fromArray(coord, face.a * 3);\n          vB.fromArray(coord, face.b * 3);\n          vC.fromArray(coord, face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n        return new Float32BufferAttribute(normals, 3);\n      }\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (let i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n        return normal.normalize();\n      }\n      function toColorArray(colors) {\n        var array = [];\n        for (let i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n        for (let i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n        for (let i = 0; i < indices.count; i++) {\n          var index = indices.getX(i);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA, thresholdIndexB;\n          var t = 1;\n          for (let j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  });\n  function VRMLLexer(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n  VRMLLexer.prototype = {\n    constructor: VRMLLexer,\n    lex: function (inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n      return lexingResult;\n    }\n  };\n  function VRMLParser(tokenVocabulary) {\n    Parser.call(this, tokenVocabulary); // eslint-disable-line no-undef\n\n    var $ = this;\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n  VRMLParser.prototype = Object.create(Parser.prototype); // eslint-disable-line no-undef\n\n  VRMLParser.prototype.constructor = VRMLParser;\n  function Face(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n  var TEXTURE_TYPE = {\n    INTENSITY: 1,\n    INTENSITY_ALPHA: 2,\n    RGB: 3,\n    RGBA: 4\n  };\n  return VRMLLoader;\n}();\nexport { VRMLLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Vector3","Vector2","TextureLoader","Scene","Object3D","Group","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","DataTexture","RGBAFormat","RGBFormat","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","RepeatWrapping","ClampToEdgeWrapping","Parser","createToken","Lexer","VRMLLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree","scene","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","undefined","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","INTENSITY","value","parseInt","r","g","b","substring","a","getTextureType","num_components","texture","wrapS","wrapT","width","height","useAlpha","size","Uint8Array","k","stride","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","positionAttribute","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","inputText","tokenize","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/VRMLLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { Parser, createToken, Lexer } from 'chevrotain';\n\nvar VRMLLoader = function () {\n  // class definitions\n  function VRMLLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  VRMLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: VRMLLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (data, path) {\n      var nodeMap = {};\n\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = createToken({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n        'Inline', 'LOD', 'Switch', // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = createToken({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = createToken({\n          name: 'StringLiteral',\n          pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n        });\n        var HexLiteral = createToken({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = createToken({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n        });\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n\n        for (let i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function (ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n\n            if (ctx.route) {\n              for (let i = 0, l = ctx.route.length; i < l; i++) {\n                var route = ctx.route[i];\n                data.routes.push(this.visit(route));\n              }\n            }\n\n            return data;\n          },\n          version: function (ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function (ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n\n            if (ctx.field) {\n              for (let i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n\n            return data;\n          },\n          field: function (ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function (ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function (ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function (ctx) {\n            return processField(this, ctx);\n          },\n          route: function (ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n\n          if (ctx.node) {\n            field.type = 'node';\n\n            for (let i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n\n          if (ctx.use) {\n            field.type = 'use';\n\n            for (let i = 0, l = ctx.use.length; i < l; i++) {\n              var use = ctx.use[i];\n              field.values.push(scope.visit(use));\n            }\n          }\n\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n\n            for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n              var stringLiteral = ctx.StringLiteral[i];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n\n            for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n              var numberLiteral = ctx.NumberLiteral[i];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n\n            for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n              var hexLiteral = ctx.HexLiteral[i];\n              field.values.push(hexLiteral.image);\n            }\n          }\n\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n\n            for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n              var trueLiteral = ctx.TrueLiteral[i];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n\n            for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n              var falseLiteral = ctx.FalseLiteral[i];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n\n          return field;\n        }\n\n        return new VRMLToASTVisitor();\n      }\n\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          var object = getNode(node);\n          if (object instanceof Object3D) scene.add(object);\n          if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n\n        return scene;\n      }\n\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n\n            for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n\n        return build;\n      }\n\n      function buildGroupingNode(node) {\n        var object = new Group(); //\n\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n\n            case 'bboxSize':\n              // field not supported\n              break;\n\n            case 'center':\n              // field not supported\n              break;\n\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n\n            case 'collide':\n              // field not supported\n              break;\n\n            case 'rotation':\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'scaleOrientation':\n              // field not supported\n              break;\n\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'proxy':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return object;\n      }\n\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n\n            case 'backUrl':\n              // field not supported\n              break;\n\n            case 'bottomUrl':\n              // field not supported\n              break;\n\n            case 'frontUrl':\n              // field not supported\n              break;\n\n            case 'leftUrl':\n              // field not supported\n              break;\n\n            case 'rightUrl':\n              // field not supported\n              break;\n\n            case 'topUrl':\n              // field not supported\n              break;\n\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n\n        var object;\n\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new PointsMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new LineBasicMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            } // check for vertex colors\n\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n\n        return object;\n      }\n\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n\n              break;\n\n            case 'texture':\n              var textureNode = fieldValues[0];\n\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n\n              break;\n\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n\n            delete material.map.__type;\n          } // apply texture transform\n\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n\n        return material;\n      }\n\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n\n            case 'diffuseColor':\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'emissiveColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n\n            case 'specularColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return materialData;\n      }\n\n      function parseHexColor(hex, textureType, color) {\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            var value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            break;\n\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            var value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            break;\n\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n\n      function getTextureType(num_components) {\n        var type;\n\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n\n        return type;\n      }\n\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var useAlpha = num_components === 2 || num_components === 4;\n              var textureType = getTextureType(num_components);\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\n              var data = new Uint8Array(size);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n\n              for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n\n                if (useAlpha === true) {\n                  var stride = k * 4;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                  data[stride + 3] = color.a;\n                } else {\n                  var stride = k * 3;\n                  data[stride + 0] = color.r;\n                  data[stride + 1] = color.g;\n                  data[stride + 2] = color.b;\n                }\n              }\n\n              texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return transformData;\n      }\n\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return worldInfo;\n      }\n\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n            solid = true,\n            creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n            normalPerVertex = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var positionAttribute;\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            }\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n\n      function buildPointSetNode(node) {\n        var geometry;\n        var color, coord;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n\n      function buildConeNode(node) {\n        var radius = 1,\n            height = 2,\n            openEnded = false;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n\n      function buildCylinderNode(node) {\n        var radius = 1,\n            height = 2;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            case 'top':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'height':\n              height = fieldValues;\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n\n        for (let i = 0; i < zDimension; i++) {\n          for (let j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = i * xDimension + j; // vertices\n\n            var x = xSpacing * i;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n\n        var indices = [];\n\n        for (let i = 0; i < xDimension - 1; i++) {\n          for (let j = 0; j < zDimension - 1; j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = i + j * xDimension;\n            var b = i + (j + 1) * xDimension;\n            var c = i + 1 + (j + 1) * xDimension;\n            var d = i + 1 + j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var r = color[index * 3 + 0];\n                var g = color[index * 3 + 1];\n                var b = color[index * 3 + 2]; // one color per quad\n\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n                colors.push(r, g, b);\n              }\n            }\n\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (let i = 0; i < xDimension - 1; i++) {\n              for (let j = 0; j < zDimension - 1; j++) {\n                var index = i + j * (xDimension - 1);\n                var xn = normal[index * 3 + 0];\n                var yn = normal[index * 3 + 1];\n                var zn = normal[index * 3 + 2]; // one normal per quad\n\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n                normals.push(xn, yn, zn);\n              }\n            }\n\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n\n        for (let i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n\n            case 'scale':\n              scale = fieldValues;\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n\n        for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, i);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n\n          for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n\n        for (let i = 0; i < spineCount - 1; i++) {\n          for (let j = 0; j < crossSectionCount - 1; j++) {\n            var a = j + i * crossSectionCount;\n            var b = j + 1 + i * crossSectionCount;\n            var c = j + (i + 1) * crossSectionCount;\n            var d = j + 1 + (i + 1) * crossSectionCount;\n\n            if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = i * crossSectionCount;\n              d = (i + 1) * crossSectionCount;\n            }\n\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n\n          for (let i = 0, l = crossSection.length; i < l; i += 2) {\n            contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n          }\n\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n\n          for (let i = 0, l = faces.length; i < l; i++) {\n            var face = faces[i];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n\n          if (beginCap === true) {\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n              } else {\n                indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n              }\n            }\n          } // end cap\n\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (let i = 0, l = capIndices.length; i < l; i += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n              }\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n\n      function parseFieldChildren(children, owner) {\n        for (let i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n\n        return indices;\n      }\n\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      function flattenData(data, index) {\n        var flattenData = [];\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n\n        return flattenData;\n      }\n\n      function expandLineIndex(index) {\n        var indices = [];\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n\n        return indices;\n      }\n\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (let i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n\n        return new Float32BufferAttribute(array, itemSize);\n      }\n\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n\n        for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n\n        for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (let i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n\n      var ab = new Vector3();\n      var cb = new Vector3();\n\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (let i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n\n        var normals = [];\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          var face = faces[i];\n          var nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n          vA.fromArray(coord, face.a * 3);\n          vB.fromArray(coord, face.b * 3);\n          vC.fromArray(coord, face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n\n        return new Float32BufferAttribute(normals, 3);\n      }\n\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (let i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n\n        return normal.normalize();\n      }\n\n      function toColorArray(colors) {\n        var array = [];\n\n        for (let i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n\n        for (let i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n\n        for (let i = 0; i < indices.count; i++) {\n          var index = indices.getX(i);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA, thresholdIndexB;\n          var t = 1;\n\n          for (let j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  });\n\n  function VRMLLexer(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  VRMLLexer.prototype = {\n    constructor: VRMLLexer,\n    lex: function (inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n\n      return lexingResult;\n    }\n  };\n\n  function VRMLParser(tokenVocabulary) {\n    Parser.call(this, tokenVocabulary); // eslint-disable-line no-undef\n\n    var $ = this;\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n  VRMLParser.prototype = Object.create(Parser.prototype); // eslint-disable-line no-undef\n\n  VRMLParser.prototype.constructor = VRMLParser;\n\n  function Face(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n  var TEXTURE_TYPE = {\n    INTENSITY: 1,\n    INTENSITY_ALPHA: 2,\n    RGB: 3,\n    RGBA: 4\n  };\n  return VRMLLoader;\n}();\n\nexport { VRMLLoader };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,WAAW,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAEC,aAAa,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,cAAc,EAAEC,iBAAiB,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,cAAc,EAAEC,MAAM,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,SAAS,EAAEC,UAAU,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,WAAW,EAAEC,UAAU,EAAEC,SAAS,EAAEC,cAAc,EAAEC,sBAAsB,EAAEC,WAAW,EAAEC,YAAY,EAAEC,gBAAgB,EAAEC,UAAU,EAAEC,UAAU,EAAEC,eAAe,EAAEC,cAAc,EAAEC,mBAAmB,QAAQ,OAAO;AACpd,SAASC,MAAM,EAAEC,WAAW,EAAEC,KAAK,QAAQ,YAAY;AAEvD,IAAIC,UAAU,GAAG,YAAY;EAC3B;EACA,SAASA,UAAUA,CAACC,OAAO,EAAE;IAC3BtC,MAAM,CAACuC,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC;EAC5B;EAEAD,UAAU,CAACG,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,MAAM,CAAC3C,MAAM,CAACwC,SAAS,CAAC,EAAE;IACpEI,WAAW,EAAEP,UAAU;IACvBQ,IAAI,EAAE,SAAAA,CAAUC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;MAChD,IAAIC,KAAK,GAAG,IAAI;MAChB,IAAIC,IAAI,GAAGD,KAAK,CAACC,IAAI,KAAK,EAAE,GAAGlD,WAAW,CAACmD,cAAc,CAACN,GAAG,CAAC,GAAGI,KAAK,CAACC,IAAI;MAC3E,IAAIE,MAAM,GAAG,IAAInD,UAAU,CAACgD,KAAK,CAACZ,OAAO,CAAC;MAC1Ce,MAAM,CAACC,OAAO,CAACJ,KAAK,CAACC,IAAI,CAAC;MAC1BE,MAAM,CAACE,gBAAgB,CAACL,KAAK,CAACM,aAAa,CAAC;MAC5CH,MAAM,CAACI,kBAAkB,CAACP,KAAK,CAACQ,eAAe,CAAC;MAChDL,MAAM,CAACR,IAAI,CAACC,GAAG,EAAE,UAAUa,IAAI,EAAE;QAC/B,IAAI;UACFZ,MAAM,CAACG,KAAK,CAACU,KAAK,CAACD,IAAI,EAAER,IAAI,CAAC,CAAC;QACjC,CAAC,CAAC,OAAOU,CAAC,EAAE;UACV,IAAIZ,OAAO,EAAE;YACXA,OAAO,CAACY,CAAC,CAAC;UACZ,CAAC,MAAM;YACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;UAClB;UAEAX,KAAK,CAACZ,OAAO,CAAC0B,SAAS,CAAClB,GAAG,CAAC;QAC9B;MACF,CAAC,EAAEE,UAAU,EAAEC,OAAO,CAAC;IACzB,CAAC;IACDW,KAAK,EAAE,SAAAA,CAAUK,IAAI,EAAEd,IAAI,EAAE;MAC3B,IAAIe,OAAO,GAAG,CAAC,CAAC;MAEhB,SAASC,gBAAgBA,CAACF,IAAI,EAAE;QAC9B;QACA,IAAIG,SAAS,GAAGC,YAAY,CAAC,CAAC;QAC9B,IAAIC,KAAK,GAAG,IAAIC,SAAS,CAACH,SAAS,CAACI,MAAM,CAAC;QAC3C,IAAIC,MAAM,GAAG,IAAIC,UAAU,CAACN,SAAS,CAACO,eAAe,CAAC;QACtD,IAAIC,OAAO,GAAGC,aAAa,CAACJ,MAAM,CAACK,4BAA4B,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEpE,IAAIC,YAAY,GAAGT,KAAK,CAACU,GAAG,CAACf,IAAI,CAAC;QAClCQ,MAAM,CAACQ,KAAK,GAAGF,YAAY,CAACP,MAAM,CAAC,CAAC;;QAEpC,IAAIU,SAAS,GAAGT,MAAM,CAACU,IAAI,CAAC,CAAC;QAE7B,IAAIV,MAAM,CAACW,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;UAC5BvB,OAAO,CAACC,KAAK,CAACU,MAAM,CAACW,MAAM,CAAC;UAC5B,MAAME,KAAK,CAAC,4CAA4C,CAAC;QAC3D,CAAC,CAAC;;QAGF,IAAIC,GAAG,GAAGX,OAAO,CAACY,KAAK,CAACN,SAAS,CAAC;QAClC,OAAOK,GAAG;MACZ;MAEA,SAASlB,YAAYA,CAAA,EAAG;QACtB;QACA,IAAIoB,eAAe,GAAGtD,WAAW,CAAC;UAChCuD,IAAI,EAAE,iBAAiB;UACvBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIC,UAAU,GAAGzD,WAAW,CAAC;UAC3BuD,IAAI,EAAE,YAAY;UAClBC,OAAO,EAAE,gIAAgI;UACzIE,UAAU,EAAEJ;QACd,CAAC,CAAC,CAAC,CAAC;;QAEJ,IAAIK,SAAS,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,WAAW,EAAE,OAAO,EAAE,WAAW;QAAE;QAC3E,QAAQ,EAAE,KAAK,EAAE,QAAQ;QAAE;QAC3B,WAAW,EAAE,kBAAkB,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,WAAW;QAAE;QACrG,gBAAgB,EAAE,aAAa,EAAE,iBAAiB,EAAE,cAAc,EAAE,YAAY,EAAE,aAAa,EAAE,kBAAkB;QAAE;QACrH,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,eAAe,EAAE,WAAW,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,UAAU,EAAE,QAAQ;QAAE;QACnH,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,mBAAmB;QAAE;QACtD,YAAY,EAAE,WAAW,EAAE,cAAc,EAAE,UAAU,EAAE,cAAc,EAAE,cAAc,EAAE,kBAAkB;QAAE;QAC3G,mBAAmB,EAAE,wBAAwB,EAAE,oBAAoB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,oBAAoB;QAAE;QAC9I,YAAY,EAAE,KAAK,EAAE,gBAAgB,EAAE,WAAW;QAAE;QACpD,MAAM,CAAC;QAAA,CACN,CAAC,CAAC;;QAEH,IAAIC,OAAO,GAAG5D,WAAW,CAAC;UACxBuD,IAAI,EAAE,SAAS;UACfC,OAAO,EAAE,SAAS;UAClBE,UAAU,EAAED;QACd,CAAC,CAAC;QACF,IAAII,QAAQ,GAAG7D,WAAW,CAAC;UACzBuD,IAAI,EAAE,UAAU;UAChBC,OAAO,EAAE,IAAIM,MAAM,CAACH,SAAS,CAACI,IAAI,CAAC,GAAG,CAAC,CAAC;UACxCL,UAAU,EAAED;QACd,CAAC,CAAC;QACF,IAAIO,GAAG,GAAGhE,WAAW,CAAC;UACpBuD,IAAI,EAAE,KAAK;UACXC,OAAO,EAAE,KAAK;UACdE,UAAU,EAAED;QACd,CAAC,CAAC;QACF,IAAIQ,GAAG,GAAGjE,WAAW,CAAC;UACpBuD,IAAI,EAAE,KAAK;UACXC,OAAO,EAAE,KAAK;UACdE,UAAU,EAAED;QACd,CAAC,CAAC;QACF,IAAIS,KAAK,GAAGlE,WAAW,CAAC;UACtBuD,IAAI,EAAE,OAAO;UACbC,OAAO,EAAE,OAAO;UAChBE,UAAU,EAAED;QACd,CAAC,CAAC;QACF,IAAIU,EAAE,GAAGnE,WAAW,CAAC;UACnBuD,IAAI,EAAE,IAAI;UACVC,OAAO,EAAE,IAAI;UACbE,UAAU,EAAED;QACd,CAAC,CAAC,CAAC,CAAC;;QAEJ,IAAIW,aAAa,GAAGpE,WAAW,CAAC;UAC9BuD,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIa,UAAU,GAAGrE,WAAW,CAAC;UAC3BuD,IAAI,EAAE,YAAY;UAClBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIc,aAAa,GAAGtE,WAAW,CAAC;UAC9BuD,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIe,WAAW,GAAGvE,WAAW,CAAC;UAC5BuD,IAAI,EAAE,aAAa;UACnBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIgB,YAAY,GAAGxE,WAAW,CAAC;UAC7BuD,IAAI,EAAE,cAAc;UACpBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIiB,WAAW,GAAGzE,WAAW,CAAC;UAC5BuD,IAAI,EAAE,aAAa;UACnBC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIkB,OAAO,GAAG1E,WAAW,CAAC;UACxBuD,IAAI,EAAE,SAAS;UACfC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAImB,OAAO,GAAG3E,WAAW,CAAC;UACxBuD,IAAI,EAAE,SAAS;UACfC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIoB,MAAM,GAAG5E,WAAW,CAAC;UACvBuD,IAAI,EAAE,QAAQ;UACdC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIqB,MAAM,GAAG7E,WAAW,CAAC;UACvBuD,IAAI,EAAE,QAAQ;UACdC,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAIsB,OAAO,GAAG9E,WAAW,CAAC;UACxBuD,IAAI,EAAE,SAAS;UACfC,OAAO,EAAE,KAAK;UACduB,KAAK,EAAE9E,KAAK,CAAC+E,OAAO,CAAC;QAEvB,CAAC,CAAC,CAAC,CAAC;;QAEJ,IAAIC,UAAU,GAAGjF,WAAW,CAAC;UAC3BuD,IAAI,EAAE,YAAY;UAClBC,OAAO,EAAE,QAAQ;UACjBuB,KAAK,EAAE9E,KAAK,CAAC+E,OAAO,CAAC;QAEvB,CAAC,CAAC;QACF,IAAI3C,MAAM,GAAG,CAAC4C,UAAU;QAAE;QAC1BpB,QAAQ,EAAEG,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAEC,EAAE,EAAEI,WAAW,EAAEC,YAAY,EAAEC,WAAW;QAAE;QACvEb,OAAO,EAAEH,UAAU,EAAEH,eAAe,EAAEc,aAAa,EAAEC,UAAU,EAAEC,aAAa,EAAEI,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC;QAC1H,IAAItC,eAAe,GAAG,CAAC,CAAC;QAExB,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG9C,MAAM,CAACa,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIE,KAAK,GAAG/C,MAAM,CAAC6C,CAAC,CAAC;UACrB1C,eAAe,CAAC4C,KAAK,CAAC7B,IAAI,CAAC,GAAG6B,KAAK;QACrC;QAEA,OAAO;UACL/C,MAAM,EAAEA,MAAM;UACdG,eAAe,EAAEA;QACnB,CAAC;MACH;MAEA,SAASE,aAAaA,CAAC2C,eAAe,EAAE;QACtC;QACA,SAASC,gBAAgBA,CAAA,EAAG;UAC1BD,eAAe,CAACjF,IAAI,CAAC,IAAI,CAAC;UAC1B,IAAI,CAACmF,eAAe,CAAC,CAAC;QACxB;QAEAD,gBAAgB,CAACjF,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,MAAM,CAAC6E,eAAe,CAAChF,SAAS,CAAC,EAAE;UACnFI,WAAW,EAAE6E,gBAAgB;UAC7BtC,IAAI,EAAE,SAAAA,CAAUwC,GAAG,EAAE;YACnB,IAAI1D,IAAI,GAAG;cACT2D,OAAO,EAAE,IAAI,CAACpC,KAAK,CAACmC,GAAG,CAACC,OAAO,CAAC;cAChCC,KAAK,EAAE,EAAE;cACTC,MAAM,EAAE;YACV,CAAC;YAED,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACI,IAAI,CAAC1C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cAC/C,IAAIU,IAAI,GAAGJ,GAAG,CAACI,IAAI,CAACV,CAAC,CAAC;cACtBpD,IAAI,CAAC4D,KAAK,CAACG,IAAI,CAAC,IAAI,CAACxC,KAAK,CAACuC,IAAI,CAAC,CAAC;YACnC;YAEA,IAAIJ,GAAG,CAACM,KAAK,EAAE;cACb,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACM,KAAK,CAAC5C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;gBAChD,IAAIY,KAAK,GAAGN,GAAG,CAACM,KAAK,CAACZ,CAAC,CAAC;gBACxBpD,IAAI,CAAC6D,MAAM,CAACE,IAAI,CAAC,IAAI,CAACxC,KAAK,CAACyC,KAAK,CAAC,CAAC;cACrC;YACF;YAEA,OAAOhE,IAAI;UACb,CAAC;UACD2D,OAAO,EAAE,SAAAA,CAAUD,GAAG,EAAE;YACtB,OAAOA,GAAG,CAAC5B,OAAO,CAAC,CAAC,CAAC,CAACmC,KAAK;UAC7B,CAAC;UACDH,IAAI,EAAE,SAAAA,CAAUJ,GAAG,EAAE;YACnB,IAAI1D,IAAI,GAAG;cACTyB,IAAI,EAAEiC,GAAG,CAAC3B,QAAQ,CAAC,CAAC,CAAC,CAACkC,KAAK;cAC3BC,MAAM,EAAE;YACV,CAAC;YAED,IAAIR,GAAG,CAACS,KAAK,EAAE;cACb,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACS,KAAK,CAAC/C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;gBAChD,IAAIe,KAAK,GAAGT,GAAG,CAACS,KAAK,CAACf,CAAC,CAAC;gBACxBpD,IAAI,CAACkE,MAAM,CAACH,IAAI,CAAC,IAAI,CAACxC,KAAK,CAAC4C,KAAK,CAAC,CAAC;cACrC;YACF,CAAC,CAAC;;YAGF,IAAIT,GAAG,CAACU,GAAG,EAAE;cACXpE,IAAI,CAACkC,GAAG,GAAG,IAAI,CAACX,KAAK,CAACmC,GAAG,CAACU,GAAG,CAAC,CAAC,CAAC,CAAC;YACnC;YAEA,OAAOpE,IAAI;UACb,CAAC;UACDmE,KAAK,EAAE,SAAAA,CAAUT,GAAG,EAAE;YACpB,IAAI1D,IAAI,GAAG;cACTyB,IAAI,EAAEiC,GAAG,CAAC/B,UAAU,CAAC,CAAC,CAAC,CAACsC,KAAK;cAC7BI,IAAI,EAAE,IAAI;cACVC,MAAM,EAAE;YACV,CAAC;YACD,IAAIC,MAAM,CAAC,CAAC;;YAEZ,IAAIb,GAAG,CAACc,gBAAgB,EAAE;cACxBD,MAAM,GAAG,IAAI,CAAChD,KAAK,CAACmC,GAAG,CAACc,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC9C,CAAC,CAAC;;YAGF,IAAId,GAAG,CAACe,eAAe,EAAE;cACvBF,MAAM,GAAG,IAAI,CAAChD,KAAK,CAACmC,GAAG,CAACe,eAAe,CAAC,CAAC,CAAC,CAAC;YAC7C;YAEAzE,IAAI,CAACqE,IAAI,GAAGE,MAAM,CAACF,IAAI;YACvBrE,IAAI,CAACsE,MAAM,GAAGC,MAAM,CAACD,MAAM;YAC3B,OAAOtE,IAAI;UACb,CAAC;UACDoE,GAAG,EAAE,SAAAA,CAAUV,GAAG,EAAE;YAClB,OAAO,CAACA,GAAG,CAAC/B,UAAU,IAAI+B,GAAG,CAAC3B,QAAQ,EAAE,CAAC,CAAC,CAACkC,KAAK;UAClD,CAAC;UACDS,GAAG,EAAE,SAAAA,CAAUhB,GAAG,EAAE;YAClB,OAAO;cACLvB,GAAG,EAAE,CAACuB,GAAG,CAAC/B,UAAU,IAAI+B,GAAG,CAAC3B,QAAQ,EAAE,CAAC,CAAC,CAACkC;YAC3C,CAAC;UACH,CAAC;UACDO,gBAAgB,EAAE,SAAAA,CAAUd,GAAG,EAAE;YAC/B,OAAOiB,YAAY,CAAC,IAAI,EAAEjB,GAAG,CAAC;UAChC,CAAC;UACDe,eAAe,EAAE,SAAAA,CAAUf,GAAG,EAAE;YAC9B,OAAOiB,YAAY,CAAC,IAAI,EAAEjB,GAAG,CAAC;UAChC,CAAC;UACDM,KAAK,EAAE,SAAAA,CAAUN,GAAG,EAAE;YACpB,IAAI1D,IAAI,GAAG;cACT4E,IAAI,EAAElB,GAAG,CAAClC,eAAe,CAAC,CAAC,CAAC,CAACyC,KAAK;cAClC5B,EAAE,EAAEqB,GAAG,CAAClC,eAAe,CAAC,CAAC,CAAC,CAACyC;YAC7B,CAAC;YACD,OAAOjE,IAAI;UACb;QACF,CAAC,CAAC;QAEF,SAAS2E,YAAYA,CAAC1F,KAAK,EAAEyE,GAAG,EAAE;UAChC,IAAIS,KAAK,GAAG;YACVE,IAAI,EAAE,IAAI;YACVC,MAAM,EAAE;UACV,CAAC;UAED,IAAIZ,GAAG,CAACI,IAAI,EAAE;YACZK,KAAK,CAACE,IAAI,GAAG,MAAM;YAEnB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACI,IAAI,CAAC1C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cAC/C,IAAIU,IAAI,GAAGJ,GAAG,CAACI,IAAI,CAACV,CAAC,CAAC;cACtBe,KAAK,CAACG,MAAM,CAACP,IAAI,CAAC9E,KAAK,CAACsC,KAAK,CAACuC,IAAI,CAAC,CAAC;YACtC;UACF;UAEA,IAAIJ,GAAG,CAACgB,GAAG,EAAE;YACXP,KAAK,CAACE,IAAI,GAAG,KAAK;YAElB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACgB,GAAG,CAACtD,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cAC9C,IAAIsB,GAAG,GAAGhB,GAAG,CAACgB,GAAG,CAACtB,CAAC,CAAC;cACpBe,KAAK,CAACG,MAAM,CAACP,IAAI,CAAC9E,KAAK,CAACsC,KAAK,CAACmD,GAAG,CAAC,CAAC;YACrC;UACF;UAEA,IAAIhB,GAAG,CAACpB,aAAa,EAAE;YACrB6B,KAAK,CAACE,IAAI,GAAG,QAAQ;YAErB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACpB,aAAa,CAAClB,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cACxD,IAAIyB,aAAa,GAAGnB,GAAG,CAACpB,aAAa,CAACc,CAAC,CAAC;cACxCe,KAAK,CAACG,MAAM,CAACP,IAAI,CAACc,aAAa,CAACZ,KAAK,CAACa,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;YAC5D;UACF;UAEA,IAAIpB,GAAG,CAAClB,aAAa,EAAE;YACrB2B,KAAK,CAACE,IAAI,GAAG,QAAQ;YAErB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAAClB,aAAa,CAACpB,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cACxD,IAAI2B,aAAa,GAAGrB,GAAG,CAAClB,aAAa,CAACY,CAAC,CAAC;cACxCe,KAAK,CAACG,MAAM,CAACP,IAAI,CAACiB,UAAU,CAACD,aAAa,CAACd,KAAK,CAAC,CAAC;YACpD;UACF;UAEA,IAAIP,GAAG,CAACnB,UAAU,EAAE;YAClB4B,KAAK,CAACE,IAAI,GAAG,KAAK;YAElB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACnB,UAAU,CAACnB,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cACrD,IAAI6B,UAAU,GAAGvB,GAAG,CAACnB,UAAU,CAACa,CAAC,CAAC;cAClCe,KAAK,CAACG,MAAM,CAACP,IAAI,CAACkB,UAAU,CAAChB,KAAK,CAAC;YACrC;UACF;UAEA,IAAIP,GAAG,CAACjB,WAAW,EAAE;YACnB0B,KAAK,CAACE,IAAI,GAAG,SAAS;YAEtB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAACjB,WAAW,CAACrB,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cACtD,IAAI8B,WAAW,GAAGxB,GAAG,CAACjB,WAAW,CAACW,CAAC,CAAC;cACpC,IAAI8B,WAAW,CAACjB,KAAK,KAAK,MAAM,EAAEE,KAAK,CAACG,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC;YAC3D;UACF;UAEA,IAAIL,GAAG,CAAChB,YAAY,EAAE;YACpByB,KAAK,CAACE,IAAI,GAAG,SAAS;YAEtB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGK,GAAG,CAAChB,YAAY,CAACtB,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;cACvD,IAAI+B,YAAY,GAAGzB,GAAG,CAAChB,YAAY,CAACU,CAAC,CAAC;cACtC,IAAI+B,YAAY,CAAClB,KAAK,KAAK,OAAO,EAAEE,KAAK,CAACG,MAAM,CAACP,IAAI,CAAC,KAAK,CAAC;YAC9D;UACF;UAEA,IAAIL,GAAG,CAACf,WAAW,EAAE;YACnBwB,KAAK,CAACE,IAAI,GAAG,MAAM;YACnBX,GAAG,CAACf,WAAW,CAACyC,OAAO,CAAC,YAAY;cAClCjB,KAAK,CAACG,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC;YACzB,CAAC,CAAC;UACJ;UAEA,OAAOI,KAAK;QACd;QAEA,OAAO,IAAIX,gBAAgB,CAAC,CAAC;MAC/B;MAEA,SAAS6B,SAASA,CAACC,IAAI,EAAE;QACvB;QACA,IAAI1B,KAAK,GAAG0B,IAAI,CAAC1B,KAAK;QACtB,IAAI2B,KAAK,GAAG,IAAIlJ,KAAK,CAAC,CAAC,CAAC,CAAC;;QAEzB,KAAK,IAAI+G,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGO,KAAK,CAACxC,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIU,IAAI,GAAGF,KAAK,CAACR,CAAC,CAAC;UACnBoC,YAAY,CAAC1B,IAAI,CAAC;QACpB,CAAC,CAAC;;QAGF,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGO,KAAK,CAACxC,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIU,IAAI,GAAGF,KAAK,CAACR,CAAC,CAAC;UACnB,IAAIqC,MAAM,GAAGC,OAAO,CAAC5B,IAAI,CAAC;UAC1B,IAAI2B,MAAM,YAAYnJ,QAAQ,EAAEiJ,KAAK,CAACI,GAAG,CAACF,MAAM,CAAC;UACjD,IAAI3B,IAAI,CAACrC,IAAI,KAAK,WAAW,EAAE8D,KAAK,CAACK,QAAQ,CAACC,SAAS,GAAGJ,MAAM;QAClE;QAEA,OAAOF,KAAK;MACd;MAEA,SAASC,YAAYA,CAAC1B,IAAI,EAAE;QAC1B,IAAIA,IAAI,CAAC5B,GAAG,EAAE;UACZjC,OAAO,CAAC6D,IAAI,CAAC5B,GAAG,CAAC,GAAG4B,IAAI;QAC1B;QAEA,IAAII,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UAErB,IAAIe,KAAK,CAACE,IAAI,KAAK,MAAM,EAAE;YACzB,IAAIyB,WAAW,GAAG3B,KAAK,CAACG,MAAM;YAE9B,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGF,WAAW,CAAC1E,MAAM,EAAE2E,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;cACpDP,YAAY,CAACM,WAAW,CAACC,CAAC,CAAC,CAAC;YAC9B;UACF;QACF;MACF;MAEA,SAASL,OAAOA,CAAC5B,IAAI,EAAE;QACrB;QACA,IAAIA,IAAI,CAAC3B,GAAG,EAAE;UACZ,OAAO8D,UAAU,CAACnC,IAAI,CAAC3B,GAAG,CAAC;QAC7B;QAEA,IAAI2B,IAAI,CAACoC,KAAK,KAAKC,SAAS,EAAE,OAAOrC,IAAI,CAACoC,KAAK;QAC/CpC,IAAI,CAACoC,KAAK,GAAGE,SAAS,CAACtC,IAAI,CAAC;QAC5B,OAAOA,IAAI,CAACoC,KAAK;MACnB,CAAC,CAAC;;MAGF,SAASE,SAASA,CAACtC,IAAI,EAAE;QACvB,IAAIuC,QAAQ,GAAGvC,IAAI,CAACrC,IAAI;QACxB,IAAIyE,KAAK;QAET,QAAQG,QAAQ;UACd,KAAK,OAAO;UACZ,KAAK,WAAW;UAChB,KAAK,WAAW;YACdH,KAAK,GAAGI,iBAAiB,CAACxC,IAAI,CAAC;YAC/B;UAEF,KAAK,YAAY;YACfoC,KAAK,GAAGK,mBAAmB,CAACzC,IAAI,CAAC;YACjC;UAEF,KAAK,OAAO;YACVoC,KAAK,GAAGM,cAAc,CAAC1C,IAAI,CAAC;YAC5B;UAEF,KAAK,YAAY;YACfoC,KAAK,GAAGO,mBAAmB,CAAC3C,IAAI,CAAC;YACjC;UAEF,KAAK,UAAU;YACboC,KAAK,GAAGQ,iBAAiB,CAAC5C,IAAI,CAAC;YAC/B;UAEF,KAAK,cAAc;YACjBoC,KAAK,GAAGS,qBAAqB,CAAC7C,IAAI,CAAC;YACnC;UAEF,KAAK,cAAc;YACjBoC,KAAK,GAAGU,qBAAqB,CAAC9C,IAAI,CAAC;YACnC;UAEF,KAAK,kBAAkB;YACrBoC,KAAK,GAAGW,yBAAyB,CAAC/C,IAAI,CAAC;YACvC;UAEF,KAAK,gBAAgB;YACnBoC,KAAK,GAAGY,uBAAuB,CAAChD,IAAI,CAAC;YACrC;UAEF,KAAK,gBAAgB;YACnBoC,KAAK,GAAGa,uBAAuB,CAACjD,IAAI,CAAC;YACrC;UAEF,KAAK,UAAU;YACboC,KAAK,GAAGc,iBAAiB,CAAClD,IAAI,CAAC;YAC/B;UAEF,KAAK,KAAK;YACRoC,KAAK,GAAGe,YAAY,CAACnD,IAAI,CAAC;YAC1B;UAEF,KAAK,MAAM;YACToC,KAAK,GAAGgB,aAAa,CAACpD,IAAI,CAAC;YAC3B;UAEF,KAAK,UAAU;YACboC,KAAK,GAAGiB,iBAAiB,CAACrD,IAAI,CAAC;YAC/B;UAEF,KAAK,QAAQ;YACXoC,KAAK,GAAGkB,eAAe,CAACtD,IAAI,CAAC;YAC7B;UAEF,KAAK,eAAe;YAClBoC,KAAK,GAAGmB,sBAAsB,CAACvD,IAAI,CAAC;YACpC;UAEF,KAAK,WAAW;YACdoC,KAAK,GAAGoB,kBAAkB,CAACxD,IAAI,CAAC;YAChC;UAEF,KAAK,OAAO;UACZ,KAAK,YAAY;UACjB,KAAK,QAAQ;UACb,KAAK,mBAAmB;YACtBoC,KAAK,GAAGqB,kBAAkB,CAACzD,IAAI,CAAC;YAChC;UAEF,KAAK,WAAW;YACdoC,KAAK,GAAGsB,kBAAkB,CAAC1D,IAAI,CAAC;YAChC;UAEF,KAAK,QAAQ;UACb,KAAK,WAAW;UAChB,KAAK,QAAQ;UACb,KAAK,KAAK;UACV,KAAK,QAAQ;UACb,KAAK,WAAW;UAChB,KAAK,kBAAkB;UACvB,KAAK,YAAY;UACjB,KAAK,QAAQ;UACb,KAAK,OAAO;UACZ,KAAK,WAAW;UAChB,KAAK,gBAAgB;UACrB,KAAK,aAAa;UAClB,KAAK,iBAAiB;UACtB,KAAK,cAAc;UACnB,KAAK,YAAY;UACjB,KAAK,aAAa;UAClB,KAAK,kBAAkB;UACvB,KAAK,MAAM;UACX,KAAK,WAAW;UAChB,KAAK,cAAc;UACnB,KAAK,mBAAmB;UACxB,KAAK,wBAAwB;UAC7B,KAAK,oBAAoB;UACzB,KAAK,yBAAyB;UAC9B,KAAK,sBAAsB;UAC3B,KAAK,oBAAoB;UACzB,KAAK,KAAK;UACV,KAAK,gBAAgB;UACrB,KAAK,WAAW;YACd;YACA;UAEF;YACEjE,OAAO,CAAC4H,IAAI,CAAC,iCAAiC,EAAEpB,QAAQ,CAAC;YACzD;QACJ;QAEA,IAAIH,KAAK,KAAKC,SAAS,IAAIrC,IAAI,CAAC5B,GAAG,KAAKiE,SAAS,IAAID,KAAK,CAACwB,cAAc,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE;UAC1FxB,KAAK,CAACzE,IAAI,GAAGqC,IAAI,CAAC5B,GAAG;QACvB;QAEA,OAAOgE,KAAK;MACd;MAEA,SAASI,iBAAiBA,CAACxC,IAAI,EAAE;QAC/B,IAAI2B,MAAM,GAAG,IAAIlJ,KAAK,CAAC,CAAC,CAAC,CAAC;;QAE1B,IAAI2H,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,YAAY;cACf;cACA;YAEF,KAAK,UAAU;cACb;cACA;YAEF,KAAK,QAAQ;cACX;cACA;YAEF,KAAK,UAAU;cACbC,kBAAkB,CAAC9B,WAAW,EAAEL,MAAM,CAAC;cACvC;YAEF,KAAK,SAAS;cACZ;cACA;YAEF,KAAK,UAAU;cACb,IAAIoC,IAAI,GAAG,IAAI3L,OAAO,CAAC4J,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACtE,IAAIgC,KAAK,GAAGhC,WAAW,CAAC,CAAC,CAAC;cAC1BL,MAAM,CAACsC,UAAU,CAACC,gBAAgB,CAACH,IAAI,EAAEC,KAAK,CAAC;cAC/C;YAEF,KAAK,OAAO;cACVrC,MAAM,CAACwC,KAAK,CAACC,GAAG,CAACpC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cAChE;YAEF,KAAK,kBAAkB;cACrB;cACA;YAEF,KAAK,aAAa;cAChBL,MAAM,CAAC0C,QAAQ,CAACD,GAAG,CAACpC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACnE;YAEF,KAAK,OAAO;cACV;cACA;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,OAAOlC,MAAM;MACf;MAEA,SAASc,mBAAmBA,CAACzC,IAAI,EAAE;QACjC,IAAIb,KAAK,GAAG,IAAI1G,KAAK,CAAC,CAAC;QACvB,IAAI6L,WAAW,EAAEC,WAAW;QAC5B,IAAIC,QAAQ,EAAEC,QAAQ;QACtB,IAAIrE,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,aAAa;cAChBS,WAAW,GAAGtC,WAAW;cACzB;YAEF,KAAK,aAAa;cAChBuC,WAAW,GAAGvC,WAAW;cACzB;YAEF,KAAK,SAAS;cACZ;cACA;YAEF,KAAK,WAAW;cACd;cACA;YAEF,KAAK,UAAU;cACb;cACA;YAEF,KAAK,SAAS;cACZ;cACA;YAEF,KAAK,UAAU;cACb;cACA;YAEF,KAAK,QAAQ;cACX;cACA;YAEF,KAAK,UAAU;cACbwC,QAAQ,GAAGxC,WAAW;cACtB;YAEF,KAAK,UAAU;cACbyC,QAAQ,GAAGzC,WAAW;cACtB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIa,MAAM,GAAG,KAAK,CAAC,CAAC;;QAEpB,IAAID,QAAQ,EAAE;UACZ,IAAIE,WAAW,GAAG,IAAIjM,cAAc,CAACgM,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;UACpD,IAAIE,WAAW,GAAG,IAAIjM,iBAAiB,CAAC;YACtCkM,GAAG,EAAE,KAAK;YACVC,IAAI,EAAElM,QAAQ;YACdmM,UAAU,EAAE,KAAK;YACjBC,SAAS,EAAE;UACb,CAAC,CAAC;UAEF,IAAIP,QAAQ,CAACnH,MAAM,GAAG,CAAC,EAAE;YACvB2H,UAAU,CAACN,WAAW,EAAED,MAAM,EAAEF,QAAQ,EAAEU,YAAY,CAACT,QAAQ,CAAC,EAAE,IAAI,CAAC;YACvEG,WAAW,CAACO,YAAY,GAAG,IAAI;UACjC,CAAC,MAAM;YACLP,WAAW,CAACQ,KAAK,CAACC,MAAM,CAACZ,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;UACjE;UAEA,IAAIa,GAAG,GAAG,IAAIzM,IAAI,CAAC8L,WAAW,EAAEC,WAAW,CAAC;UAC5CzF,KAAK,CAAC0C,GAAG,CAACyD,GAAG,CAAC;QAChB,CAAC,CAAC;;QAGF,IAAIf,WAAW,EAAE;UACf,IAAIA,WAAW,CAACjH,MAAM,GAAG,CAAC,EAAE;YAC1B,IAAIiI,cAAc,GAAG,IAAI7M,cAAc,CAACgM,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,GAAGc,IAAI,CAACC,EAAE,EAAE,GAAG,GAAGD,IAAI,CAACC,EAAE,EAAE,GAAG,GAAGD,IAAI,CAACC,EAAE,CAAC;YACrG,IAAIC,cAAc,GAAG,IAAI/M,iBAAiB,CAAC;cACzCkM,GAAG,EAAE,KAAK;cACVC,IAAI,EAAElM,QAAQ;cACduM,YAAY,EAAE,IAAI;cAClBJ,UAAU,EAAE,KAAK;cACjBC,SAAS,EAAE;YACb,CAAC,CAAC;YACFC,UAAU,CAACM,cAAc,EAAEb,MAAM,EAAEJ,WAAW,EAAEY,YAAY,CAACX,WAAW,CAAC,EAAE,KAAK,CAAC;YACjF,IAAIoB,MAAM,GAAG,IAAI9M,IAAI,CAAC0M,cAAc,EAAEG,cAAc,CAAC;YACrDvG,KAAK,CAAC0C,GAAG,CAAC8D,MAAM,CAAC;UACnB;QACF,CAAC,CAAC;;QAGFxG,KAAK,CAACyG,WAAW,GAAG,CAACC,QAAQ;QAC7B,OAAO1G,KAAK;MACd;MAEA,SAASuD,cAAcA,CAAC1C,IAAI,EAAE;QAC5B,IAAII,MAAM,GAAGJ,IAAI,CAACI,MAAM,CAAC,CAAC;;QAE1B,IAAI0F,QAAQ,GAAG,IAAInN,iBAAiB,CAAC;UACnCyM,KAAK,EAAE;QACT,CAAC,CAAC;QACF,IAAIW,QAAQ;QAEZ,KAAK,IAAIzG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,YAAY;cACf,IAAI7B,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3B8D,QAAQ,GAAGlE,OAAO,CAACI,WAAW,CAAC,CAAC,CAAC,CAAC;cACpC;cAEA;YAEF,KAAK,UAAU;cACb,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3B+D,QAAQ,GAAGnE,OAAO,CAACI,WAAW,CAAC,CAAC,CAAC,CAAC;cACpC;cAEA;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF,CAAC,CAAC;;QAGF,IAAIlC,MAAM;QAEV,IAAIoE,QAAQ,IAAIA,QAAQ,CAACC,UAAU,CAAC3B,QAAQ,EAAE;UAC5C,IAAI9D,IAAI,GAAGwF,QAAQ,CAACE,KAAK;UAEzB,IAAI1F,IAAI,KAAK,QAAQ,EAAE;YACrB;YACA,IAAI2F,cAAc,GAAG,IAAIpN,cAAc,CAAC;cACtCsM,KAAK,EAAE;YACT,CAAC,CAAC;YAEF,IAAIW,QAAQ,CAACC,UAAU,CAACZ,KAAK,KAAK/C,SAAS,EAAE;cAC3C6D,cAAc,CAACf,YAAY,GAAG,IAAI;YACpC,CAAC,MAAM;cACL;cACA,IAAIW,QAAQ,CAACK,mBAAmB,EAAE;gBAChCD,cAAc,CAACd,KAAK,CAACgB,IAAI,CAACN,QAAQ,CAACO,QAAQ,CAAC;cAC9C;YACF;YAEA1E,MAAM,GAAG,IAAI5I,MAAM,CAACgN,QAAQ,EAAEG,cAAc,CAAC;UAC/C,CAAC,MAAM,IAAI3F,IAAI,KAAK,MAAM,EAAE;YAC1B;YACA,IAAI+F,YAAY,GAAG,IAAItN,iBAAiB,CAAC;cACvCoM,KAAK,EAAE;YACT,CAAC,CAAC;YAEF,IAAIW,QAAQ,CAACC,UAAU,CAACZ,KAAK,KAAK/C,SAAS,EAAE;cAC3CiE,YAAY,CAACnB,YAAY,GAAG,IAAI;YAClC,CAAC,MAAM;cACL;cACA,IAAIW,QAAQ,CAACK,mBAAmB,EAAE;gBAChCG,YAAY,CAAClB,KAAK,CAACgB,IAAI,CAACN,QAAQ,CAACO,QAAQ,CAAC;cAC5C;YACF;YAEA1E,MAAM,GAAG,IAAI1I,YAAY,CAAC8M,QAAQ,EAAEO,YAAY,CAAC;UACnD,CAAC,MAAM;YACL;YACA;YACA,IAAIP,QAAQ,CAACQ,MAAM,KAAKlE,SAAS,EAAE;cACjCyD,QAAQ,CAAChB,IAAI,GAAGiB,QAAQ,CAACQ,MAAM,GAAGrN,SAAS,GAAGC,UAAU;YAC1D,CAAC,CAAC;;YAGF,IAAI4M,QAAQ,CAACC,UAAU,CAACZ,KAAK,KAAK/C,SAAS,EAAE;cAC3CyD,QAAQ,CAACX,YAAY,GAAG,IAAI;YAC9B;YAEAxD,MAAM,GAAG,IAAI9I,IAAI,CAACkN,QAAQ,EAAED,QAAQ,CAAC;UACvC;QACF,CAAC,MAAM;UACLnE,MAAM,GAAG,IAAInJ,QAAQ,CAAC,CAAC,CAAC,CAAC;;UAEzBmJ,MAAM,CAAC6E,OAAO,GAAG,KAAK;QACxB;QAEA,OAAO7E,MAAM;MACf;MAEA,SAASgB,mBAAmBA,CAAC3C,IAAI,EAAE;QACjC,IAAI8F,QAAQ,GAAG,IAAI1M,iBAAiB,CAAC,CAAC;QACtC,IAAIqN,aAAa;QACjB,IAAIrG,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,UAAU;cACb,IAAI7B,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3B,IAAI0E,YAAY,GAAG9E,OAAO,CAACI,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI0E,YAAY,CAACC,YAAY,EAAEb,QAAQ,CAACV,KAAK,CAACgB,IAAI,CAACM,YAAY,CAACC,YAAY,CAAC;gBAC7E,IAAID,YAAY,CAACE,aAAa,EAAEd,QAAQ,CAACO,QAAQ,CAACD,IAAI,CAACM,YAAY,CAACE,aAAa,CAAC;gBAClF,IAAIF,YAAY,CAACG,SAAS,EAAEf,QAAQ,CAACe,SAAS,GAAGH,YAAY,CAACG,SAAS;gBACvE,IAAIH,YAAY,CAACI,aAAa,EAAEhB,QAAQ,CAACiB,QAAQ,CAACX,IAAI,CAACM,YAAY,CAACI,aAAa,CAAC;gBAClF,IAAIJ,YAAY,CAACM,YAAY,EAAElB,QAAQ,CAACmB,OAAO,GAAG,CAAC,GAAGP,YAAY,CAACM,YAAY;gBAC/E,IAAIN,YAAY,CAACM,YAAY,GAAG,CAAC,EAAElB,QAAQ,CAACoB,WAAW,GAAG,IAAI;cAChE,CAAC,MAAM;gBACL;gBACApB,QAAQ,GAAG,IAAInN,iBAAiB,CAAC;kBAC/ByM,KAAK,EAAE;gBACT,CAAC,CAAC;cACJ;cAEA;YAEF,KAAK,SAAS;cACZ,IAAI+B,WAAW,GAAGnF,WAAW,CAAC,CAAC,CAAC;cAEhC,IAAImF,WAAW,KAAK,IAAI,EAAE;gBACxB,IAAIA,WAAW,CAACxJ,IAAI,KAAK,cAAc,IAAIwJ,WAAW,CAACxJ,IAAI,KAAK,cAAc,EAAE;kBAC9EmI,QAAQ,CAACsB,GAAG,GAAGxF,OAAO,CAACuF,WAAW,CAAC;gBACrC;cACF;cAEA;YAEF,KAAK,kBAAkB;cACrB,IAAInF,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3ByE,aAAa,GAAG7E,OAAO,CAACI,WAAW,CAAC,CAAC,CAAC,CAAC;cACzC;cAEA;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF,CAAC,CAAC;;QAGF,IAAIiC,QAAQ,CAACsB,GAAG,EAAE;UAChB;UACA,IAAItB,QAAQ,CAACsB,GAAG,CAACC,MAAM,EAAE;YACvB,QAAQvB,QAAQ,CAACsB,GAAG,CAACC,MAAM;cACzB,KAAKC,YAAY,CAACC,eAAe;gBAC/BzB,QAAQ,CAACmB,OAAO,GAAG,CAAC,CAAC,CAAC;;gBAEtB;cAEF,KAAKK,YAAY,CAACE,GAAG;gBACnB1B,QAAQ,CAACV,KAAK,CAAChB,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;;gBAE9B;cAEF,KAAKkD,YAAY,CAACG,IAAI;gBACpB3B,QAAQ,CAACV,KAAK,CAAChB,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;;gBAE9B0B,QAAQ,CAACmB,OAAO,GAAG,CAAC,CAAC,CAAC;;gBAEtB;YACJ;YAEA,OAAOnB,QAAQ,CAACsB,GAAG,CAACC,MAAM;UAC5B,CAAC,CAAC;;UAGF,IAAIZ,aAAa,EAAE;YACjBX,QAAQ,CAACsB,GAAG,CAACM,MAAM,CAACtB,IAAI,CAACK,aAAa,CAACiB,MAAM,CAAC;YAC9C5B,QAAQ,CAACsB,GAAG,CAACO,QAAQ,GAAGlB,aAAa,CAACkB,QAAQ;YAC9C7B,QAAQ,CAACsB,GAAG,CAACQ,MAAM,CAACxB,IAAI,CAACK,aAAa,CAACtC,KAAK,CAAC;YAC7C2B,QAAQ,CAACsB,GAAG,CAACS,MAAM,CAACzB,IAAI,CAACK,aAAa,CAACqB,WAAW,CAAC;UACrD;QACF;QAEA,OAAOhC,QAAQ;MACjB;MAEA,SAASlD,iBAAiBA,CAAC5C,IAAI,EAAE;QAC/B,IAAI0G,YAAY,GAAG,CAAC,CAAC;QACrB,IAAItG,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,kBAAkB;cACrB;cACA;YAEF,KAAK,cAAc;cACjB6C,YAAY,CAACC,YAAY,GAAG,IAAItN,KAAK,CAAC2I,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACrF;YAEF,KAAK,eAAe;cAClB0E,YAAY,CAACE,aAAa,GAAG,IAAIvN,KAAK,CAAC2I,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACtF;YAEF,KAAK,WAAW;cACd0E,YAAY,CAACG,SAAS,GAAG7E,WAAW,CAAC,CAAC,CAAC;cACvC;YAEF,KAAK,eAAe;cAClB0E,YAAY,CAACE,aAAa,GAAG,IAAIvN,KAAK,CAAC2I,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACtF;YAEF,KAAK,cAAc;cACjB0E,YAAY,CAACM,YAAY,GAAGhF,WAAW,CAAC,CAAC,CAAC;cAC1C;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,OAAO6C,YAAY;MACrB;MAEA,SAASqB,aAAaA,CAACC,GAAG,EAAEC,WAAW,EAAE7C,KAAK,EAAE;QAC9C,QAAQ6C,WAAW;UACjB,KAAKX,YAAY,CAACY,SAAS;YACzB;YACA,IAAIC,KAAK,GAAGC,QAAQ,CAACJ,GAAG,CAAC;YACzB5C,KAAK,CAACiD,CAAC,GAAGF,KAAK;YACf/C,KAAK,CAACkD,CAAC,GAAGH,KAAK;YACf/C,KAAK,CAACmD,CAAC,GAAGJ,KAAK;YACf;UAEF,KAAKb,YAAY,CAACC,eAAe;YAC/B;YACA,IAAIY,KAAK,GAAGC,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAChDpD,KAAK,CAACiD,CAAC,GAAGF,KAAK;YACf/C,KAAK,CAACkD,CAAC,GAAGH,KAAK;YACf/C,KAAK,CAACmD,CAAC,GAAGJ,KAAK;YACf/C,KAAK,CAACqD,CAAC,GAAGL,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9C;UAEF,KAAKlB,YAAY,CAACE,GAAG;YACnB;YACApC,KAAK,CAACiD,CAAC,GAAGD,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9CpD,KAAK,CAACkD,CAAC,GAAGF,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9CpD,KAAK,CAACmD,CAAC,GAAGH,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9C;UAEF,KAAKlB,YAAY,CAACG,IAAI;YACpB;YACArC,KAAK,CAACiD,CAAC,GAAGD,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9CpD,KAAK,CAACkD,CAAC,GAAGF,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9CpD,KAAK,CAACmD,CAAC,GAAGH,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9CpD,KAAK,CAACqD,CAAC,GAAGL,QAAQ,CAAC,IAAI,GAAGJ,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAC/C;QACJ;MACF;MAEA,SAASE,cAAcA,CAACC,cAAc,EAAE;QACtC,IAAIpI,IAAI;QAER,QAAQoI,cAAc;UACpB,KAAK,CAAC;YACJpI,IAAI,GAAG+G,YAAY,CAACY,SAAS;YAC7B;UAEF,KAAK,CAAC;YACJ3H,IAAI,GAAG+G,YAAY,CAACC,eAAe;YACnC;UAEF,KAAK,CAAC;YACJhH,IAAI,GAAG+G,YAAY,CAACE,GAAG;YACvB;UAEF,KAAK,CAAC;YACJjH,IAAI,GAAG+G,YAAY,CAACG,IAAI;YACxB;QACJ;QAEA,OAAOlH,IAAI;MACb;MAEA,SAASuC,qBAAqBA,CAAC9C,IAAI,EAAE;QACnC,IAAI4I,OAAO;QACX,IAAIC,KAAK,GAAG5O,cAAc;QAC1B,IAAI6O,KAAK,GAAG7O,cAAc;QAC1B,IAAImG,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV,IAAIkF,KAAK,GAAG/G,WAAW,CAAC,CAAC,CAAC;cAC1B,IAAIgH,MAAM,GAAGhH,WAAW,CAAC,CAAC,CAAC;cAC3B,IAAI2G,cAAc,GAAG3G,WAAW,CAAC,CAAC,CAAC;cACnC,IAAIiH,QAAQ,GAAGN,cAAc,KAAK,CAAC,IAAIA,cAAc,KAAK,CAAC;cAC3D,IAAIV,WAAW,GAAGS,cAAc,CAACC,cAAc,CAAC;cAChD,IAAIO,IAAI,GAAG,CAACD,QAAQ,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC,KAAKF,KAAK,GAAGC,MAAM,CAAC;cACzD,IAAI9M,IAAI,GAAG,IAAIiN,UAAU,CAACD,IAAI,CAAC;cAC/B,IAAI9D,KAAK,GAAG;gBACViD,CAAC,EAAE,CAAC;gBACJC,CAAC,EAAE,CAAC;gBACJC,CAAC,EAAE,CAAC;gBACJE,CAAC,EAAE;cACL,CAAC;cAED,KAAK,IAAIxG,CAAC,GAAG,CAAC,EAAEmH,CAAC,GAAG,CAAC,EAAElH,EAAE,GAAGF,WAAW,CAAC1E,MAAM,EAAE2E,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAEmH,CAAC,EAAE,EAAE;gBAChErB,aAAa,CAAC/F,WAAW,CAACC,CAAC,CAAC,EAAEgG,WAAW,EAAE7C,KAAK,CAAC;gBAEjD,IAAI6D,QAAQ,KAAK,IAAI,EAAE;kBACrB,IAAII,MAAM,GAAGD,CAAC,GAAG,CAAC;kBAClBlN,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACiD,CAAC;kBAC1BnM,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACkD,CAAC;kBAC1BpM,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACmD,CAAC;kBAC1BrM,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACqD,CAAC;gBAC5B,CAAC,MAAM;kBACL,IAAIY,MAAM,GAAGD,CAAC,GAAG,CAAC;kBAClBlN,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACiD,CAAC;kBAC1BnM,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACkD,CAAC;kBAC1BpM,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC,GAAGjE,KAAK,CAACmD,CAAC;gBAC5B;cACF;cAEAK,OAAO,GAAG,IAAItP,WAAW,CAAC4C,IAAI,EAAE6M,KAAK,EAAEC,MAAM,EAAEC,QAAQ,KAAK,IAAI,GAAG1P,UAAU,GAAGC,SAAS,CAAC;cAC1FoP,OAAO,CAACvB,MAAM,GAAGY,WAAW,CAAC,CAAC;;cAE9B;YAEF,KAAK,SAAS;cACZ,IAAIjG,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE6G,KAAK,GAAG3O,mBAAmB;cACzD;YAEF,KAAK,SAAS;cACZ,IAAI8H,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE8G,KAAK,GAAG5O,mBAAmB;cACzD;YAEF;cACE6B,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAI+E,OAAO,EAAE;UACXA,OAAO,CAACC,KAAK,GAAGA,KAAK;UACrBD,OAAO,CAACE,KAAK,GAAGA,KAAK;QACvB;QAEA,OAAOF,OAAO;MAChB;MAEA,SAAS/F,qBAAqBA,CAAC7C,IAAI,EAAE;QACnC,IAAI4I,OAAO;QACX,IAAIC,KAAK,GAAG5O,cAAc;QAC1B,IAAI6O,KAAK,GAAG7O,cAAc;QAC1B,IAAImG,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,KAAK;cACR,IAAI9I,GAAG,GAAGiH,WAAW,CAAC,CAAC,CAAC;cACxB,IAAIjH,GAAG,EAAE6N,OAAO,GAAGU,aAAa,CAACxO,IAAI,CAACC,GAAG,CAAC;cAC1C;YAEF,KAAK,SAAS;cACZ,IAAIiH,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE6G,KAAK,GAAG3O,mBAAmB;cACzD;YAEF,KAAK,SAAS;cACZ,IAAI8H,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE8G,KAAK,GAAG5O,mBAAmB;cACzD;YAEF;cACE6B,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAI+E,OAAO,EAAE;UACXA,OAAO,CAACC,KAAK,GAAGA,KAAK;UACrBD,OAAO,CAACE,KAAK,GAAGA,KAAK;QACvB;QAEA,OAAOF,OAAO;MAChB;MAEA,SAAS7F,yBAAyBA,CAAC/C,IAAI,EAAE;QACvC,IAAIyG,aAAa,GAAG;UAClBiB,MAAM,EAAE,IAAIrP,OAAO,CAAC,CAAC;UACrBsP,QAAQ,EAAE,IAAItP,OAAO,CAAC,CAAC;UACvB8L,KAAK,EAAE,IAAI9L,OAAO,CAAC,CAAC;UACpByP,WAAW,EAAE,IAAIzP,OAAO,CAAC;QAC3B,CAAC;QACD,IAAI+H,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,QAAQ;cACX4C,aAAa,CAACiB,MAAM,CAACtD,GAAG,CAACpC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACxD;YAEF,KAAK,UAAU;cACbyE,aAAa,CAACkB,QAAQ,GAAG3F,WAAW,CAAC,CAAC,CAAC;cACvC;YAEF,KAAK,OAAO;cACVyE,aAAa,CAACtC,KAAK,CAACC,GAAG,CAACpC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cACvD;YAEF,KAAK,aAAa;cAChByE,aAAa,CAACqB,WAAW,CAAC1D,GAAG,CAACpC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;cAC7D;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,OAAO4C,aAAa;MACtB;MAEA,SAAShD,kBAAkBA,CAACzD,IAAI,EAAE;QAChC,OAAOA,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC,CAACI,MAAM;MAC9B;MAEA,SAASkD,kBAAkBA,CAAC1D,IAAI,EAAE;QAChC,IAAI+B,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI3B,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV9B,SAAS,CAACwH,KAAK,GAAGvH,WAAW,CAAC,CAAC,CAAC;cAChC;YAEF,KAAK,MAAM;cACTD,SAAS,CAACyH,IAAI,GAAGxH,WAAW;cAC5B;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,OAAO9B,SAAS;MAClB;MAEA,SAASiB,uBAAuBA,CAAChD,IAAI,EAAE;QACrC,IAAIoF,KAAK,EAAEqE,KAAK,EAAEC,MAAM,EAAEC,QAAQ;QAClC,IAAIC,GAAG,GAAG,IAAI;UACVC,KAAK,GAAG,IAAI;UACZC,WAAW,GAAG,CAAC;QACnB,IAAIC,UAAU,EAAEC,UAAU,EAAEC,WAAW,EAAEC,aAAa;QACtD,IAAIC,cAAc,GAAG,IAAI;UACrBC,eAAe,GAAG,IAAI;QAC1B,IAAIhK,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV,IAAIwG,SAAS,GAAGrI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIqI,SAAS,KAAK,IAAI,EAAE;gBACtBjF,KAAK,GAAGxD,OAAO,CAACyI,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,OAAO;cACV,IAAIC,SAAS,GAAGtI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIsI,SAAS,KAAK,IAAI,EAAE;gBACtBb,KAAK,GAAG7H,OAAO,CAAC0I,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,QAAQ;cACX,IAAIC,UAAU,GAAGvI,WAAW,CAAC,CAAC,CAAC;cAE/B,IAAIuI,UAAU,KAAK,IAAI,EAAE;gBACvBb,MAAM,GAAG9H,OAAO,CAAC2I,UAAU,CAAC;cAC9B;cAEA;YAEF,KAAK,UAAU;cACb,IAAIC,YAAY,GAAGxI,WAAW,CAAC,CAAC,CAAC;cAEjC,IAAIwI,YAAY,KAAK,IAAI,EAAE;gBACzBb,QAAQ,GAAG/H,OAAO,CAAC4I,YAAY,CAAC;cAClC;cAEA;YAEF,KAAK,KAAK;cACRZ,GAAG,GAAG5H,WAAW,CAAC,CAAC,CAAC;cACpB;YAEF,KAAK,YAAY;cACf+H,UAAU,GAAG/H,WAAW;cACxB;YAEF,KAAK,gBAAgB;cACnBmI,cAAc,GAAGnI,WAAW,CAAC,CAAC,CAAC;cAC/B;YAEF,KAAK,QAAQ;cACX;cACA;YAEF,KAAK,YAAY;cACfgI,UAAU,GAAGhI,WAAW;cACxB;YAEF,KAAK,aAAa;cAChB8H,WAAW,GAAG9H,WAAW,CAAC,CAAC,CAAC;cAC5B;YAEF,KAAK,aAAa;cAChBiI,WAAW,GAAGjI,WAAW;cACzB;YAEF,KAAK,iBAAiB;cACpBoI,eAAe,GAAGpI,WAAW,CAAC,CAAC,CAAC;cAChC;YAEF,KAAK,OAAO;cACV6H,KAAK,GAAG7H,WAAW,CAAC,CAAC,CAAC;cACtB;YAEF,KAAK,eAAe;cAClBkI,aAAa,GAAGlI,WAAW;cAC3B;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAImG,UAAU,KAAK3H,SAAS,EAAE;UAC5BtG,OAAO,CAAC4H,IAAI,CAAC,uCAAuC,CAAC;UACrD,OAAO,IAAIlK,cAAc,CAAC,CAAC,CAAC,CAAC;QAC/B;QAEA,IAAIgR,sBAAsB,GAAGC,oBAAoB,CAACV,UAAU,EAAEJ,GAAG,CAAC;QAClE,IAAIe,iBAAiB;QACrB,IAAIC,cAAc;QAClB,IAAIC,eAAe;QACnB,IAAIC,WAAW;QAEf,IAAI1F,KAAK,EAAE;UACT,IAAI+E,cAAc,KAAK,IAAI,EAAE;YAC3B,IAAIJ,UAAU,IAAIA,UAAU,CAACzM,MAAM,GAAG,CAAC,EAAE;cACvC;cACA,IAAIyN,sBAAsB,GAAGL,oBAAoB,CAACX,UAAU,EAAEH,GAAG,CAAC;cAClEgB,cAAc,GAAGI,+BAA+B,CAACP,sBAAsB,EAAEM,sBAAsB,EAAE3F,KAAK,EAAE,CAAC,CAAC;YAC5G,CAAC,MAAM;cACL;cACAwF,cAAc,GAAGK,qBAAqB,CAACR,sBAAsB,EAAE,IAAI/Q,sBAAsB,CAAC0L,KAAK,EAAE,CAAC,CAAC,CAAC;YACtG;UACF,CAAC,MAAM;YACL,IAAI2E,UAAU,IAAIA,UAAU,CAACzM,MAAM,GAAG,CAAC,EAAE;cACvC;cACA,IAAI4N,iBAAiB,GAAGC,WAAW,CAAC/F,KAAK,EAAE2E,UAAU,CAAC;cACtD,IAAIqB,sBAAsB,GAAGC,mBAAmB,CAACH,iBAAiB,EAAElB,UAAU,CAAC;cAC/EY,cAAc,GAAGU,4BAA4B,CAACb,sBAAsB,EAAEW,sBAAsB,CAAC;YAC/F,CAAC,MAAM;cACL;cACA,IAAIA,sBAAsB,GAAGC,mBAAmB,CAACjG,KAAK,EAAE4E,UAAU,CAAC;cACnEY,cAAc,GAAGU,4BAA4B,CAACb,sBAAsB,EAAEW,sBAAsB,CAAC;YAC/F;UACF;QACF;QAEA,IAAI1B,MAAM,EAAE;UACV,IAAIU,eAAe,KAAK,IAAI,EAAE;YAC5B;YACA,IAAIH,WAAW,IAAIA,WAAW,CAAC3M,MAAM,GAAG,CAAC,EAAE;cACzC;cACA,IAAIiO,uBAAuB,GAAGb,oBAAoB,CAACT,WAAW,EAAEL,GAAG,CAAC;cACpEiB,eAAe,GAAGG,+BAA+B,CAACP,sBAAsB,EAAEc,uBAAuB,EAAE7B,MAAM,EAAE,CAAC,CAAC;YAC/G,CAAC,MAAM;cACL;cACAmB,eAAe,GAAGI,qBAAqB,CAACR,sBAAsB,EAAE,IAAI/Q,sBAAsB,CAACgQ,MAAM,EAAE,CAAC,CAAC,CAAC;YACxG;UACF,CAAC,MAAM;YACL;YACA,IAAIO,WAAW,IAAIA,WAAW,CAAC3M,MAAM,GAAG,CAAC,EAAE;cACzC;cACA,IAAIkO,kBAAkB,GAAGL,WAAW,CAACzB,MAAM,EAAEO,WAAW,CAAC;cACzD,IAAIwB,uBAAuB,GAAGJ,mBAAmB,CAACG,kBAAkB,EAAExB,UAAU,CAAC;cACjFa,eAAe,GAAGS,4BAA4B,CAACb,sBAAsB,EAAEgB,uBAAuB,CAAC;YACjG,CAAC,MAAM;cACL;cACA,IAAIA,uBAAuB,GAAGJ,mBAAmB,CAAC3B,MAAM,EAAEM,UAAU,CAAC;cACrEa,eAAe,GAAGS,4BAA4B,CAACb,sBAAsB,EAAEgB,uBAAuB,CAAC;YACjG;UACF;QACF,CAAC,MAAM;UACL;UACAZ,eAAe,GAAGa,sBAAsB,CAACjB,sBAAsB,EAAEhB,KAAK,EAAEK,WAAW,CAAC;QACtF;QAEA,IAAIH,QAAQ,EAAE;UACZ;UACA,IAAIO,aAAa,IAAIA,aAAa,CAAC5M,MAAM,GAAG,CAAC,EAAE;YAC7C;YACA,IAAIqO,yBAAyB,GAAGjB,oBAAoB,CAACR,aAAa,EAAEN,GAAG,CAAC;YACxEkB,WAAW,GAAGE,+BAA+B,CAACP,sBAAsB,EAAEkB,yBAAyB,EAAEhC,QAAQ,EAAE,CAAC,CAAC;UAC/G,CAAC,MAAM;YACL;YACAmB,WAAW,GAAGG,qBAAqB,CAACR,sBAAsB,EAAE,IAAI/Q,sBAAsB,CAACiQ,QAAQ,EAAE,CAAC,CAAC,CAAC;UACtG;QACF;QAEA,IAAI5D,QAAQ,GAAG,IAAItM,cAAc,CAAC,CAAC;QACnCkR,iBAAiB,GAAGM,qBAAqB,CAACR,sBAAsB,EAAE,IAAI/Q,sBAAsB,CAAC+P,KAAK,EAAE,CAAC,CAAC,CAAC;QACvG1D,QAAQ,CAAC6F,YAAY,CAAC,UAAU,EAAEjB,iBAAiB,CAAC;QACpD5E,QAAQ,CAAC6F,YAAY,CAAC,QAAQ,EAAEf,eAAe,CAAC,CAAC,CAAC;;QAElD,IAAID,cAAc,EAAE7E,QAAQ,CAAC6F,YAAY,CAAC,OAAO,EAAEhB,cAAc,CAAC;QAClE,IAAIE,WAAW,EAAE/E,QAAQ,CAAC6F,YAAY,CAAC,IAAI,EAAEd,WAAW,CAAC,CAAC,CAAC;;QAE3D/E,QAAQ,CAACQ,MAAM,GAAGsD,KAAK;QACvB9D,QAAQ,CAACE,KAAK,GAAG,MAAM;QACvB,OAAOF,QAAQ;MACjB;MAEA,SAAS9C,uBAAuBA,CAACjD,IAAI,EAAE;QACrC,IAAIoF,KAAK,EAAEqE,KAAK;QAChB,IAAIM,UAAU,EAAEC,UAAU;QAC1B,IAAIG,cAAc,GAAG,IAAI;QACzB,IAAI/J,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV,IAAIwG,SAAS,GAAGrI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIqI,SAAS,KAAK,IAAI,EAAE;gBACtBjF,KAAK,GAAGxD,OAAO,CAACyI,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,OAAO;cACV,IAAIC,SAAS,GAAGtI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIsI,SAAS,KAAK,IAAI,EAAE;gBACtBb,KAAK,GAAG7H,OAAO,CAAC0I,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,YAAY;cACfP,UAAU,GAAG/H,WAAW;cACxB;YAEF,KAAK,gBAAgB;cACnBmI,cAAc,GAAGnI,WAAW,CAAC,CAAC,CAAC;cAC/B;YAEF,KAAK,YAAY;cACfgI,UAAU,GAAGhI,WAAW;cACxB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF,CAAC,CAAC;;QAGF,IAAI+G,cAAc;QAClB,IAAIiB,iBAAiB,GAAGC,eAAe,CAAC9B,UAAU,CAAC,CAAC,CAAC;;QAErD,IAAI5E,KAAK,EAAE;UACT,IAAI+E,cAAc,KAAK,IAAI,EAAE;YAC3B,IAAIJ,UAAU,CAACzM,MAAM,GAAG,CAAC,EAAE;cACzB;cACA,IAAIyO,kBAAkB,GAAGD,eAAe,CAAC/B,UAAU,CAAC,CAAC,CAAC;;cAEtDa,cAAc,GAAGI,+BAA+B,CAACa,iBAAiB,EAAEE,kBAAkB,EAAE3G,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACrG,CAAC,MAAM;cACL;cACAwF,cAAc,GAAGK,qBAAqB,CAACY,iBAAiB,EAAE,IAAInS,sBAAsB,CAAC0L,KAAK,EAAE,CAAC,CAAC,CAAC;YACjG;UACF,CAAC,MAAM;YACL,IAAI2E,UAAU,CAACzM,MAAM,GAAG,CAAC,EAAE;cACzB;cACA,IAAI0O,iBAAiB,GAAGb,WAAW,CAAC/F,KAAK,EAAE2E,UAAU,CAAC,CAAC,CAAC;;cAExD,IAAIkC,kBAAkB,GAAGC,cAAc,CAACF,iBAAiB,EAAEhC,UAAU,CAAC,CAAC,CAAC;;cAExEY,cAAc,GAAGuB,4BAA4B,CAACN,iBAAiB,EAAEI,kBAAkB,CAAC,CAAC,CAAC;YACxF,CAAC,MAAM;cACL;cACA,IAAIA,kBAAkB,GAAGC,cAAc,CAAC9G,KAAK,EAAE4E,UAAU,CAAC,CAAC,CAAC;;cAE5DY,cAAc,GAAGuB,4BAA4B,CAACN,iBAAiB,EAAEI,kBAAkB,CAAC,CAAC,CAAC;YACxF;UACF;QACF,CAAC,CAAC;;QAGF,IAAIlG,QAAQ,GAAG,IAAItM,cAAc,CAAC,CAAC;QACnC,IAAIkR,iBAAiB,GAAGM,qBAAqB,CAACY,iBAAiB,EAAE,IAAInS,sBAAsB,CAAC+P,KAAK,EAAE,CAAC,CAAC,CAAC;QACtG1D,QAAQ,CAAC6F,YAAY,CAAC,UAAU,EAAEjB,iBAAiB,CAAC;QACpD,IAAIC,cAAc,EAAE7E,QAAQ,CAAC6F,YAAY,CAAC,OAAO,EAAEhB,cAAc,CAAC;QAClE7E,QAAQ,CAACE,KAAK,GAAG,MAAM;QACvB,OAAOF,QAAQ;MACjB;MAEA,SAAS7C,iBAAiBA,CAAClD,IAAI,EAAE;QAC/B,IAAI+F,QAAQ;QACZ,IAAIX,KAAK,EAAEqE,KAAK;QAChB,IAAIrJ,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV,IAAIwG,SAAS,GAAGrI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIqI,SAAS,KAAK,IAAI,EAAE;gBACtBjF,KAAK,GAAGxD,OAAO,CAACyI,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,OAAO;cACV,IAAIC,SAAS,GAAGtI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIsI,SAAS,KAAK,IAAI,EAAE;gBACtBb,KAAK,GAAG7H,OAAO,CAAC0I,SAAS,CAAC;cAC5B;cAEA;YAEF;cACEvO,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIkC,QAAQ,GAAG,IAAItM,cAAc,CAAC,CAAC;QACnCsM,QAAQ,CAAC6F,YAAY,CAAC,UAAU,EAAE,IAAIlS,sBAAsB,CAAC+P,KAAK,EAAE,CAAC,CAAC,CAAC;QACvE,IAAIrE,KAAK,EAAEW,QAAQ,CAAC6F,YAAY,CAAC,OAAO,EAAE,IAAIlS,sBAAsB,CAAC0L,KAAK,EAAE,CAAC,CAAC,CAAC;QAC/EW,QAAQ,CAACE,KAAK,GAAG,QAAQ;QACzB,OAAOF,QAAQ;MACjB;MAEA,SAAS5C,YAAYA,CAACnD,IAAI,EAAE;QAC1B,IAAIkJ,IAAI,GAAG,IAAI9Q,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC/B,IAAIgI,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,MAAM;cACTqF,IAAI,CAACkD,CAAC,GAAGpK,WAAW,CAAC,CAAC,CAAC;cACvBkH,IAAI,CAACmD,CAAC,GAAGrK,WAAW,CAAC,CAAC,CAAC;cACvBkH,IAAI,CAACoD,CAAC,GAAGtK,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIkC,QAAQ,GAAG,IAAIpM,WAAW,CAACuP,IAAI,CAACkD,CAAC,EAAElD,IAAI,CAACmD,CAAC,EAAEnD,IAAI,CAACoD,CAAC,CAAC;QACtD,OAAOvG,QAAQ;MACjB;MAEA,SAAS3C,aAAaA,CAACpD,IAAI,EAAE;QAC3B,IAAI0E,MAAM,GAAG,CAAC;UACVsE,MAAM,GAAG,CAAC;UACVuD,SAAS,GAAG,KAAK;QACrB,IAAInM,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,QAAQ;cACX0I,SAAS,GAAG,CAACvK,WAAW,CAAC,CAAC,CAAC;cAC3B;YAEF,KAAK,cAAc;cACjB0C,MAAM,GAAG1C,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF,KAAK,QAAQ;cACXgH,MAAM,GAAGhH,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF,KAAK,MAAM;cACT;cACA;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIkC,QAAQ,GAAG,IAAInM,YAAY,CAAC8K,MAAM,EAAEsE,MAAM,EAAE,EAAE,EAAE,CAAC,EAAEuD,SAAS,CAAC;QACjE,OAAOxG,QAAQ;MACjB;MAEA,SAAS1C,iBAAiBA,CAACrD,IAAI,EAAE;QAC/B,IAAI0E,MAAM,GAAG,CAAC;UACVsE,MAAM,GAAG,CAAC;QACd,IAAI5I,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,QAAQ;cACX;cACA;YAEF,KAAK,QAAQ;cACXa,MAAM,GAAG1C,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF,KAAK,QAAQ;cACXgH,MAAM,GAAGhH,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF,KAAK,MAAM;cACT;cACA;YAEF,KAAK,KAAK;cACR;cACA;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIkC,QAAQ,GAAG,IAAIlM,gBAAgB,CAAC6K,MAAM,EAAEA,MAAM,EAAEsE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;QAClE,OAAOjD,QAAQ;MACjB;MAEA,SAASzC,eAAeA,CAACtD,IAAI,EAAE;QAC7B,IAAI0E,MAAM,GAAG,CAAC;QACd,IAAItE,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,QAAQ;cACXa,MAAM,GAAG1C,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIkC,QAAQ,GAAG,IAAIrN,cAAc,CAACgM,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;QACjD,OAAOqB,QAAQ;MACjB;MAEA,SAASxC,sBAAsBA,CAACvD,IAAI,EAAE;QACpC,IAAIoF,KAAK;QACT,IAAIsE,MAAM;QACV,IAAIC,QAAQ;QACZ,IAAIX,MAAM;QACV,IAAImB,cAAc,GAAG,IAAI;QACzB,IAAIC,eAAe,GAAG,IAAI;QAC1B,IAAIP,KAAK,GAAG,IAAI;QAChB,IAAID,GAAG,GAAG,IAAI;QACd,IAAIE,WAAW,GAAG,CAAC;QACnB,IAAI0C,UAAU,GAAG,CAAC;QAClB,IAAIC,UAAU,GAAG,CAAC;QAClB,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAIvM,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,OAAO;cACV,IAAIwG,SAAS,GAAGrI,WAAW,CAAC,CAAC,CAAC;cAE9B,IAAIqI,SAAS,KAAK,IAAI,EAAE;gBACtBjF,KAAK,GAAGxD,OAAO,CAACyI,SAAS,CAAC;cAC5B;cAEA;YAEF,KAAK,QAAQ;cACX,IAAIE,UAAU,GAAGvI,WAAW,CAAC,CAAC,CAAC;cAE/B,IAAIuI,UAAU,KAAK,IAAI,EAAE;gBACvBb,MAAM,GAAG9H,OAAO,CAAC2I,UAAU,CAAC;cAC9B;cAEA;YAEF,KAAK,UAAU;cACb,IAAIC,YAAY,GAAGxI,WAAW,CAAC,CAAC,CAAC;cAEjC,IAAIwI,YAAY,KAAK,IAAI,EAAE;gBACzBb,QAAQ,GAAG/H,OAAO,CAAC4I,YAAY,CAAC;cAClC;cAEA;YAEF,KAAK,QAAQ;cACXxB,MAAM,GAAGhH,WAAW;cACpB;YAEF,KAAK,KAAK;cACR4H,GAAG,GAAG5H,WAAW,CAAC,CAAC,CAAC;cACpB;YAEF,KAAK,gBAAgB;cACnBmI,cAAc,GAAGnI,WAAW,CAAC,CAAC,CAAC;cAC/B;YAEF,KAAK,aAAa;cAChB8H,WAAW,GAAG9H,WAAW,CAAC,CAAC,CAAC;cAC5B;YAEF,KAAK,iBAAiB;cACpBoI,eAAe,GAAGpI,WAAW,CAAC,CAAC,CAAC;cAChC;YAEF,KAAK,OAAO;cACV6H,KAAK,GAAG7H,WAAW,CAAC,CAAC,CAAC;cACtB;YAEF,KAAK,YAAY;cACfwK,UAAU,GAAGxK,WAAW,CAAC,CAAC,CAAC;cAC3B;YAEF,KAAK,UAAU;cACb0K,QAAQ,GAAG1K,WAAW,CAAC,CAAC,CAAC;cACzB;YAEF,KAAK,YAAY;cACfyK,UAAU,GAAGzK,WAAW,CAAC,CAAC,CAAC;cAC3B;YAEF,KAAK,UAAU;cACb2K,QAAQ,GAAG3K,WAAW,CAAC,CAAC,CAAC;cACzB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF,CAAC,CAAC;;QAGF,IAAI+I,QAAQ,GAAG,EAAE;QACjB,IAAIC,OAAO,GAAG,EAAE;QAChB,IAAIC,MAAM,GAAG,EAAE;QACf,IAAIC,GAAG,GAAG,EAAE;QAEZ,KAAK,IAAIzN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmN,UAAU,EAAEnN,CAAC,EAAE,EAAE;UACnC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuK,UAAU,EAAEvK,CAAC,EAAE,EAAE;YACnC;YACA,IAAI+K,KAAK,GAAG1N,CAAC,GAAGkN,UAAU,GAAGvK,CAAC,CAAC,CAAC;;YAEhC,IAAImK,CAAC,GAAGM,QAAQ,GAAGpN,CAAC;YACpB,IAAI+M,CAAC,GAAGrD,MAAM,CAACgE,KAAK,CAAC;YACrB,IAAIV,CAAC,GAAGK,QAAQ,GAAG1K,CAAC;YACpB2K,QAAQ,CAAC3M,IAAI,CAACmM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC;;YAExB,IAAIlH,KAAK,IAAI+E,cAAc,KAAK,IAAI,EAAE;cACpC,IAAI9B,CAAC,GAAGjD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC5B,IAAI1E,CAAC,GAAGlD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC5B,IAAIzE,CAAC,GAAGnD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC5BF,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;YACtB,CAAC,CAAC;;YAGF,IAAImB,MAAM,IAAIU,eAAe,KAAK,IAAI,EAAE;cACtC,IAAI6C,EAAE,GAAGvD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC9B,IAAIE,EAAE,GAAGxD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC9B,IAAIG,EAAE,GAAGzD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC9BH,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;YAC1B,CAAC,CAAC;;YAGF,IAAIxD,QAAQ,EAAE;cACZ,IAAIyD,CAAC,GAAGzD,QAAQ,CAACqD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC/B,IAAIK,CAAC,GAAG1D,QAAQ,CAACqD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;cAC/BD,GAAG,CAAC9M,IAAI,CAACmN,CAAC,EAAEC,CAAC,CAAC;YAChB,CAAC,MAAM;cACLN,GAAG,CAAC9M,IAAI,CAACX,CAAC,IAAIkN,UAAU,GAAG,CAAC,CAAC,EAAEvK,CAAC,IAAIwK,UAAU,GAAG,CAAC,CAAC,CAAC;YACtD;UACF;QACF,CAAC,CAAC;;QAGF,IAAIa,OAAO,GAAG,EAAE;QAEhB,KAAK,IAAIhO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkN,UAAU,GAAG,CAAC,EAAElN,CAAC,EAAE,EAAE;UACvC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwK,UAAU,GAAG,CAAC,EAAExK,CAAC,EAAE,EAAE;YACvC;YACA,IAAIwG,CAAC,GAAGnJ,CAAC,GAAG2C,CAAC,GAAGuK,UAAU;YAC1B,IAAIjE,CAAC,GAAGjJ,CAAC,GAAG,CAAC2C,CAAC,GAAG,CAAC,IAAIuK,UAAU;YAChC,IAAIe,CAAC,GAAGjO,CAAC,GAAG,CAAC,GAAG,CAAC2C,CAAC,GAAG,CAAC,IAAIuK,UAAU;YACpC,IAAIgB,CAAC,GAAGlO,CAAC,GAAG,CAAC,GAAG2C,CAAC,GAAGuK,UAAU,CAAC,CAAC;;YAEhC,IAAI5C,GAAG,KAAK,IAAI,EAAE;cAChB0D,OAAO,CAACrN,IAAI,CAACwI,CAAC,EAAE8E,CAAC,EAAEhF,CAAC,CAAC;cACrB+E,OAAO,CAACrN,IAAI,CAACsN,CAAC,EAAE9E,CAAC,EAAE+E,CAAC,CAAC;YACvB,CAAC,MAAM;cACLF,OAAO,CAACrN,IAAI,CAACwI,CAAC,EAAEF,CAAC,EAAEgF,CAAC,CAAC;cACrBD,OAAO,CAACrN,IAAI,CAACsN,CAAC,EAAEC,CAAC,EAAE/E,CAAC,CAAC;YACvB;UACF;QACF,CAAC,CAAC;;QAGF,IAAIkC,iBAAiB,GAAGM,qBAAqB,CAACqC,OAAO,EAAE,IAAI5T,sBAAsB,CAACkT,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC/F,IAAI9B,WAAW,GAAGG,qBAAqB,CAACqC,OAAO,EAAE,IAAI5T,sBAAsB,CAACqT,GAAG,EAAE,CAAC,CAAC,CAAC;QACpF,IAAInC,cAAc;QAClB,IAAIC,eAAe,CAAC,CAAC;;QAErB,IAAIzF,KAAK,EAAE;UACT,IAAI+E,cAAc,KAAK,KAAK,EAAE;YAC5B,KAAK,IAAI7K,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkN,UAAU,GAAG,CAAC,EAAElN,CAAC,EAAE,EAAE;cACvC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwK,UAAU,GAAG,CAAC,EAAExK,CAAC,EAAE,EAAE;gBACvC,IAAI+K,KAAK,GAAG1N,CAAC,GAAG2C,CAAC,IAAIuK,UAAU,GAAG,CAAC,CAAC;gBACpC,IAAInE,CAAC,GAAGjD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC5B,IAAI1E,CAAC,GAAGlD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC5B,IAAIzE,CAAC,GAAGnD,KAAK,CAAC4H,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;gBAE9BF,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;gBACpBuE,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;gBACpBuE,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;gBACpBuE,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;gBACpBuE,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;gBACpBuE,MAAM,CAAC7M,IAAI,CAACoI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;cACtB;YACF;YAEAqC,cAAc,GAAG,IAAIlR,sBAAsB,CAACoT,MAAM,EAAE,CAAC,CAAC;UACxD,CAAC,MAAM;YACLlC,cAAc,GAAGK,qBAAqB,CAACqC,OAAO,EAAE,IAAI5T,sBAAsB,CAACoT,MAAM,EAAE,CAAC,CAAC,CAAC;UACxF;QACF,CAAC,CAAC;;QAGF,IAAIpD,MAAM,EAAE;UACV,IAAIU,eAAe,KAAK,KAAK,EAAE;YAC7B,KAAK,IAAI9K,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkN,UAAU,GAAG,CAAC,EAAElN,CAAC,EAAE,EAAE;cACvC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwK,UAAU,GAAG,CAAC,EAAExK,CAAC,EAAE,EAAE;gBACvC,IAAI+K,KAAK,GAAG1N,CAAC,GAAG2C,CAAC,IAAIuK,UAAU,GAAG,CAAC,CAAC;gBACpC,IAAIS,EAAE,GAAGvD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC9B,IAAIE,EAAE,GAAGxD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC9B,IAAIG,EAAE,GAAGzD,MAAM,CAACsD,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;gBAEhCH,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBN,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBN,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBN,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBN,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;gBACxBN,OAAO,CAAC5M,IAAI,CAACgN,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;cAC1B;YACF;YAEAtC,eAAe,GAAG,IAAInR,sBAAsB,CAACmT,OAAO,EAAE,CAAC,CAAC;UAC1D,CAAC,MAAM;YACLhC,eAAe,GAAGI,qBAAqB,CAACqC,OAAO,EAAE,IAAI5T,sBAAsB,CAACmT,OAAO,EAAE,CAAC,CAAC,CAAC;UAC1F;QACF,CAAC,MAAM;UACLhC,eAAe,GAAGa,sBAAsB,CAAC4B,OAAO,EAAEV,QAAQ,EAAE9C,WAAW,CAAC;QAC1E,CAAC,CAAC;;QAGF,IAAI/D,QAAQ,GAAG,IAAItM,cAAc,CAAC,CAAC;QACnCsM,QAAQ,CAAC6F,YAAY,CAAC,UAAU,EAAEjB,iBAAiB,CAAC;QACpD5E,QAAQ,CAAC6F,YAAY,CAAC,QAAQ,EAAEf,eAAe,CAAC;QAChD9E,QAAQ,CAAC6F,YAAY,CAAC,IAAI,EAAEd,WAAW,CAAC;QACxC,IAAIF,cAAc,EAAE7E,QAAQ,CAAC6F,YAAY,CAAC,OAAO,EAAEhB,cAAc,CAAC,CAAC,CAAC;;QAEpE7E,QAAQ,CAACQ,MAAM,GAAGsD,KAAK;QACvB9D,QAAQ,CAACE,KAAK,GAAG,MAAM;QACvB,OAAOF,QAAQ;MACjB;MAEA,SAASvC,kBAAkBA,CAACxD,IAAI,EAAE;QAChC,IAAIyN,YAAY,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACrD,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC9B,IAAIvJ,KAAK;QACT,IAAIwJ,WAAW;QACf,IAAIC,QAAQ,GAAG,IAAI;QACnB,IAAIhE,GAAG,GAAG,IAAI;QACd,IAAIE,WAAW,GAAG,CAAC;QACnB,IAAI+D,MAAM,GAAG,IAAI;QACjB,IAAIhE,KAAK,GAAG,IAAI;QAChB,IAAIzJ,MAAM,GAAGJ,IAAI,CAACI,MAAM;QAExB,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGa,MAAM,CAAC9C,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIe,KAAK,GAAGD,MAAM,CAACd,CAAC,CAAC;UACrB,IAAIuE,SAAS,GAAGxD,KAAK,CAAC1C,IAAI;UAC1B,IAAIqE,WAAW,GAAG3B,KAAK,CAACG,MAAM;UAE9B,QAAQqD,SAAS;YACf,KAAK,UAAU;cACb+J,QAAQ,GAAG5L,WAAW,CAAC,CAAC,CAAC;cACzB;YAEF,KAAK,KAAK;cACR4H,GAAG,GAAG5H,WAAW,CAAC,CAAC,CAAC;cACpB;YAEF,KAAK,QAAQ;cACX;cACA;YAEF,KAAK,aAAa;cAChB8H,WAAW,GAAG9H,WAAW,CAAC,CAAC,CAAC;cAC5B;YAEF,KAAK,cAAc;cACjByL,YAAY,GAAGzL,WAAW;cAC1B;YAEF,KAAK,QAAQ;cACX6L,MAAM,GAAG7L,WAAW,CAAC,CAAC,CAAC;cACvB;YAEF,KAAK,aAAa;cAChB2L,WAAW,GAAG3L,WAAW;cACzB;YAEF,KAAK,OAAO;cACVmC,KAAK,GAAGnC,WAAW;cACnB;YAEF,KAAK,OAAO;cACV6H,KAAK,GAAG7H,WAAW,CAAC,CAAC,CAAC;cACtB;YAEF,KAAK,OAAO;cACV0L,KAAK,GAAG1L,WAAW,CAAC,CAAC;;cAErB;YAEF;cACEjG,OAAO,CAAC4H,IAAI,CAAC,kCAAkC,EAAEE,SAAS,CAAC;cAC3D;UACJ;QACF;QAEA,IAAIiK,kBAAkB,GAAGL,YAAY,CAAC,CAAC,CAAC,KAAKA,YAAY,CAACA,YAAY,CAACnQ,MAAM,GAAG,CAAC,CAAC,IAAImQ,YAAY,CAAC,CAAC,CAAC,KAAKA,YAAY,CAACA,YAAY,CAACnQ,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;;QAEjJ,IAAIsP,QAAQ,GAAG,EAAE;QACjB,IAAImB,WAAW,GAAG,IAAI3V,OAAO,CAAC,CAAC;QAC/B,IAAI4V,OAAO,GAAG,IAAI5V,OAAO,CAAC,CAAC;QAC3B,IAAI2L,IAAI,GAAG,IAAI3L,OAAO,CAAC,CAAC;QACxB,IAAI6V,MAAM,GAAG,IAAI7V,OAAO,CAAC,CAAC;QAC1B,IAAI6L,UAAU,GAAG,IAAInK,UAAU,CAAC,CAAC;QAEjC,KAAK,IAAIwF,CAAC,GAAG,CAAC,EAAE2C,CAAC,GAAG,CAAC,EAAEiM,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGT,KAAK,CAACpQ,MAAM,EAAEgC,CAAC,GAAG6O,EAAE,EAAE7O,CAAC,IAAI,CAAC,EAAE2C,CAAC,IAAI,CAAC,EAAEiM,CAAC,IAAI,CAAC,EAAE;UAC/EH,WAAW,CAACK,SAAS,CAACV,KAAK,EAAEpO,CAAC,CAAC;UAC/B0O,OAAO,CAAC5B,CAAC,GAAGjI,KAAK,GAAGA,KAAK,CAAClC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACpC+L,OAAO,CAAC3B,CAAC,GAAG,CAAC;UACb2B,OAAO,CAAC1B,CAAC,GAAGnI,KAAK,GAAGA,KAAK,CAAClC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACpC8B,IAAI,CAACqI,CAAC,GAAGuB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UAC7CnK,IAAI,CAACsI,CAAC,GAAGsB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UAC7CnK,IAAI,CAACuI,CAAC,GAAGqB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UAC7C,IAAIlK,KAAK,GAAG2J,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UAEhD,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEiF,EAAE,GAAGZ,YAAY,CAACnQ,MAAM,EAAE8L,CAAC,GAAGiF,EAAE,EAAEjF,CAAC,IAAI,CAAC,EAAE;YACxD6E,MAAM,CAAC7B,CAAC,GAAGqB,YAAY,CAACrE,CAAC,GAAG,CAAC,CAAC;YAC9B6E,MAAM,CAAC5B,CAAC,GAAG,CAAC;YACZ4B,MAAM,CAAC3B,CAAC,GAAGmB,YAAY,CAACrE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;YAEhC6E,MAAM,CAACK,QAAQ,CAACN,OAAO,CAAC,CAAC,CAAC;;YAE1B/J,UAAU,CAACC,gBAAgB,CAACH,IAAI,EAAEC,KAAK,CAAC;YACxCiK,MAAM,CAACM,eAAe,CAACtK,UAAU,CAAC,CAAC,CAAC;;YAEpCgK,MAAM,CAACpM,GAAG,CAACkM,WAAW,CAAC;YACvBnB,QAAQ,CAAC3M,IAAI,CAACgO,MAAM,CAAC7B,CAAC,EAAE6B,MAAM,CAAC5B,CAAC,EAAE4B,MAAM,CAAC3B,CAAC,CAAC;UAC7C;QACF,CAAC,CAAC;;QAGF,IAAIgB,OAAO,GAAG,EAAE;QAChB,IAAIkB,UAAU,GAAGd,KAAK,CAACpQ,MAAM,GAAG,CAAC;QACjC,IAAImR,iBAAiB,GAAGhB,YAAY,CAACnQ,MAAM,GAAG,CAAC;QAE/C,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkP,UAAU,GAAG,CAAC,EAAElP,CAAC,EAAE,EAAE;UACvC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwM,iBAAiB,GAAG,CAAC,EAAExM,CAAC,EAAE,EAAE;YAC9C,IAAIwG,CAAC,GAAGxG,CAAC,GAAG3C,CAAC,GAAGmP,iBAAiB;YACjC,IAAIlG,CAAC,GAAGtG,CAAC,GAAG,CAAC,GAAG3C,CAAC,GAAGmP,iBAAiB;YACrC,IAAIlB,CAAC,GAAGtL,CAAC,GAAG,CAAC3C,CAAC,GAAG,CAAC,IAAImP,iBAAiB;YACvC,IAAIjB,CAAC,GAAGvL,CAAC,GAAG,CAAC,GAAG,CAAC3C,CAAC,GAAG,CAAC,IAAImP,iBAAiB;YAE3C,IAAIxM,CAAC,KAAKwM,iBAAiB,GAAG,CAAC,IAAIX,kBAAkB,KAAK,IAAI,EAAE;cAC9DvF,CAAC,GAAGjJ,CAAC,GAAGmP,iBAAiB;cACzBjB,CAAC,GAAG,CAAClO,CAAC,GAAG,CAAC,IAAImP,iBAAiB;YACjC;YAEA,IAAI7E,GAAG,KAAK,IAAI,EAAE;cAChB0D,OAAO,CAACrN,IAAI,CAACwI,CAAC,EAAEF,CAAC,EAAEgF,CAAC,CAAC;cACrBD,OAAO,CAACrN,IAAI,CAACsN,CAAC,EAAEhF,CAAC,EAAEiF,CAAC,CAAC;YACvB,CAAC,MAAM;cACLF,OAAO,CAACrN,IAAI,CAACwI,CAAC,EAAE8E,CAAC,EAAEhF,CAAC,CAAC;cACrB+E,OAAO,CAACrN,IAAI,CAACsN,CAAC,EAAEC,CAAC,EAAEjF,CAAC,CAAC;YACvB;UACF;QACF,CAAC,CAAC;;QAGF,IAAIqF,QAAQ,KAAK,IAAI,IAAIC,MAAM,KAAK,IAAI,EAAE;UACxC,IAAIa,OAAO,GAAG,EAAE;UAEhB,KAAK,IAAIpP,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGkO,YAAY,CAACnQ,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;YACtDoP,OAAO,CAACzO,IAAI,CAAC,IAAI5H,OAAO,CAACoV,YAAY,CAACnO,CAAC,CAAC,EAAEmO,YAAY,CAACnO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UACjE;UAEA,IAAIqP,KAAK,GAAG5U,UAAU,CAAC6U,gBAAgB,CAACF,OAAO,EAAE,EAAE,CAAC;UACpD,IAAIG,UAAU,GAAG,EAAE;UAEnB,KAAK,IAAIvP,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGoP,KAAK,CAACrR,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC5C,IAAIwP,IAAI,GAAGH,KAAK,CAACrP,CAAC,CAAC;YACnBuP,UAAU,CAAC5O,IAAI,CAAC6O,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;UAC5C,CAAC,CAAC;;UAGF,IAAIlB,QAAQ,KAAK,IAAI,EAAE;YACrB,KAAK,IAAItO,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGsP,UAAU,CAACvR,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;cACpD,IAAIsK,GAAG,KAAK,IAAI,EAAE;gBAChB0D,OAAO,CAACrN,IAAI,CAAC4O,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEuP,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEuP,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,CAAC;cACvE,CAAC,MAAM;gBACLgO,OAAO,CAACrN,IAAI,CAAC4O,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEuP,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEuP,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,CAAC;cACvE;YACF;UACF,CAAC,CAAC;;UAGF,IAAIuO,MAAM,KAAK,IAAI,EAAE;YACnB,IAAIkB,WAAW,GAAGN,iBAAiB,IAAID,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;;YAExD,KAAK,IAAIlP,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGsP,UAAU,CAACvR,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;cACpD,IAAIsK,GAAG,KAAK,IAAI,EAAE;gBAChB0D,OAAO,CAACrN,IAAI,CAAC8O,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEyP,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEyP,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,CAAC;cACjH,CAAC,MAAM;gBACLgO,OAAO,CAACrN,IAAI,CAAC8O,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEyP,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,EAAEyP,WAAW,GAAGF,UAAU,CAACvP,CAAC,GAAG,CAAC,CAAC,CAAC;cACjH;YACF;UACF;QACF;QAEA,IAAIqL,iBAAiB,GAAGM,qBAAqB,CAACqC,OAAO,EAAE,IAAI5T,sBAAsB,CAACkT,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC/F,IAAI/B,eAAe,GAAGa,sBAAsB,CAAC4B,OAAO,EAAEV,QAAQ,EAAE9C,WAAW,CAAC;QAC5E,IAAI/D,QAAQ,GAAG,IAAItM,cAAc,CAAC,CAAC;QACnCsM,QAAQ,CAAC6F,YAAY,CAAC,UAAU,EAAEjB,iBAAiB,CAAC;QACpD5E,QAAQ,CAAC6F,YAAY,CAAC,QAAQ,EAAEf,eAAe,CAAC,CAAC,CAAC;QAClD;;QAEA9E,QAAQ,CAACQ,MAAM,GAAGsD,KAAK;QACvB9D,QAAQ,CAACE,KAAK,GAAG,MAAM;QACvB,OAAOF,QAAQ;MACjB,CAAC,CAAC;;MAGF,SAAS5D,UAAUA,CAAC6M,UAAU,EAAE;QAC9B,IAAIhP,IAAI,GAAG7D,OAAO,CAAC6S,UAAU,CAAC;QAC9B,IAAI5M,KAAK,GAAGR,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;QAC3B;QACA;;QAEA,OAAOoC,KAAK,CAAC6M,UAAU,IAAI7M,KAAK,CAAC8M,UAAU,GAAG9M,KAAK,CAAC+M,KAAK,CAAC,CAAC,GAAG/M,KAAK;MACrE;MAEA,SAAS0B,kBAAkBA,CAACsL,QAAQ,EAAEC,KAAK,EAAE;QAC3C,KAAK,IAAI/P,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG6P,QAAQ,CAAC9R,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC/C,IAAIqC,MAAM,GAAGC,OAAO,CAACwN,QAAQ,CAAC9P,CAAC,CAAC,CAAC;UACjC,IAAIqC,MAAM,YAAYnJ,QAAQ,EAAE6W,KAAK,CAACxN,GAAG,CAACF,MAAM,CAAC;QACnD;MACF;MAEA,SAAS+I,oBAAoBA,CAACsC,KAAK,EAAEpD,GAAG,EAAE;QACxC,IAAI0D,OAAO,GAAG,EAAE,CAAC,CAAC;QAClB;;QAEA,IAAIgC,KAAK,GAAG,CAAC;QAEb,KAAK,IAAIhQ,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIiQ,EAAE,GAAGvC,KAAK,CAACsC,KAAK,CAAC;UACrB,IAAIE,EAAE,GAAGxC,KAAK,CAAC1N,CAAC,IAAIsK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;UACjC,IAAI6F,EAAE,GAAGzC,KAAK,CAAC1N,CAAC,IAAIsK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;UACjC0D,OAAO,CAACrN,IAAI,CAACsP,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC,CAAC;;UAE1B,IAAIzC,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIC,CAAC,EAAE;YACrCD,CAAC,IAAI,CAAC;YACNgQ,KAAK,GAAGhQ,CAAC,GAAG,CAAC;UACf;QACF;QAEA,OAAOgO,OAAO;MAChB;MAEA,SAASjC,mBAAmBA,CAACnP,IAAI,EAAE8Q,KAAK,EAAE;QACxC,IAAI0C,gBAAgB,GAAG,EAAE;QACzB,IAAIJ,KAAK,GAAG,CAAC;QAEb,KAAK,IAAIhQ,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAI+J,MAAM,GAAGiG,KAAK,GAAG,CAAC;UACtB,IAAIlD,CAAC,GAAGlQ,IAAI,CAACmN,MAAM,CAAC;UACpB,IAAIgD,CAAC,GAAGnQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxB,IAAIiD,CAAC,GAAGpQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxBqG,gBAAgB,CAACzP,IAAI,CAACmM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC;;UAEhC,IAAIU,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIC,CAAC,EAAE;YACrCD,CAAC,IAAI,CAAC;YACNgQ,KAAK,EAAE;UACT;QACF;QAEA,OAAOI,gBAAgB;MACzB;MAEA,SAASvE,WAAWA,CAACjP,IAAI,EAAE8Q,KAAK,EAAE;QAChC,IAAI7B,WAAW,GAAG,EAAE;QAEpB,KAAK,IAAI7L,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIiQ,EAAE,GAAGvC,KAAK,CAAC1N,CAAC,CAAC;UACjB,IAAI+J,MAAM,GAAGkG,EAAE,GAAG,CAAC;UACnB,IAAInD,CAAC,GAAGlQ,IAAI,CAACmN,MAAM,CAAC;UACpB,IAAIgD,CAAC,GAAGnQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxB,IAAIiD,CAAC,GAAGpQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxB8B,WAAW,CAAClL,IAAI,CAACmM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;QAC3B;QAEA,OAAOnB,WAAW;MACpB;MAEA,SAASW,eAAeA,CAACkB,KAAK,EAAE;QAC9B,IAAIM,OAAO,GAAG,EAAE;QAEhB,KAAK,IAAIhO,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIiQ,EAAE,GAAGvC,KAAK,CAAC1N,CAAC,CAAC;UACjB,IAAIkQ,EAAE,GAAGxC,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC;UACrBgO,OAAO,CAACrN,IAAI,CAACsP,EAAE,EAAEC,EAAE,CAAC,CAAC,CAAC;;UAEtB,IAAIxC,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIC,CAAC,EAAE;YACrCD,CAAC,IAAI,CAAC;UACR;QACF;QAEA,OAAOgO,OAAO;MAChB;MAEA,SAASpB,cAAcA,CAAChQ,IAAI,EAAE8Q,KAAK,EAAE;QACnC,IAAI0C,gBAAgB,GAAG,EAAE;QACzB,IAAIJ,KAAK,GAAG,CAAC;QAEb,KAAK,IAAIhQ,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAI+J,MAAM,GAAGiG,KAAK,GAAG,CAAC;UACtB,IAAIlD,CAAC,GAAGlQ,IAAI,CAACmN,MAAM,CAAC;UACpB,IAAIgD,CAAC,GAAGnQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxB,IAAIiD,CAAC,GAAGpQ,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;UACxBqG,gBAAgB,CAACzP,IAAI,CAACmM,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC;;UAEhC,IAAIU,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIC,CAAC,EAAE;YACrCD,CAAC,IAAI,CAAC;YACNgQ,KAAK,EAAE;UACT;QACF;QAEA,OAAOI,gBAAgB;MACzB;MAEA,IAAIC,EAAE,GAAG,IAAIvX,OAAO,CAAC,CAAC;MACtB,IAAIwX,EAAE,GAAG,IAAIxX,OAAO,CAAC,CAAC;MACtB,IAAIyX,EAAE,GAAG,IAAIzX,OAAO,CAAC,CAAC;MACtB,IAAI0X,GAAG,GAAG,IAAIzX,OAAO,CAAC,CAAC;MACvB,IAAI0X,GAAG,GAAG,IAAI1X,OAAO,CAAC,CAAC;MACvB,IAAI2X,GAAG,GAAG,IAAI3X,OAAO,CAAC,CAAC;MAEvB,SAAS2S,+BAA+BA,CAAChB,UAAU,EAAEgD,KAAK,EAAE9Q,IAAI,EAAE+T,QAAQ,EAAE;QAC1E,IAAIC,KAAK,GAAG,EAAE,CAAC,CAAC;;QAEhB,KAAK,IAAI5Q,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyK,UAAU,CAAC1M,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;UACpD,IAAImJ,CAAC,GAAGuE,KAAK,CAAC1N,CAAC,CAAC;UAChB,IAAIiJ,CAAC,GAAGyE,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC;UACpB,IAAIiO,CAAC,GAAGP,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC;UAEpB,IAAI2Q,QAAQ,KAAK,CAAC,EAAE;YAClBH,GAAG,CAAC1B,SAAS,CAAClS,IAAI,EAAEuM,CAAC,GAAGwH,QAAQ,CAAC;YACjCF,GAAG,CAAC3B,SAAS,CAAClS,IAAI,EAAEqM,CAAC,GAAG0H,QAAQ,CAAC;YACjCD,GAAG,CAAC5B,SAAS,CAAClS,IAAI,EAAEqR,CAAC,GAAG0C,QAAQ,CAAC;YACjCC,KAAK,CAACjQ,IAAI,CAAC6P,GAAG,CAAC1D,CAAC,EAAE0D,GAAG,CAACzD,CAAC,CAAC;YACxB6D,KAAK,CAACjQ,IAAI,CAAC8P,GAAG,CAAC3D,CAAC,EAAE2D,GAAG,CAAC1D,CAAC,CAAC;YACxB6D,KAAK,CAACjQ,IAAI,CAAC+P,GAAG,CAAC5D,CAAC,EAAE4D,GAAG,CAAC3D,CAAC,CAAC;UAC1B,CAAC,MAAM;YACLsD,EAAE,CAACvB,SAAS,CAAClS,IAAI,EAAEuM,CAAC,GAAGwH,QAAQ,CAAC;YAChCL,EAAE,CAACxB,SAAS,CAAClS,IAAI,EAAEqM,CAAC,GAAG0H,QAAQ,CAAC;YAChCJ,EAAE,CAACzB,SAAS,CAAClS,IAAI,EAAEqR,CAAC,GAAG0C,QAAQ,CAAC;YAChCC,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;YAC5B4D,KAAK,CAACjQ,IAAI,CAAC2P,EAAE,CAACxD,CAAC,EAAEwD,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,CAAC;YAC5B4D,KAAK,CAACjQ,IAAI,CAAC4P,EAAE,CAACzD,CAAC,EAAEyD,EAAE,CAACxD,CAAC,EAAEwD,EAAE,CAACvD,CAAC,CAAC;UAC9B;QACF;QAEA,OAAO,IAAI5S,sBAAsB,CAACwW,KAAK,EAAED,QAAQ,CAAC;MACpD;MAEA,SAAS3E,4BAA4BA,CAAC0B,KAAK,EAAEmD,QAAQ,EAAE;QACrD,IAAID,KAAK,GAAG,EAAE;QAEd,KAAK,IAAI5Q,CAAC,GAAG,CAAC,EAAE2C,CAAC,GAAG,CAAC,EAAE1C,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE2C,CAAC,EAAE,EAAE;UAC3D0N,EAAE,CAACvB,SAAS,CAAC+B,QAAQ,EAAElO,CAAC,GAAG,CAAC,CAAC;UAC7BiO,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;UAC5B4D,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;UAC5B4D,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;QAC9B;QAEA,OAAO,IAAI5S,sBAAsB,CAACwW,KAAK,EAAE,CAAC,CAAC;MAC7C;MAEA,SAAS/D,4BAA4BA,CAACa,KAAK,EAAEoD,QAAQ,EAAE;QACrD,IAAIF,KAAK,GAAG,EAAE;QAEd,KAAK,IAAI5Q,CAAC,GAAG,CAAC,EAAE2C,CAAC,GAAG,CAAC,EAAE1C,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE2C,CAAC,EAAE,EAAE;UAC3D0N,EAAE,CAACvB,SAAS,CAACgC,QAAQ,EAAEnO,CAAC,GAAG,CAAC,CAAC;UAC7BiO,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;UAC5B4D,KAAK,CAACjQ,IAAI,CAAC0P,EAAE,CAACvD,CAAC,EAAEuD,EAAE,CAACtD,CAAC,EAAEsD,EAAE,CAACrD,CAAC,CAAC;QAC9B;QAEA,OAAO,IAAI5S,sBAAsB,CAACwW,KAAK,EAAE,CAAC,CAAC;MAC7C;MAEA,SAASjF,qBAAqBA,CAACqC,OAAO,EAAE+C,SAAS,EAAE;QACjD,IAAIH,KAAK,GAAGG,SAAS,CAACH,KAAK;QAC3B,IAAID,QAAQ,GAAGI,SAAS,CAACJ,QAAQ;QACjC,IAAIK,MAAM,GAAG,IAAIJ,KAAK,CAACrV,WAAW,CAACyS,OAAO,CAAChQ,MAAM,GAAG2S,QAAQ,CAAC;QAC7D,IAAIjD,KAAK,GAAG,CAAC;UACTuD,MAAM,GAAG,CAAC;QAEd,KAAK,IAAIjR,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG+N,OAAO,CAAChQ,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC9C0N,KAAK,GAAGM,OAAO,CAAChO,CAAC,CAAC,GAAG2Q,QAAQ;UAE7B,KAAK,IAAIhO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgO,QAAQ,EAAEhO,CAAC,EAAE,EAAE;YACjCqO,MAAM,CAACC,MAAM,EAAE,CAAC,GAAGL,KAAK,CAAClD,KAAK,EAAE,CAAC;UACnC;QACF;QAEA,OAAO,IAAItT,sBAAsB,CAAC4W,MAAM,EAAEL,QAAQ,CAAC;MACrD;MAEA,IAAIO,EAAE,GAAG,IAAIpY,OAAO,CAAC,CAAC;MACtB,IAAIqY,EAAE,GAAG,IAAIrY,OAAO,CAAC,CAAC;MAEtB,SAASsT,sBAAsBA,CAACsB,KAAK,EAAEvD,KAAK,EAAEK,WAAW,EAAE;QACzD,IAAI6E,KAAK,GAAG,EAAE;QACd,IAAI+B,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;;QAExB,KAAK,IAAIpR,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGyN,KAAK,CAAC1P,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;UAC/C,IAAImJ,CAAC,GAAGuE,KAAK,CAAC1N,CAAC,CAAC;UAChB,IAAIiJ,CAAC,GAAGyE,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC;UACpB,IAAIiO,CAAC,GAAGP,KAAK,CAAC1N,CAAC,GAAG,CAAC,CAAC;UACpB,IAAIwP,IAAI,GAAG,IAAI6B,IAAI,CAAClI,CAAC,EAAEF,CAAC,EAAEgF,CAAC,CAAC;UAC5BoC,EAAE,CAACvB,SAAS,CAAC3E,KAAK,EAAEhB,CAAC,GAAG,CAAC,CAAC;UAC1BmH,EAAE,CAACxB,SAAS,CAAC3E,KAAK,EAAElB,CAAC,GAAG,CAAC,CAAC;UAC1BsH,EAAE,CAACzB,SAAS,CAAC3E,KAAK,EAAE8D,CAAC,GAAG,CAAC,CAAC;UAC1BkD,EAAE,CAACG,UAAU,CAACf,EAAE,EAAED,EAAE,CAAC;UACrBY,EAAE,CAACI,UAAU,CAACjB,EAAE,EAAEC,EAAE,CAAC;UACrBa,EAAE,CAACI,KAAK,CAACL,EAAE,CAAC;UACZC,EAAE,CAACK,SAAS,CAAC,CAAC;UACdhC,IAAI,CAACpF,MAAM,CAACtD,IAAI,CAACqK,EAAE,CAAC;UACpB,IAAIC,aAAa,CAACjI,CAAC,CAAC,KAAKpG,SAAS,EAAEqO,aAAa,CAACjI,CAAC,CAAC,GAAG,EAAE;UACzD,IAAIiI,aAAa,CAACnI,CAAC,CAAC,KAAKlG,SAAS,EAAEqO,aAAa,CAACnI,CAAC,CAAC,GAAG,EAAE;UACzD,IAAImI,aAAa,CAACnD,CAAC,CAAC,KAAKlL,SAAS,EAAEqO,aAAa,CAACnD,CAAC,CAAC,GAAG,EAAE;UACzDmD,aAAa,CAACjI,CAAC,CAAC,CAACxI,IAAI,CAAC6O,IAAI,CAACpF,MAAM,CAAC;UAClCgH,aAAa,CAACnI,CAAC,CAAC,CAACtI,IAAI,CAAC6O,IAAI,CAACpF,MAAM,CAAC;UAClCgH,aAAa,CAACnD,CAAC,CAAC,CAACtN,IAAI,CAAC6O,IAAI,CAACpF,MAAM,CAAC;UAClCiF,KAAK,CAAC1O,IAAI,CAAC6O,IAAI,CAAC;QAClB,CAAC,CAAC;;QAGF,IAAIjC,OAAO,GAAG,EAAE;QAEhB,KAAK,IAAIvN,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGoP,KAAK,CAACrR,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC5C,IAAIwP,IAAI,GAAGH,KAAK,CAACrP,CAAC,CAAC;UACnB,IAAIyR,EAAE,GAAGC,cAAc,CAACN,aAAa,CAAC5B,IAAI,CAACrG,CAAC,CAAC,EAAEqG,IAAI,CAACpF,MAAM,EAAEI,WAAW,CAAC;UACxE,IAAImH,EAAE,GAAGD,cAAc,CAACN,aAAa,CAAC5B,IAAI,CAACvG,CAAC,CAAC,EAAEuG,IAAI,CAACpF,MAAM,EAAEI,WAAW,CAAC;UACxE,IAAIoH,EAAE,GAAGF,cAAc,CAACN,aAAa,CAAC5B,IAAI,CAACvB,CAAC,CAAC,EAAEuB,IAAI,CAACpF,MAAM,EAAEI,WAAW,CAAC;UACxE6F,EAAE,CAACvB,SAAS,CAAC3E,KAAK,EAAEqF,IAAI,CAACrG,CAAC,GAAG,CAAC,CAAC;UAC/BmH,EAAE,CAACxB,SAAS,CAAC3E,KAAK,EAAEqF,IAAI,CAACvG,CAAC,GAAG,CAAC,CAAC;UAC/BsH,EAAE,CAACzB,SAAS,CAAC3E,KAAK,EAAEqF,IAAI,CAACvB,CAAC,GAAG,CAAC,CAAC;UAC/BV,OAAO,CAAC5M,IAAI,CAAC8Q,EAAE,CAAC3E,CAAC,EAAE2E,EAAE,CAAC1E,CAAC,EAAE0E,EAAE,CAACzE,CAAC,CAAC;UAC9BO,OAAO,CAAC5M,IAAI,CAACgR,EAAE,CAAC7E,CAAC,EAAE6E,EAAE,CAAC5E,CAAC,EAAE4E,EAAE,CAAC3E,CAAC,CAAC;UAC9BO,OAAO,CAAC5M,IAAI,CAACiR,EAAE,CAAC9E,CAAC,EAAE8E,EAAE,CAAC7E,CAAC,EAAE6E,EAAE,CAAC5E,CAAC,CAAC;QAChC;QAEA,OAAO,IAAI5S,sBAAsB,CAACmT,OAAO,EAAE,CAAC,CAAC;MAC/C;MAEA,SAASmE,cAAcA,CAACnE,OAAO,EAAEsE,MAAM,EAAErH,WAAW,EAAE;QACpD,IAAIJ,MAAM,GAAG,IAAItR,OAAO,CAAC,CAAC;QAE1B,IAAI0R,WAAW,KAAK,CAAC,EAAE;UACrBJ,MAAM,CAACtD,IAAI,CAAC+K,MAAM,CAAC;QACrB,CAAC,MAAM;UACL,KAAK,IAAI7R,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGsN,OAAO,CAACvP,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC9C,IAAIuN,OAAO,CAACvN,CAAC,CAAC,CAAC8R,OAAO,CAACD,MAAM,CAAC,GAAGrH,WAAW,EAAE;cAC5CJ,MAAM,CAAC7H,GAAG,CAACgL,OAAO,CAACvN,CAAC,CAAC,CAAC;YACxB;UACF;QACF;QAEA,OAAOoK,MAAM,CAACoH,SAAS,CAAC,CAAC;MAC3B;MAEA,SAAS5L,YAAYA,CAAC4H,MAAM,EAAE;QAC5B,IAAIoD,KAAK,GAAG,EAAE;QAEd,KAAK,IAAI5Q,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGuN,MAAM,CAACxP,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;UAChD4Q,KAAK,CAACjQ,IAAI,CAAC,IAAI5G,KAAK,CAACyT,MAAM,CAACxN,CAAC,CAAC,EAAEwN,MAAM,CAACxN,CAAC,GAAG,CAAC,CAAC,EAAEwN,MAAM,CAACxN,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAChE;QAEA,OAAO4Q,KAAK;MACd;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MAGM,SAASjL,UAAUA,CAACc,QAAQ,EAAErB,MAAM,EAAE2M,MAAM,EAAEvE,MAAM,EAAEwE,OAAO,EAAE;QAC7D;QACA,IAAIC,UAAU,GAAG,EAAE;QACnB,IAAIC,UAAU,GAAGF,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG9L,IAAI,CAACC,EAAE;QAE/C,KAAK,IAAInG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGuN,MAAM,CAACxP,MAAM,EAAEgC,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAI0E,KAAK,GAAG1E,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG+R,MAAM,CAAC/R,CAAC,GAAG,CAAC,CAAC;UACvC0E,KAAK,GAAGsN,OAAO,KAAK,IAAI,GAAGtN,KAAK,GAAGwN,UAAU,GAAGxN,KAAK;UACrD,IAAIyN,KAAK,GAAG,IAAIrZ,OAAO,CAAC,CAAC;UACzBqZ,KAAK,CAACC,sBAAsB,CAAChN,MAAM,EAAEV,KAAK,EAAE,CAAC,CAAC;UAC9CuN,UAAU,CAACtR,IAAI,CAACwR,KAAK,CAAC;QACxB,CAAC,CAAC;;QAGF,IAAInE,OAAO,GAAGvH,QAAQ,CAACiH,KAAK;QAC5B,IAAIrC,iBAAiB,GAAG5E,QAAQ,CAACC,UAAU,CAAC3B,QAAQ;QACpD,IAAIuG,cAAc,GAAG,IAAI5Q,eAAe,CAAC,IAAI2X,YAAY,CAAC5L,QAAQ,CAACC,UAAU,CAAC3B,QAAQ,CAACuN,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;QACrG,IAAIvN,QAAQ,GAAG,IAAIjM,OAAO,CAAC,CAAC;QAC5B,IAAIgN,KAAK,GAAG,IAAI/L,KAAK,CAAC,CAAC;QAEvB,KAAK,IAAIiG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgO,OAAO,CAACsE,KAAK,EAAEtS,CAAC,EAAE,EAAE;UACtC,IAAI0N,KAAK,GAAGM,OAAO,CAACuE,IAAI,CAACvS,CAAC,CAAC;UAC3B+E,QAAQ,CAACyN,mBAAmB,CAACnH,iBAAiB,EAAEqC,KAAK,CAAC;UACtD,IAAI+E,eAAe,EAAEC,eAAe;UACpC,IAAI3E,CAAC,GAAG,CAAC;UAET,KAAK,IAAIpL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsP,UAAU,CAACjU,MAAM,EAAE2E,CAAC,EAAE,EAAE;YAC1C8P,eAAe,GAAG9P,CAAC,GAAG,CAAC;YACvB+P,eAAe,GAAG/P,CAAC;YACnB,IAAIgQ,UAAU,GAAGV,UAAU,CAACQ,eAAe,CAAC;YAC5C,IAAIG,UAAU,GAAGX,UAAU,CAACS,eAAe,CAAC;YAE5C,IAAIV,OAAO,KAAK,IAAI,EAAE;cACpB;cACA,IAAIjN,QAAQ,CAACgI,CAAC,IAAI4F,UAAU,CAAC5F,CAAC,IAAIhI,QAAQ,CAACgI,CAAC,GAAG6F,UAAU,CAAC7F,CAAC,EAAE;gBAC3DgB,CAAC,GAAG7H,IAAI,CAAC2M,GAAG,CAACF,UAAU,CAAC5F,CAAC,GAAGhI,QAAQ,CAACgI,CAAC,CAAC,GAAG7G,IAAI,CAAC2M,GAAG,CAACF,UAAU,CAAC5F,CAAC,GAAG6F,UAAU,CAAC7F,CAAC,CAAC;gBAC/E;cACF;YACF,CAAC,MAAM;cACL;cACA,IAAIhI,QAAQ,CAACgI,CAAC,IAAI4F,UAAU,CAAC5F,CAAC,IAAIhI,QAAQ,CAACgI,CAAC,GAAG6F,UAAU,CAAC7F,CAAC,EAAE;gBAC3DgB,CAAC,GAAG7H,IAAI,CAAC2M,GAAG,CAACF,UAAU,CAAC5F,CAAC,GAAGhI,QAAQ,CAACgI,CAAC,CAAC,GAAG7G,IAAI,CAAC2M,GAAG,CAACF,UAAU,CAAC5F,CAAC,GAAG6F,UAAU,CAAC7F,CAAC,CAAC;gBAC/E;cACF;YACF;UACF;UAEA,IAAI+F,MAAM,GAAGtF,MAAM,CAACiF,eAAe,CAAC;UACpC,IAAIM,MAAM,GAAGvF,MAAM,CAACkF,eAAe,CAAC;UACpC5M,KAAK,CAACgB,IAAI,CAACgM,MAAM,CAAC,CAACE,IAAI,CAACD,MAAM,EAAEhF,CAAC,CAAC;UAClCzC,cAAc,CAAC2H,MAAM,CAACvF,KAAK,EAAE5H,KAAK,CAACiD,CAAC,EAAEjD,KAAK,CAACkD,CAAC,EAAElD,KAAK,CAACmD,CAAC,CAAC;QACzD;QAEAxC,QAAQ,CAAC6F,YAAY,CAAC,OAAO,EAAEhB,cAAc,CAAC;MAChD,CAAC,CAAC;;MAGF,IAAItB,aAAa,GAAG,IAAIhR,aAAa,CAAC,IAAI,CAACiC,OAAO,CAAC;MACnD+O,aAAa,CAAC/N,OAAO,CAAC,IAAI,CAACiX,YAAY,IAAIpX,IAAI,CAAC,CAACqX,cAAc,CAAC,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC;;MAEnF,IAAIxW,IAAI,CAACyW,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE;QACrC,MAAMpV,KAAK,CAAC,uDAAuD,CAAC;MACtE,CAAC,CAAC;;MAGF,IAAIiE,IAAI,GAAGpF,gBAAgB,CAACF,IAAI,CAAC,CAAC,CAAC;;MAEnC,IAAIuF,KAAK,GAAGF,SAAS,CAACC,IAAI,CAAC;MAC3B,OAAOC,KAAK;IACd;EACF,CAAC,CAAC;EAEF,SAASjF,SAASA,CAACC,MAAM,EAAE;IACzB,IAAI,CAACF,KAAK,GAAG,IAAIlC,KAAK,CAACoC,MAAM,CAAC,CAAC,CAAC;EAClC;EAEAD,SAAS,CAAC/B,SAAS,GAAG;IACpBI,WAAW,EAAE2B,SAAS;IACtBS,GAAG,EAAE,SAAAA,CAAU2V,SAAS,EAAE;MACxB,IAAI5V,YAAY,GAAG,IAAI,CAACT,KAAK,CAACsW,QAAQ,CAACD,SAAS,CAAC;MAEjD,IAAI5V,YAAY,CAACK,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;QAClCvB,OAAO,CAACC,KAAK,CAACgB,YAAY,CAACK,MAAM,CAAC;QAClC,MAAME,KAAK,CAAC,0CAA0C,CAAC;MACzD;MAEA,OAAOP,YAAY;IACrB;EACF,CAAC;EAED,SAASL,UAAUA,CAACC,eAAe,EAAE;IACnCzC,MAAM,CAACK,IAAI,CAAC,IAAI,EAAEoC,eAAe,CAAC,CAAC,CAAC;;IAEpC,IAAIkW,CAAC,GAAG,IAAI;IACZ,IAAI9U,OAAO,GAAGpB,eAAe,CAAC,SAAS,CAAC;IACxC,IAAIoC,MAAM,GAAGpC,eAAe,CAAC,QAAQ,CAAC;IACtC,IAAIqC,MAAM,GAAGrC,eAAe,CAAC,QAAQ,CAAC;IACtC,IAAIkC,OAAO,GAAGlC,eAAe,CAAC,SAAS,CAAC;IACxC,IAAImC,OAAO,GAAGnC,eAAe,CAAC,SAAS,CAAC;IACxC,IAAIiB,UAAU,GAAGjB,eAAe,CAAC,YAAY,CAAC;IAC9C,IAAIc,eAAe,GAAGd,eAAe,CAAC,iBAAiB,CAAC;IACxD,IAAI4B,aAAa,GAAG5B,eAAe,CAAC,eAAe,CAAC;IACpD,IAAI6B,UAAU,GAAG7B,eAAe,CAAC,YAAY,CAAC;IAC9C,IAAI8B,aAAa,GAAG9B,eAAe,CAAC,eAAe,CAAC;IACpD,IAAI+B,WAAW,GAAG/B,eAAe,CAAC,aAAa,CAAC;IAChD,IAAIgC,YAAY,GAAGhC,eAAe,CAAC,cAAc,CAAC;IAClD,IAAIiC,WAAW,GAAGjC,eAAe,CAAC,aAAa,CAAC;IAChD,IAAIwB,GAAG,GAAGxB,eAAe,CAAC,KAAK,CAAC;IAChC,IAAIyB,GAAG,GAAGzB,eAAe,CAAC,KAAK,CAAC;IAChC,IAAI0B,KAAK,GAAG1B,eAAe,CAAC,OAAO,CAAC;IACpC,IAAI2B,EAAE,GAAG3B,eAAe,CAAC,IAAI,CAAC;IAC9B,IAAIqB,QAAQ,GAAGrB,eAAe,CAAC,UAAU,CAAC;IAC1CkW,CAAC,CAACC,IAAI,CAAC,MAAM,EAAE,YAAY;MACzBD,CAAC,CAACE,OAAO,CAACF,CAAC,CAACjT,OAAO,CAAC;MACpBiT,CAAC,CAACG,YAAY,CAAC,YAAY;QACzBH,CAAC,CAACE,OAAO,CAACF,CAAC,CAAC9S,IAAI,CAAC;MACnB,CAAC,CAAC;MACF8S,CAAC,CAACI,IAAI,CAAC,YAAY;QACjBJ,CAAC,CAACE,OAAO,CAACF,CAAC,CAAC5S,KAAK,CAAC;MACpB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF4S,CAAC,CAACC,IAAI,CAAC,SAAS,EAAE,YAAY;MAC5BD,CAAC,CAACK,OAAO,CAACnV,OAAO,CAAC;IACpB,CAAC,CAAC;IACF8U,CAAC,CAACC,IAAI,CAAC,MAAM,EAAE,YAAY;MACzBD,CAAC,CAACM,MAAM,CAAC,YAAY;QACnBN,CAAC,CAACE,OAAO,CAACF,CAAC,CAACxS,GAAG,CAAC;MAClB,CAAC,CAAC;MACFwS,CAAC,CAACK,OAAO,CAAClV,QAAQ,CAAC;MACnB6U,CAAC,CAACK,OAAO,CAACnU,MAAM,CAAC;MACjB8T,CAAC,CAACI,IAAI,CAAC,YAAY;QACjBJ,CAAC,CAACE,OAAO,CAACF,CAAC,CAACzS,KAAK,CAAC;MACpB,CAAC,CAAC;MACFyS,CAAC,CAACK,OAAO,CAAClU,MAAM,CAAC;IACnB,CAAC,CAAC;IACF6T,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,YAAY;MAC1BD,CAAC,CAACK,OAAO,CAACtV,UAAU,CAAC;MACrBiV,CAAC,CAACO,GAAG,CAAC,CAAC;QACLC,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAACpS,gBAAgB,CAAC;QAC/B;MACF,CAAC,EAAE;QACD4S,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAACnS,eAAe,CAAC;QAC9B;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACFmS,CAAC,CAACC,IAAI,CAAC,KAAK,EAAE,YAAY;MACxBD,CAAC,CAACK,OAAO,CAAC/U,GAAG,CAAC;MACd0U,CAAC,CAACS,EAAE,CAAC,CAAC;QACJD,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACK,OAAO,CAACtV,UAAU,CAAC;QACvB;MACF,CAAC,EAAE;QACDyV,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACK,OAAO,CAAClV,QAAQ,CAAC;QACrB;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF6U,CAAC,CAACC,IAAI,CAAC,KAAK,EAAE,YAAY;MACxBD,CAAC,CAACK,OAAO,CAAC9U,GAAG,CAAC;MACdyU,CAAC,CAACS,EAAE,CAAC,CAAC;QACJD,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACK,OAAO,CAACtV,UAAU,CAAC;QACvB;MACF,CAAC,EAAE;QACDyV,GAAG,EAAE,SAAAA,CAAA,EAAY;UACfR,CAAC,CAACK,OAAO,CAAClV,QAAQ,CAAC;QACrB;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF6U,CAAC,CAACC,IAAI,CAAC,kBAAkB,EAAE,YAAY;MACrCD,CAAC,CAACG,YAAY,CAAC,YAAY;QACzBH,CAAC,CAACS,EAAE,CAAC,CAAC;UACJD,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAAC9S,IAAI,CAAC;UACnB;QACF,CAAC,EAAE;UACDsT,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAAClS,GAAG,CAAC;UAClB;QACF,CAAC,EAAE;UACD0S,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAAC3U,aAAa,CAAC;UAC1B;QACF,CAAC,EAAE;UACD8U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAAC1U,UAAU,CAAC;UACvB;QACF,CAAC,EAAE;UACD6U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACzU,aAAa,CAAC;UAC1B;QACF,CAAC,EAAE;UACD4U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACxU,WAAW,CAAC;UACxB;QACF,CAAC,EAAE;UACD2U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACvU,YAAY,CAAC;UACzB;QACF,CAAC,EAAE;UACD0U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACtU,WAAW,CAAC;UACxB;QACF,CAAC,CAAC,CAAC;MACL,CAAC,CAAC;IACJ,CAAC,CAAC;IACFiU,CAAC,CAACC,IAAI,CAAC,iBAAiB,EAAE,YAAY;MACpCD,CAAC,CAACK,OAAO,CAACrU,OAAO,CAAC;MAClBgU,CAAC,CAACI,IAAI,CAAC,YAAY;QACjBJ,CAAC,CAACS,EAAE,CAAC,CAAC;UACJD,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAAC9S,IAAI,CAAC;UACnB;QACF,CAAC,EAAE;UACDsT,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACE,OAAO,CAACF,CAAC,CAAClS,GAAG,CAAC;UAClB;QACF,CAAC,EAAE;UACD0S,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAAC3U,aAAa,CAAC;UAC1B;QACF,CAAC,EAAE;UACD8U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAAC1U,UAAU,CAAC;UACvB;QACF,CAAC,EAAE;UACD6U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACzU,aAAa,CAAC;UAC1B;QACF,CAAC,EAAE;UACD4U,GAAG,EAAE,SAAAA,CAAA,EAAY;YACfR,CAAC,CAACK,OAAO,CAACtU,WAAW,CAAC;UACxB;QACF,CAAC,CAAC,CAAC;MACL,CAAC,CAAC;MACFiU,CAAC,CAACK,OAAO,CAACpU,OAAO,CAAC;IACpB,CAAC,CAAC;IACF+T,CAAC,CAACC,IAAI,CAAC,OAAO,EAAE,YAAY;MAC1BD,CAAC,CAACK,OAAO,CAAC7U,KAAK,CAAC;MAChBwU,CAAC,CAACK,OAAO,CAACzV,eAAe,CAAC;MAC1BoV,CAAC,CAACK,OAAO,CAAC5U,EAAE,CAAC;MACbuU,CAAC,CAACU,QAAQ,CAAC9V,eAAe,CAAC;IAC7B,CAAC,CAAC;IACF,IAAI,CAAC+V,mBAAmB,CAAC,CAAC;EAC5B;EAEA9W,UAAU,CAAClC,SAAS,GAAGC,MAAM,CAACE,MAAM,CAACT,MAAM,CAACM,SAAS,CAAC,CAAC,CAAC;;EAExDkC,UAAU,CAAClC,SAAS,CAACI,WAAW,GAAG8B,UAAU;EAE7C,SAASgU,IAAIA,CAAClI,CAAC,EAAEF,CAAC,EAAEgF,CAAC,EAAE;IACrB,IAAI,CAAC9E,CAAC,GAAGA,CAAC;IACV,IAAI,CAACF,CAAC,GAAGA,CAAC;IACV,IAAI,CAACgF,CAAC,GAAGA,CAAC;IACV,IAAI,CAAC7D,MAAM,GAAG,IAAItR,OAAO,CAAC,CAAC;EAC7B;EAEA,IAAIkP,YAAY,GAAG;IACjBY,SAAS,EAAE,CAAC;IACZX,eAAe,EAAE,CAAC;IAClBC,GAAG,EAAE,CAAC;IACNC,IAAI,EAAE;EACR,CAAC;EACD,OAAOnN,UAAU;AACnB,CAAC,CAAC,CAAC;AAEH,SAASA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module"}