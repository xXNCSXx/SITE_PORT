{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\nvar AbstractNextPossibleTokensWalker = /** @class */function (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    // immutable for the win\n    this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    // stop scanning once we found the path\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n  return AbstractNextPossibleTokensWalker;\n}(RestWalker);\nexport { AbstractNextPossibleTokensWalker };\nvar NextAfterTokenWalker = /** @class */function (_super) {\n  __extends(NextAfterTokenWalker, _super);\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path) || this;\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  };\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */function (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this) || this;\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n  return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker);\nexport { AbstractNextTerminalAfterProductionWalker };\nvar NextTerminalAfterManyWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterManyWalker };\nvar NextTerminalAfterManySepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterManySepWalker };\nvar NextTerminalAfterAtLeastOneWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterAtLeastOneWalker };\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */function (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  }\n  // avoid side effects\n  currPath = cloneArr(currPath);\n  var result = [];\n  var i = 0;\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      var newDef = [new Alternative({\n        definition: prod.definition\n      }), new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, function (currAlt) {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty(possiblePaths)) {\n    var currPath = possiblePaths.pop();\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack;\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n    var prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      var newRuleStack = cloneArr(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = cloneArr(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      var nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = cloneArr(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = cloneArr(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/interpreter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(RestWalker));\nexport { AbstractNextPossibleTokensWalker };\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker));\nexport { AbstractNextTerminalAfterProductionWalker };\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManyWalker };\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManySepWalker };\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneWalker };\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = cloneArr(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, function (currAlt) {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i)\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            var newRuleStack = cloneArr(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = cloneArr(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = cloneArr(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = cloneArr(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map"]},"metadata":{},"sourceType":"module"}