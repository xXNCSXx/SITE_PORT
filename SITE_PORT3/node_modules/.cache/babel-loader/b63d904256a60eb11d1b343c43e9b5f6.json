{"ast":null,"code":"import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nvar Water2 = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Water2';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var flowDirection = options.flowDirection || new Vector2(1, 0);\n  var flowSpeed = options.flowSpeed || 0.03;\n  var reflectivity = options.reflectivity || 0.02;\n  var scale = options.scale || 1;\n  var shader = options.shader || Water2.WaterShader;\n  var encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n  var textureLoader = new TextureLoader();\n  var flowMap = options.flowMap || undefined;\n  var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n  var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n  var cycle = 0.15; // a cycle of a flow map phase\n\n  var halfCycle = cycle * 0.5;\n  var textureMatrix = new Matrix4();\n  var clock = new Clock(); // internal components\n\n  if (Reflector === undefined) {\n    console.error('THREE.Water: Required component Reflector not found.');\n    return;\n  }\n  if (Refractor === undefined) {\n    console.error('THREE.Water: Required component Refractor not found.');\n    return;\n  }\n  var reflector = new Reflector(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  var refractor = new Refractor(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  reflector.matrixAutoUpdate = false;\n  refractor.matrixAutoUpdate = false; // material\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true,\n    fog: true\n  });\n  if (flowMap !== undefined) {\n    this.material.defines.USE_FLOWMAP = '';\n    this.material.uniforms['tFlowMap'] = {\n      type: 't',\n      value: flowMap\n    };\n  } else {\n    this.material.uniforms['flowDirection'] = {\n      type: 'v2',\n      value: flowDirection\n    };\n  } // maps\n\n  normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n  normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n  this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n  this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n  this.material.uniforms['tNormalMap0'].value = normalMap0;\n  this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['reflectivity'].value = reflectivity;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n  this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n  this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n  this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n  this.material.uniforms['config'].value.w = scale; // scale\n  // functions\n\n  function updateTextureMatrix(camera) {\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  }\n  function updateFlow() {\n    var delta = clock.getDelta();\n    var config = scope.material.uniforms['config'];\n    config.value.x += flowSpeed * delta; // flowMapOffset0\n\n    config.value.y = config.value.x + halfCycle; // flowMapOffset1\n    // Important: The distance between offsets should be always the value of \"halfCycle\".\n    // Moreover, both offsets should be in the range of [ 0, cycle ].\n    // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n    if (config.value.x >= cycle) {\n      config.value.x = 0;\n      config.value.y = halfCycle;\n    } else if (config.value.y >= cycle) {\n      config.value.y = config.value.y - cycle;\n    }\n  } //\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    updateTextureMatrix(camera);\n    updateFlow();\n    scope.visible = false;\n    reflector.matrixWorld.copy(scope.matrixWorld);\n    refractor.matrixWorld.copy(scope.matrixWorld);\n    reflector.onBeforeRender(renderer, scene, camera);\n    refractor.onBeforeRender(renderer, scene, camera);\n    scope.visible = true;\n  };\n};\nWater2.prototype = Object.create(Mesh.prototype);\nWater2.prototype.constructor = Water2;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: ['#include <common>', '#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'uniform mat4 textureMatrix;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\tvUv = uv;', '\tvCoord = textureMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvToEye = cameraPosition - worldPosition.xyz;', '\tvec4 mvPosition =  viewMatrix * worldPosition;',\n  // used in fog_vertex\n  '\tgl_Position = projectionMatrix * mvPosition;', '\t#include <logdepthbuf_vertex>', '\t#include <fog_vertex>', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', 'uniform sampler2D tReflectionMap;', 'uniform sampler2D tRefractionMap;', 'uniform sampler2D tNormalMap0;', 'uniform sampler2D tNormalMap1;', '#ifdef USE_FLOWMAP', '\tuniform sampler2D tFlowMap;', '#else', '\tuniform vec2 flowDirection;', '#endif', 'uniform vec3 color;', 'uniform float reflectivity;', 'uniform vec4 config;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\t#include <logdepthbuf_fragment>', '\tfloat flowMapOffset0 = config.x;', '\tfloat flowMapOffset1 = config.y;', '\tfloat halfCycle = config.z;', '\tfloat scale = config.w;', '\tvec3 toEye = normalize( vToEye );',\n  // determine flow direction\n  '\tvec2 flow;', '\t#ifdef USE_FLOWMAP', '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;', '\t#else', '\t\tflow = flowDirection;', '\t#endif', '\tflow.x *= - 1.0;',\n  // sample normal maps (distort uvs with flowdata)\n  '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );', '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',\n  // linear interpolate to get the final normal color\n  '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;', '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\n  // calculate normal vector\n  '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\n  // calculate the fresnel term to blend reflection and refraction maps\n  '\tfloat theta = max( dot( toEye, normal ), 0.0 );', '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',\n  // calculate final uv coords\n  '\tvec3 coord = vCoord.xyz / vCoord.w;', '\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;', '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );', '\tvec4 refractColor = texture2D( tRefractionMap, uv );',\n  // multiply water color with the mix of both textures\n  '\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '}'].join('\\n')\n};\nexport { Water2 };","map":{"version":3,"names":["Mesh","Color","Vector2","LinearEncoding","TextureLoader","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Vector4","Reflector","Refractor","Water2","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","prototype","Object","create","constructor","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","join"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/objects/Water2.js"],"sourcesContent":["import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nvar Water2 = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Water2';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var flowDirection = options.flowDirection || new Vector2(1, 0);\n  var flowSpeed = options.flowSpeed || 0.03;\n  var reflectivity = options.reflectivity || 0.02;\n  var scale = options.scale || 1;\n  var shader = options.shader || Water2.WaterShader;\n  var encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n  var textureLoader = new TextureLoader();\n  var flowMap = options.flowMap || undefined;\n  var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n  var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n  var cycle = 0.15; // a cycle of a flow map phase\n\n  var halfCycle = cycle * 0.5;\n  var textureMatrix = new Matrix4();\n  var clock = new Clock(); // internal components\n\n  if (Reflector === undefined) {\n    console.error('THREE.Water: Required component Reflector not found.');\n    return;\n  }\n\n  if (Refractor === undefined) {\n    console.error('THREE.Water: Required component Refractor not found.');\n    return;\n  }\n\n  var reflector = new Reflector(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  var refractor = new Refractor(geometry, {\n    textureWidth: textureWidth,\n    textureHeight: textureHeight,\n    clipBias: clipBias,\n    encoding: encoding\n  });\n  reflector.matrixAutoUpdate = false;\n  refractor.matrixAutoUpdate = false; // material\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true,\n    fog: true\n  });\n\n  if (flowMap !== undefined) {\n    this.material.defines.USE_FLOWMAP = '';\n    this.material.uniforms['tFlowMap'] = {\n      type: 't',\n      value: flowMap\n    };\n  } else {\n    this.material.uniforms['flowDirection'] = {\n      type: 'v2',\n      value: flowDirection\n    };\n  } // maps\n\n\n  normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n  normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n  this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n  this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n  this.material.uniforms['tNormalMap0'].value = normalMap0;\n  this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['reflectivity'].value = reflectivity;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n  this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n  this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n  this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n  this.material.uniforms['config'].value.w = scale; // scale\n  // functions\n\n  function updateTextureMatrix(camera) {\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  }\n\n  function updateFlow() {\n    var delta = clock.getDelta();\n    var config = scope.material.uniforms['config'];\n    config.value.x += flowSpeed * delta; // flowMapOffset0\n\n    config.value.y = config.value.x + halfCycle; // flowMapOffset1\n    // Important: The distance between offsets should be always the value of \"halfCycle\".\n    // Moreover, both offsets should be in the range of [ 0, cycle ].\n    // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n    if (config.value.x >= cycle) {\n      config.value.x = 0;\n      config.value.y = halfCycle;\n    } else if (config.value.y >= cycle) {\n      config.value.y = config.value.y - cycle;\n    }\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    updateTextureMatrix(camera);\n    updateFlow();\n    scope.visible = false;\n    reflector.matrixWorld.copy(scope.matrixWorld);\n    refractor.matrixWorld.copy(scope.matrixWorld);\n    reflector.onBeforeRender(renderer, scene, camera);\n    refractor.onBeforeRender(renderer, scene, camera);\n    scope.visible = true;\n  };\n};\n\nWater2.prototype = Object.create(Mesh.prototype);\nWater2.prototype.constructor = Water2;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: ['#include <common>', '#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'uniform mat4 textureMatrix;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\tvUv = uv;', '\tvCoord = textureMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvToEye = cameraPosition - worldPosition.xyz;', '\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\n  '\tgl_Position = projectionMatrix * mvPosition;', '\t#include <logdepthbuf_vertex>', '\t#include <fog_vertex>', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', 'uniform sampler2D tReflectionMap;', 'uniform sampler2D tRefractionMap;', 'uniform sampler2D tNormalMap0;', 'uniform sampler2D tNormalMap1;', '#ifdef USE_FLOWMAP', '\tuniform sampler2D tFlowMap;', '#else', '\tuniform vec2 flowDirection;', '#endif', 'uniform vec3 color;', 'uniform float reflectivity;', 'uniform vec4 config;', 'varying vec4 vCoord;', 'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\t#include <logdepthbuf_fragment>', '\tfloat flowMapOffset0 = config.x;', '\tfloat flowMapOffset1 = config.y;', '\tfloat halfCycle = config.z;', '\tfloat scale = config.w;', '\tvec3 toEye = normalize( vToEye );', // determine flow direction\n  '\tvec2 flow;', '\t#ifdef USE_FLOWMAP', '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;', '\t#else', '\t\tflow = flowDirection;', '\t#endif', '\tflow.x *= - 1.0;', // sample normal maps (distort uvs with flowdata)\n  '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );', '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );', // linear interpolate to get the final normal color\n  '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;', '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );', // calculate normal vector\n  '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );', // calculate the fresnel term to blend reflection and refraction maps\n  '\tfloat theta = max( dot( toEye, normal ), 0.0 );', '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );', // calculate final uv coords\n  '\tvec3 coord = vCoord.xyz / vCoord.w;', '\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;', '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );', '\tvec4 refractColor = texture2D( tRefractionMap, uv );', // multiply water color with the mix of both textures\n  '\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '}'].join('\\n')\n};\n\nexport { Water2 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}