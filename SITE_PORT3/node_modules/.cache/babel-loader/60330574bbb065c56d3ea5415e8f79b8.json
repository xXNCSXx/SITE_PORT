{"ast":null,"code":"import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n  propertiesRegexp = /[a-z_0-9]+/gi;\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\nFunctionNode.prototype.getShared = function () /* builder, output */\n{\n  return !this.isMethod;\n};\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n    offset = 0,\n    src = this.src;\n  for (let i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n  for (let ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n  var matches = [];\n  while (match = propertiesRegexp.exec(this.src)) matches.push(match);\n  for (let i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    var prop = match[0],\n      isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n      reference = prop;\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n      reference = node.build(builder);\n    }\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n      if (inputs) {\n        var i = 0;\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n    for (let keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n    if (this.includes.length) {\n      data.includes = [];\n      for (let i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n  return data;\n};\nexport { FunctionNode };","map":{"version":3,"names":["TempNode","NodeLib","declarationRegexp","propertiesRegexp","FunctionNode","src","includes","extensions","keywords","type","isMethod","undefined","isInterface","call","parse","prototype","Object","create","constructor","nodeType","useKeywords","getShared","getType","builder","getTypeByFormat","getInputByName","name","i","inputs","length","getIncludeByName","generate","output","match","offset","include","ext","matches","exec","push","prop","isGlobal","reference","containsKeyword","node","keyword","getKeywordData","cache","getKeyword","build","substring","index","contains","get","format","qualifier","indexOf","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","JSON","stringify","uuid"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/core/FunctionNode.js"],"sourcesContent":["import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\n\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (let i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (let ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) matches.push(match);\n\n  for (let i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (let keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (let i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}