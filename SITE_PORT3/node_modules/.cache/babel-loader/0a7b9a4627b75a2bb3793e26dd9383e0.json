{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = [];\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\nexport { OccurrenceValidationCollector };\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof AlternativeGAST || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(GAstVisitor);\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\nvar RepetionCollector = /** @class */function (_super) {\n  __extends(RepetionCollector, _super);\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetionCollector;\n}(GAstVisitor);\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = [];\n  // flatten\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/checks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (every(leftRecursionErrors, isEmpty)) {\n        emptyAltErrors = map(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tooManyAltsErrors = map(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = map(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)));\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n        var firstProd = utils.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(GAstVisitor));\nexport { OccurrenceValidationCollector };\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!utils.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (utils.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n            var newPath = utils.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(utils.flatten(errorsFromNextSteps));\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    var result = [];\n    if (utils.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = utils.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = isOptionalProd(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = utils.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(GAstVisitor));\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        var exceptLast = utils.dropRight(currOr.definition);\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n            if (utils.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(utils.compact(currErrors));\n    }, []);\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = utils.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(GAstVisitor));\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n            var prodType = getProdType(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    forEach(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = map(tokenTypes, function (currToken) { return currToken.name; });\n    forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (contains(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map"]},"metadata":{},"sourceType":"module"}