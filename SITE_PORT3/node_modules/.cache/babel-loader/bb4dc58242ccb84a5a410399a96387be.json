{"ast":null,"code":"import { Quaternion, Vector3, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Matrix4, Mesh, Line, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nconst CCDIKSolver = (() => {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh, iks) {\n    this.mesh = mesh;\n    this.iks = iks || [];\n    this._valid();\n  }\n  CCDIKSolver.prototype = {\n    constructor: CCDIKSolver,\n    /**\n     * Update IK bones.\n     *\n     * @return {CCDIKSolver}\n     */\n    update: (() => {\n      const q = new Quaternion();\n      const targetPos = new Vector3();\n      const targetVec = new Vector3();\n      const effectorPos = new Vector3();\n      const effectorVec = new Vector3();\n      const linkPos = new Vector3();\n      const invLinkQ = new Quaternion();\n      const linkScale = new Vector3();\n      const axis = new Vector3();\n      const vector = new Vector3();\n      return function update() {\n        const bones = this.mesh.skeleton.bones;\n        const iks = this.iks; // for reference overhead reduction in loop\n\n        const math = Math;\n        for (let i = 0, il = iks.length; i < il; i++) {\n          const ik = iks[i];\n          const effector = bones[ik.effector];\n          const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n          // because it calls updateMatrixWorld( true ) inside.\n\n          targetPos.setFromMatrixPosition(target.matrixWorld);\n          const links = ik.links;\n          const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n          for (let j = 0; j < iteration; j++) {\n            let rotated = false;\n            for (let k = 0, kl = links.length; k < kl; k++) {\n              const link = bones[links[k].index]; // skip this link and following links.\n              // this skip is used for MMD performance optimization.\n\n              if (links[k].enabled === false) break;\n              const limitation = links[k].limitation;\n              const rotationMin = links[k].rotationMin;\n              const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n              // because they call updateMatrixWorld( true ) inside.\n\n              link.matrixWorld.decompose(linkPos, invLinkQ, linkScale);\n              invLinkQ.invert();\n              effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n              effectorVec.subVectors(effectorPos, linkPos);\n              effectorVec.applyQuaternion(invLinkQ);\n              effectorVec.normalize();\n              targetVec.subVectors(targetPos, linkPos);\n              targetVec.applyQuaternion(invLinkQ);\n              targetVec.normalize();\n              let angle = targetVec.dot(effectorVec);\n              if (angle > 1.0) {\n                angle = 1.0;\n              } else if (angle < -1.0) {\n                angle = -1.0;\n              }\n              angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n              // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n              if (angle < 1e-5) continue;\n              if (ik.minAngle !== undefined && angle < ik.minAngle) {\n                angle = ik.minAngle;\n              }\n              if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n                angle = ik.maxAngle;\n              }\n              axis.crossVectors(effectorVec, targetVec);\n              axis.normalize();\n              q.setFromAxisAngle(axis, angle);\n              link.quaternion.multiply(q); // TODO: re-consider the limitation specification\n\n              if (limitation !== undefined) {\n                let c = link.quaternion.w;\n                if (c > 1.0) c = 1.0;\n                const c2 = math.sqrt(1 - c * c);\n                link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n              }\n              if (rotationMin !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).max(rotationMin));\n              }\n              if (rotationMax !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).min(rotationMax));\n              }\n              link.updateMatrixWorld(true);\n              rotated = true;\n            }\n            if (!rotated) break;\n          }\n        }\n        return this;\n      };\n    })(),\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n    createHelper: function () {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    },\n    // private methods\n    _valid: function () {\n      const iks = this.iks;\n      const bones = this.mesh.skeleton.bones;\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const effector = bones[ik.effector];\n        const links = ik.links;\n        let link0, link1;\n        link0 = effector;\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n          if (link0.parent !== link1) {\n            console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n          }\n          link0 = link1;\n        }\n      }\n    }\n  };\n  /**\n   * Visualize IK bones\n   *\n   * @param {SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n\n  function CCDIKHelper(mesh, iks) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.iks = iks || [];\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._init();\n  }\n  CCDIKHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: CCDIKHelper,\n    /**\n     * Updates IK bones visualization.\n     */\n    updateMatrixWorld: (() => {\n      const matrix = new Matrix4();\n      const vector = new Vector3();\n      function getPosition(bone, matrixWorldInv) {\n        return vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n      }\n      function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n        const v = getPosition(bone, matrixWorldInv);\n        array[index * 3 + 0] = v.x;\n        array[index * 3 + 1] = v.y;\n        array[index * 3 + 2] = v.z;\n      }\n      return function updateMatrixWorld(force) {\n        const mesh = this.root;\n        if (this.visible) {\n          let offset = 0;\n          const iks = this.iks;\n          const bones = mesh.skeleton.bones;\n          matrix.copy(mesh.matrixWorld).invert();\n          for (let i = 0, il = iks.length; i < il; i++) {\n            const ik = iks[i];\n            const targetBone = bones[ik.target];\n            const effectorBone = bones[ik.effector];\n            const targetMesh = this.children[offset++];\n            const effectorMesh = this.children[offset++];\n            targetMesh.position.copy(getPosition(targetBone, matrix));\n            effectorMesh.position.copy(getPosition(effectorBone, matrix));\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              const linkMesh = this.children[offset++];\n              linkMesh.position.copy(getPosition(linkBone, matrix));\n            }\n            const line = this.children[offset++];\n            const array = line.geometry.attributes.position.array;\n            setPositionOfBoneToAttributeArray(array, 0, targetBone, matrix);\n            setPositionOfBoneToAttributeArray(array, 1, effectorBone, matrix);\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              setPositionOfBoneToAttributeArray(array, j + 2, linkBone, matrix);\n            }\n            line.geometry.attributes.position.needsUpdate = true;\n          }\n        }\n        this.matrix.copy(mesh.matrixWorld);\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    })(),\n    // private method\n    _init: function () {\n      const scope = this;\n      const iks = this.iks;\n      function createLineGeometry(ik) {\n        const geometry = new BufferGeometry();\n        const vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n        this.add(createLine(ik));\n      }\n    }\n  });\n  return CCDIKSolver;\n})();\nexport { CCDIKSolver };","map":{"version":3,"names":["Quaternion","Vector3","Object3D","SphereGeometry","MeshBasicMaterial","Color","LineBasicMaterial","Matrix4","Mesh","Line","BufferGeometry","BufferAttribute","CCDIKSolver","mesh","iks","_valid","prototype","constructor","update","q","targetPos","targetVec","effectorPos","effectorVec","linkPos","invLinkQ","linkScale","axis","vector","bones","skeleton","math","Math","i","il","length","ik","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","undefined","j","rotated","k","kl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","toVector3","max","min","updateMatrixWorld","createHelper","CCDIKHelper","geometry","userData","MMD","link0","link1","jl","parent","console","warn","name","call","root","matrix","copy","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","_init","Object","assign","create","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","attributes","needsUpdate","scope","createLineGeometry","vertices","Float32Array","setAttribute","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","add"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/animation/CCDIKSolver.js"],"sourcesContent":["import { Quaternion, Vector3, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Matrix4, Mesh, Line, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nconst CCDIKSolver = (() => {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh, iks) {\n    this.mesh = mesh;\n    this.iks = iks || [];\n\n    this._valid();\n  }\n\n  CCDIKSolver.prototype = {\n    constructor: CCDIKSolver,\n\n    /**\n     * Update IK bones.\n     *\n     * @return {CCDIKSolver}\n     */\n    update: (() => {\n      const q = new Quaternion();\n      const targetPos = new Vector3();\n      const targetVec = new Vector3();\n      const effectorPos = new Vector3();\n      const effectorVec = new Vector3();\n      const linkPos = new Vector3();\n      const invLinkQ = new Quaternion();\n      const linkScale = new Vector3();\n      const axis = new Vector3();\n      const vector = new Vector3();\n      return function update() {\n        const bones = this.mesh.skeleton.bones;\n        const iks = this.iks; // for reference overhead reduction in loop\n\n        const math = Math;\n\n        for (let i = 0, il = iks.length; i < il; i++) {\n          const ik = iks[i];\n          const effector = bones[ik.effector];\n          const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n          // because it calls updateMatrixWorld( true ) inside.\n\n          targetPos.setFromMatrixPosition(target.matrixWorld);\n          const links = ik.links;\n          const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n          for (let j = 0; j < iteration; j++) {\n            let rotated = false;\n\n            for (let k = 0, kl = links.length; k < kl; k++) {\n              const link = bones[links[k].index]; // skip this link and following links.\n              // this skip is used for MMD performance optimization.\n\n              if (links[k].enabled === false) break;\n              const limitation = links[k].limitation;\n              const rotationMin = links[k].rotationMin;\n              const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n              // because they call updateMatrixWorld( true ) inside.\n\n              link.matrixWorld.decompose(linkPos, invLinkQ, linkScale);\n              invLinkQ.invert();\n              effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n              effectorVec.subVectors(effectorPos, linkPos);\n              effectorVec.applyQuaternion(invLinkQ);\n              effectorVec.normalize();\n              targetVec.subVectors(targetPos, linkPos);\n              targetVec.applyQuaternion(invLinkQ);\n              targetVec.normalize();\n              let angle = targetVec.dot(effectorVec);\n\n              if (angle > 1.0) {\n                angle = 1.0;\n              } else if (angle < -1.0) {\n                angle = -1.0;\n              }\n\n              angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n              // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n              if (angle < 1e-5) continue;\n\n              if (ik.minAngle !== undefined && angle < ik.minAngle) {\n                angle = ik.minAngle;\n              }\n\n              if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n                angle = ik.maxAngle;\n              }\n\n              axis.crossVectors(effectorVec, targetVec);\n              axis.normalize();\n              q.setFromAxisAngle(axis, angle);\n              link.quaternion.multiply(q); // TODO: re-consider the limitation specification\n\n              if (limitation !== undefined) {\n                let c = link.quaternion.w;\n                if (c > 1.0) c = 1.0;\n                const c2 = math.sqrt(1 - c * c);\n                link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n              }\n\n              if (rotationMin !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).max(rotationMin));\n              }\n\n              if (rotationMax !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).min(rotationMax));\n              }\n\n              link.updateMatrixWorld(true);\n              rotated = true;\n            }\n\n            if (!rotated) break;\n          }\n        }\n\n        return this;\n      };\n    })(),\n\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n    createHelper: function () {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    },\n    // private methods\n    _valid: function () {\n      const iks = this.iks;\n      const bones = this.mesh.skeleton.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const effector = bones[ik.effector];\n        const links = ik.links;\n        let link0, link1;\n        link0 = effector;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n\n          if (link0.parent !== link1) {\n            console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n          }\n\n          link0 = link1;\n        }\n      }\n    }\n  };\n  /**\n   * Visualize IK bones\n   *\n   * @param {SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n\n  function CCDIKHelper(mesh, iks) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.iks = iks || [];\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    this._init();\n  }\n\n  CCDIKHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: CCDIKHelper,\n\n    /**\n     * Updates IK bones visualization.\n     */\n    updateMatrixWorld: (() => {\n      const matrix = new Matrix4();\n      const vector = new Vector3();\n\n      function getPosition(bone, matrixWorldInv) {\n        return vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n      }\n\n      function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n        const v = getPosition(bone, matrixWorldInv);\n        array[index * 3 + 0] = v.x;\n        array[index * 3 + 1] = v.y;\n        array[index * 3 + 2] = v.z;\n      }\n\n      return function updateMatrixWorld(force) {\n        const mesh = this.root;\n\n        if (this.visible) {\n          let offset = 0;\n          const iks = this.iks;\n          const bones = mesh.skeleton.bones;\n          matrix.copy(mesh.matrixWorld).invert();\n\n          for (let i = 0, il = iks.length; i < il; i++) {\n            const ik = iks[i];\n            const targetBone = bones[ik.target];\n            const effectorBone = bones[ik.effector];\n            const targetMesh = this.children[offset++];\n            const effectorMesh = this.children[offset++];\n            targetMesh.position.copy(getPosition(targetBone, matrix));\n            effectorMesh.position.copy(getPosition(effectorBone, matrix));\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              const linkMesh = this.children[offset++];\n              linkMesh.position.copy(getPosition(linkBone, matrix));\n            }\n\n            const line = this.children[offset++];\n            const array = line.geometry.attributes.position.array;\n            setPositionOfBoneToAttributeArray(array, 0, targetBone, matrix);\n            setPositionOfBoneToAttributeArray(array, 1, effectorBone, matrix);\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              setPositionOfBoneToAttributeArray(array, j + 2, linkBone, matrix);\n            }\n\n            line.geometry.attributes.position.needsUpdate = true;\n          }\n        }\n\n        this.matrix.copy(mesh.matrixWorld);\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    })(),\n    // private method\n    _init: function () {\n      const scope = this;\n      const iks = this.iks;\n\n      function createLineGeometry(ik) {\n        const geometry = new BufferGeometry();\n        const vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n\n        this.add(createLine(ik));\n      }\n    }\n  });\n  return CCDIKSolver;\n})();\n\nexport { CCDIKSolver };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}