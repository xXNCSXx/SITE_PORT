{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from 'three';\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nvar MTLLoader = function (manager) {\n  Loader.call(this, manager);\n};\nMTLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: MTLLoader,\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setMaterialOptions: function (value) {\n    this.materialOptions = value;\n    return this;\n  },\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MTLLoader.MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse: function (text, path) {\n    var lines = text.split('\\n');\n    var info = {};\n    var delimiter_pattern = /\\s+/;\n    var materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n      var pos = line.indexOf(' ');\n      var key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      var value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n      if (key === 'newmtl') {\n        // New material\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          var ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    var materialCreator = new MTLLoader.MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n});\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function (baseUrl, options) {\n  this.baseUrl = baseUrl || '';\n  this.options = options;\n  this.materialsInfo = {};\n  this.materials = {};\n  this.materialsArray = [];\n  this.nameLookup = {};\n  this.side = this.options && this.options.side ? this.options.side : FrontSide;\n  this.wrap = this.options && this.options.wrap ? this.options.wrap : RepeatWrapping;\n};\nMTLLoader.MaterialCreator.prototype = {\n  constructor: MTLLoader.MaterialCreator,\n  crossOrigin: 'anonymous',\n  setCrossOrigin: function (value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  setManager: function (value) {\n    this.manager = value;\n  },\n  setMaterials: function (materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  },\n  convert: function (materialsInfo) {\n    if (!this.options) return materialsInfo;\n    var converted = {};\n    for (let mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n      var mat = materialsInfo[mn];\n      var covmat = {};\n      converted[mn] = covmat;\n      for (let prop in mat) {\n        var save = true;\n        var value = mat[prop];\n        var lprop = prop.toLowerCase();\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n                save = false;\n              }\n            }\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  },\n  preload: function () {\n    for (let mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  },\n  getIndex: function (materialName) {\n    return this.nameLookup[materialName];\n  },\n  getAsArray: function () {\n    var index = 0;\n    for (let mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  },\n  create: function (materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  },\n  createMaterial_: function (materialName) {\n    // Create material\n    var scope = this;\n    var mat = this.materialsInfo[materialName];\n    var params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      var texParams = scope.getTextureParams(value, params);\n      var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (let prop in mat) {\n      var value = mat[prop];\n      var n;\n      if (value === '') continue;\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n          params.color = new Color().fromArray(value);\n          break;\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value);\n          break;\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value);\n          break;\n        case 'map_kd':\n          // Diffuse texture map\n          setMapForType('map', value);\n          break;\n        case 'map_ks':\n          // Specular map\n          setMapForType('specularMap', value);\n          break;\n        case 'map_ke':\n          // Emissive map\n          setMapForType('emissiveMap', value);\n          break;\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n          setMapForType('bumpMap', value);\n          break;\n        case 'map_d':\n          // Alpha map\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n          params.shininess = parseFloat(value);\n          break;\n        case 'd':\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  },\n  getTextureParams: function (value, matParams) {\n    var texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    var items = value.split(/\\s+/);\n    var pos;\n    pos = items.indexOf('-bm');\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf('-s');\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n    pos = items.indexOf('-o');\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  },\n  loadTexture: function (url, mapping, onLoad, onProgress, onError) {\n    var texture;\n    var manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    var loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n};\nexport { MTLLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","FrontSide","RepeatWrapping","Color","MeshPhongMaterial","Vector2","DefaultLoadingManager","TextureLoader","MTLLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","getIndex","materialName","getAsArray","index","undefined","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","set","join","mapping","texture","getHandler"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/MTLLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from 'three';\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nvar MTLLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nMTLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: MTLLoader,\n\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setMaterialOptions: function (value) {\n    this.materialOptions = value;\n    return this;\n  },\n\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MTLLoader.MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse: function (text, path) {\n    var lines = text.split('\\n');\n    var info = {};\n    var delimiter_pattern = /\\s+/;\n    var materialsInfo = {};\n\n    for (let i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      line = line.trim();\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n\n      var pos = line.indexOf(' ');\n      var key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      var value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n\n      if (key === 'newmtl') {\n        // New material\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          var ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n\n    var materialCreator = new MTLLoader.MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n});\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function (baseUrl, options) {\n  this.baseUrl = baseUrl || '';\n  this.options = options;\n  this.materialsInfo = {};\n  this.materials = {};\n  this.materialsArray = [];\n  this.nameLookup = {};\n  this.side = this.options && this.options.side ? this.options.side : FrontSide;\n  this.wrap = this.options && this.options.wrap ? this.options.wrap : RepeatWrapping;\n};\n\nMTLLoader.MaterialCreator.prototype = {\n  constructor: MTLLoader.MaterialCreator,\n  crossOrigin: 'anonymous',\n  setCrossOrigin: function (value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  setManager: function (value) {\n    this.manager = value;\n  },\n  setMaterials: function (materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  },\n  convert: function (materialsInfo) {\n    if (!this.options) return materialsInfo;\n    var converted = {};\n\n    for (let mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n      var mat = materialsInfo[mn];\n      var covmat = {};\n      converted[mn] = covmat;\n\n      for (let prop in mat) {\n        var save = true;\n        var value = mat[prop];\n        var lprop = prop.toLowerCase();\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n                save = false;\n              }\n            }\n\n            break;\n        }\n\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n\n    return converted;\n  },\n  preload: function () {\n    for (let mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  },\n  getIndex: function (materialName) {\n    return this.nameLookup[materialName];\n  },\n  getAsArray: function () {\n    var index = 0;\n\n    for (let mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n\n    return this.materialsArray;\n  },\n  create: function (materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n\n    return this.materials[materialName];\n  },\n  createMaterial_: function (materialName) {\n    // Create material\n    var scope = this;\n    var mat = this.materialsInfo[materialName];\n    var params = {\n      name: materialName,\n      side: this.side\n    };\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      var texParams = scope.getTextureParams(value, params);\n      var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n\n    for (let prop in mat) {\n      var value = mat[prop];\n      var n;\n      if (value === '') continue;\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n          params.color = new Color().fromArray(value);\n          break;\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value);\n          break;\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value);\n          break;\n\n        case 'map_kd':\n          // Diffuse texture map\n          setMapForType('map', value);\n          break;\n\n        case 'map_ks':\n          // Specular map\n          setMapForType('specularMap', value);\n          break;\n\n        case 'map_ke':\n          // Emissive map\n          setMapForType('emissiveMap', value);\n          break;\n\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n          setMapForType('bumpMap', value);\n          break;\n\n        case 'map_d':\n          // Alpha map\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n          params.shininess = parseFloat(value);\n          break;\n\n        case 'd':\n          n = parseFloat(value);\n\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n\n          break;\n\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n\n          break;\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  },\n  getTextureParams: function (value, matParams) {\n    var texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    var items = value.split(/\\s+/);\n    var pos;\n    pos = items.indexOf('-bm');\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n\n    pos = items.indexOf('-s');\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o');\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  },\n  loadTexture: function (url, mapping, onLoad, onProgress, onError) {\n    var texture;\n    var manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    var loader = manager.getHandler(url);\n\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n};\n\nexport { MTLLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}