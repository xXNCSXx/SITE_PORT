{"ast":null,"code":"import { Vector3 } from 'three';\n\n/**\n * Usage:\n *  var exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  var data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nconst STLExporter = () => {};\nSTLExporter.prototype = {\n  constructor: STLExporter,\n  parse: function (scene, options) {\n    if (options === undefined) options = {};\n    const binary = options.binary !== undefined ? options.binary : false; //\n\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute('position');\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80; // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = '';\n      output += 'solid exported\\n';\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute('position');\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          var a = index.getX(j + 0);\n          var b = index.getX(j + 1);\n          var c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          var a = j + 0;\n          var b = j + 1;\n          var c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (binary === false) {\n      output += 'endsolid exported\\n';\n    }\n    return output;\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh === true) {\n        object.boneTransform(a, vA);\n        object.boneTransform(b, vB);\n        object.boneTransform(c, vC);\n      }\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += '\\t\\tendloop\\n';\n        output += '\\tendfacet\\n';\n      }\n    }\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += `\\tfacet normal ${normal.x} ${normal.y} ${normal.z}\\n`;\n        output += '\\t\\touter loop\\n';\n      }\n    }\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n      }\n    }\n  }\n};\nexport { STLExporter };","map":{"version":3,"names":["Vector3","STLExporter","prototype","constructor","parse","scene","options","undefined","binary","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","output","offset","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","vB","vC","cb","ab","normal","i","il","length","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/STLExporter.js"],"sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * Usage:\n *  var exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  var data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nconst STLExporter = () => {};\n\nSTLExporter.prototype = {\n  constructor: STLExporter,\n  parse: function (scene, options) {\n    if (options === undefined) options = {};\n    const binary = options.binary !== undefined ? options.binary : false; //\n\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute('position');\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80; // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = '';\n      output += 'solid exported\\n';\n    }\n\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute('position');\n\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          var a = index.getX(j + 0);\n          var b = index.getX(j + 1);\n          var c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          var a = j + 0;\n          var b = j + 1;\n          var c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n\n    if (binary === false) {\n      output += 'endsolid exported\\n';\n    }\n\n    return output;\n\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n\n      if (object.isSkinnedMesh === true) {\n        object.boneTransform(a, vA);\n        object.boneTransform(b, vB);\n        object.boneTransform(c, vC);\n      }\n\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += '\\t\\tendloop\\n';\n        output += '\\tendfacet\\n';\n      }\n    }\n\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += `\\tfacet normal ${normal.x} ${normal.y} ${normal.z}\\n`;\n        output += '\\t\\touter loop\\n';\n      }\n    }\n\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n      }\n    }\n  }\n};\n\nexport { STLExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}