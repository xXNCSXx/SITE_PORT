{"ast":null,"code":"import { GammaEncoding, RGBDEncoding, RGBM16Encoding, RGBM7Encoding, RGBEEncoding, sRGBEncoding, LinearEncoding } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nfunction ColorSpaceNode(input, method) {\n  TempNode.call(this, 'v4');\n  this.input = input;\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\n}\nColorSpaceNode.Nodes = function () {\n  // For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n  var LinearToLinear = new FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\treturn value;', '}'].join('\\n'));\n  var GammaToLinear = new FunctionNode(['vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var LinearToGamma = new FunctionNode(['vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var sRGBToLinear = new FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\n'));\n  var LinearTosRGB = new FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\n'));\n  var RGBEToLinear = new FunctionNode(['vec4 RGBEToLinear( in vec4 value ) {', '\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBE = new FunctionNode(['vec4 LinearToRGBE( in vec4 value ) {', '\tfloat maxComponent = max( max( value.r, value.g ), value.b );', '\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );', '\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );',\n  //  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n  '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBMToLinear = new FunctionNode(['vec3 RGBMToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.xyz * value.w * maxRange, 1.0 );', '}'].join('\\n'));\n  var LinearToRGBM = new FunctionNode(['vec3 LinearToRGBM( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );', '\tM            = ceil( M * 255.0 ) / 255.0;', '\treturn vec4( value.rgb / ( M * maxRange ), M );', '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBDToLinear = new FunctionNode(['vec3 RGBDToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBD = new FunctionNode(['vec3 LinearToRGBD( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat D      = max( maxRange / maxRGB, 1.0 );', '\tD            = clamp( floor( D ) / 255.0, 0.0, 1.0 );', '\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );', '}'].join('\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n  // M matrix, for encoding\n\n  var cLogLuvM = new ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\n  var LinearToLogLuv = new FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\tvec4 vResult;', '\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\tvResult.w = fract(Le);', '\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\treturn vResult;', '}'].join('\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\n\n  var cLogLuvInverseM = new ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\n  var LogLuvToLinear = new FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\tfloat Le = value.z * 255.0 + value.w;', '\tvec3 Xp_Y_XYZp;', '\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\n'), [cLogLuvInverseM]);\n  return {\n    LinearToLinear: LinearToLinear,\n    GammaToLinear: GammaToLinear,\n    LinearToGamma: LinearToGamma,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    RGBEToLinear: RGBEToLinear,\n    LinearToRGBE: LinearToRGBE,\n    RGBMToLinear: RGBMToLinear,\n    LinearToRGBM: LinearToRGBM,\n    RGBDToLinear: RGBDToLinear,\n    LinearToRGBD: LinearToRGBD,\n    cLogLuvM: cLogLuvM,\n    LinearToLogLuv: LinearToLogLuv,\n    cLogLuvInverseM: cLogLuvInverseM,\n    LogLuvToLinear: LogLuvToLinear\n  };\n}();\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';\nColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\nColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';\nColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';\nColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';\nColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\nColorSpaceNode.getEncodingComponents = function (encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear'];\n    case sRGBEncoding:\n      return ['sRGB'];\n    case RGBEEncoding:\n      return ['RGBE'];\n    case RGBM7Encoding:\n      return ['RGBM', new FloatNode(7.0).setReadonly(true)];\n    case RGBM16Encoding:\n      return ['RGBM', new FloatNode(16.0).setReadonly(true)];\n    case RGBDEncoding:\n      return ['RGBD', new FloatNode(256.0).setReadonly(true)];\n    case GammaEncoding:\n      return ['Gamma', new ExpressionNode('float( GAMMA_FACTOR )', 'f')];\n  }\n};\nColorSpaceNode.prototype = Object.create(TempNode.prototype);\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\nColorSpaceNode.prototype.hashProperties = ['method'];\nColorSpaceNode.prototype.generate = function (builder, output) {\n  var input = this.input.build(builder, 'v4');\n  var outputType = this.getType(builder);\n  var methodNode = ColorSpaceNode.Nodes[this.method];\n  var method = builder.include(methodNode);\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\n    return builder.format(input, outputType, output);\n  } else {\n    if (methodNode.inputs.length === 2) {\n      var factor = this.factor.build(builder, 'f');\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\n    } else {\n      return builder.format(method + '( ' + input + ' )', outputType, output);\n    }\n  }\n};\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = 'LinearTo' + components[0];\n  this.factor = components[1];\n};\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = components[0] + 'ToLinear';\n  this.factor = components[1];\n};\nColorSpaceNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.input = source.input;\n  this.method = source.method;\n  return this;\n};\nColorSpaceNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.input = this.input.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n  return data;\n};\nexport { ColorSpaceNode };","map":{"version":3,"names":["GammaEncoding","RGBDEncoding","RGBM16Encoding","RGBM7Encoding","RGBEEncoding","sRGBEncoding","LinearEncoding","TempNode","ConstNode","FloatNode","FunctionNode","ExpressionNode","ColorSpaceNode","input","method","call","LINEAR_TO_LINEAR","Nodes","LinearToLinear","join","GammaToLinear","LinearToGamma","sRGBToLinear","LinearTosRGB","RGBEToLinear","LinearToRGBE","RGBMToLinear","LinearToRGBM","RGBDToLinear","LinearToRGBD","cLogLuvM","LinearToLogLuv","cLogLuvInverseM","LogLuvToLinear","GAMMA_TO_LINEAR","LINEAR_TO_GAMMA","SRGB_TO_LINEAR","LINEAR_TO_SRGB","RGBE_TO_LINEAR","LINEAR_TO_RGBE","RGBM_TO_LINEAR","LINEAR_TO_RGBM","RGBD_TO_LINEAR","LINEAR_TO_RGBD","LINEAR_TO_LOG_LUV","LOG_LUV_TO_LINEAR","getEncodingComponents","encoding","setReadonly","prototype","Object","create","constructor","nodeType","hashProperties","generate","builder","output","build","outputType","getType","methodNode","include","format","inputs","length","factor","fromEncoding","components","fromDecoding","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/utils/ColorSpaceNode.js"],"sourcesContent":["import { GammaEncoding, RGBDEncoding, RGBM16Encoding, RGBM7Encoding, RGBEEncoding, sRGBEncoding, LinearEncoding } from 'three';\nimport { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction ColorSpaceNode(input, method) {\n  TempNode.call(this, 'v4');\n  this.input = input;\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\n}\n\nColorSpaceNode.Nodes = function () {\n  // For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n  var LinearToLinear = new FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\treturn value;', '}'].join('\\n'));\n  var GammaToLinear = new FunctionNode(['vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var LinearToGamma = new FunctionNode(['vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var sRGBToLinear = new FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\n'));\n  var LinearTosRGB = new FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\n'));\n  var RGBEToLinear = new FunctionNode(['vec4 RGBEToLinear( in vec4 value ) {', '\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBE = new FunctionNode(['vec4 LinearToRGBE( in vec4 value ) {', '\tfloat maxComponent = max( max( value.r, value.g ), value.b );', '\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );', '\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );', //  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n  '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBMToLinear = new FunctionNode(['vec3 RGBMToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.xyz * value.w * maxRange, 1.0 );', '}'].join('\\n'));\n  var LinearToRGBM = new FunctionNode(['vec3 LinearToRGBM( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );', '\tM            = ceil( M * 255.0 ) / 255.0;', '\treturn vec4( value.rgb / ( M * maxRange ), M );', '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBDToLinear = new FunctionNode(['vec3 RGBDToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBD = new FunctionNode(['vec3 LinearToRGBD( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat D      = max( maxRange / maxRGB, 1.0 );', '\tD            = clamp( floor( D ) / 255.0, 0.0, 1.0 );', '\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );', '}'].join('\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n  // M matrix, for encoding\n\n  var cLogLuvM = new ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\n  var LinearToLogLuv = new FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\tvec4 vResult;', '\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\tvResult.w = fract(Le);', '\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\treturn vResult;', '}'].join('\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\n\n  var cLogLuvInverseM = new ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\n  var LogLuvToLinear = new FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\tfloat Le = value.z * 255.0 + value.w;', '\tvec3 Xp_Y_XYZp;', '\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\n'), [cLogLuvInverseM]);\n  return {\n    LinearToLinear: LinearToLinear,\n    GammaToLinear: GammaToLinear,\n    LinearToGamma: LinearToGamma,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    RGBEToLinear: RGBEToLinear,\n    LinearToRGBE: LinearToRGBE,\n    RGBMToLinear: RGBMToLinear,\n    LinearToRGBM: LinearToRGBM,\n    RGBDToLinear: RGBDToLinear,\n    LinearToRGBD: LinearToRGBD,\n    cLogLuvM: cLogLuvM,\n    LinearToLogLuv: LinearToLogLuv,\n    cLogLuvInverseM: cLogLuvInverseM,\n    LogLuvToLinear: LogLuvToLinear\n  };\n}();\n\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';\nColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\nColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';\nColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';\nColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';\nColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\n\nColorSpaceNode.getEncodingComponents = function (encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear'];\n\n    case sRGBEncoding:\n      return ['sRGB'];\n\n    case RGBEEncoding:\n      return ['RGBE'];\n\n    case RGBM7Encoding:\n      return ['RGBM', new FloatNode(7.0).setReadonly(true)];\n\n    case RGBM16Encoding:\n      return ['RGBM', new FloatNode(16.0).setReadonly(true)];\n\n    case RGBDEncoding:\n      return ['RGBD', new FloatNode(256.0).setReadonly(true)];\n\n    case GammaEncoding:\n      return ['Gamma', new ExpressionNode('float( GAMMA_FACTOR )', 'f')];\n  }\n};\n\nColorSpaceNode.prototype = Object.create(TempNode.prototype);\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\nColorSpaceNode.prototype.hashProperties = ['method'];\n\nColorSpaceNode.prototype.generate = function (builder, output) {\n  var input = this.input.build(builder, 'v4');\n  var outputType = this.getType(builder);\n  var methodNode = ColorSpaceNode.Nodes[this.method];\n  var method = builder.include(methodNode);\n\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\n    return builder.format(input, outputType, output);\n  } else {\n    if (methodNode.inputs.length === 2) {\n      var factor = this.factor.build(builder, 'f');\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\n    } else {\n      return builder.format(method + '( ' + input + ' )', outputType, output);\n    }\n  }\n};\n\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = 'LinearTo' + components[0];\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = components[0] + 'ToLinear';\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.input = source.input;\n  this.method = source.method;\n  return this;\n};\n\nColorSpaceNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.input = this.input.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n\n  return data;\n};\n\nexport { ColorSpaceNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}