{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\nvar ColladaLoader = function (manager) {\n  Loader.call(this, manager);\n};\nColladaLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: ColladaLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n  },\n  parse: function (text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text) {\n      return text.substring(1);\n    }\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (let name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      var hasChildren = false;\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n      for (let target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (let time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    var position = new Vector3();\n    var scale = new Vector3();\n    var quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n      library.clips[xml.getAttribute('id')] = data;\n    }\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n      for (let i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n    function parseController(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      var data = library.images[id];\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n    function parseEffect(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml.getAttribute('id')] = data;\n    }\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n      library.materials[xml.getAttribute('id')] = data;\n    }\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || '';\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      var parameters = technique.parameters;\n      for (let key in parameters) {\n        var parameter = parameters[key];\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = DoubleSide;\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml) {\n      var data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml) {\n      var data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      var camera;\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n          // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || '';\n      return camera;\n    }\n    function getCamera(id) {\n      var data = library.cameras[id];\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n    function parseLight(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml.getAttribute('id')] = data;\n    }\n    function parseLightTechnique(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml) {\n      var data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      var light;\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n        case 'point':\n          light = new PointLight();\n          break;\n        case 'spot':\n          light = new SpotLight();\n          break;\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      var data = library.lights[id];\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml) {\n      var data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      var build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n      for (let type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n        for (let name in inputs) {\n          var input = inputs[name];\n          switch (name) {\n            case 'VERTEX':\n              for (let key in vertices) {\n                var id = vertices[key];\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n      if (position.array.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml) {\n      var data;\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    } // physics\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          // get the parent of the transform element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      var m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          var jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n          if (jointData) {\n            var joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                var transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            var angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    } // nodes\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        var element = elements[i];\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n    var matrix = new Matrix4();\n    var vector = new Vector3();\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'extra':\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n            for (let j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n          for (let j = 0; j < children.length; j++) {\n            var child = children[j];\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n      var bones = [];\n      var boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n          objects.push(object);\n        }\n      } // instance lights\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      var object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    var fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n      for (let type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n        if (skinning) {\n          for (let i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n    function buildVisualScene(data) {\n      var group = new Group();\n      group.name = data.name;\n      var children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n    function setupAnimations() {\n      var clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n          for (let id in library.animations) {\n            var animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (let id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n    function parserErrorToText(parserError) {\n      var result = '';\n      var stack = [parserError];\n      while (stack.length) {\n        var node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0];\n    var parserError = xml.getElementsByTagName('parsererror')[0];\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      var errorElement = getElementsByTagName(parserError, 'div')[0];\n      var errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n});\nexport { ColladaLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Vector3","Quaternion","Matrix4","MeshBasicMaterial","Scene","TextureLoader","Euler","MathUtils","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","MeshLambertMaterial","MeshPhongMaterial","DoubleSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","RepeatWrapping","ClampToEdgeWrapping","TGALoader","ColladaLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","options","convertUpAxis","value","warn","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/ColladaLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nvar ColladaLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nColladaLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: ColladaLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n\n  },\n  parse: function (text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (let name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      var hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for (let target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (let time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    var position = new Vector3();\n    var scale = new Vector3();\n    var quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      var data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      var parameters = technique.parameters;\n\n      for (let key in parameters) {\n        var parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      var camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      var data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      var data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      var light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      var data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      var data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      var build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n\n      for (let type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (let name in inputs) {\n          var input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (let key in vertices) {\n                var id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      var data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      var m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            var joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                var transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new Vector3().fromArray(array);\n            var angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        var element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    var matrix = new Matrix4();\n    var vector = new Vector3();\n\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            var child = children[j];\n\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      var bones = [];\n      var boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      var object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    var fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n\n      for (let type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (let i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      var group = new Group();\n      group.name = data.name;\n      var children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      var clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n\n          for (let id in library.animations) {\n            var animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (let id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      var result = '';\n      var stack = [parserError];\n\n      while (stack.length) {\n        var node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0];\n    var parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      var errorElement = getElementsByTagName(parserError, 'div')[0];\n      var errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n});\n\nexport { ColladaLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}