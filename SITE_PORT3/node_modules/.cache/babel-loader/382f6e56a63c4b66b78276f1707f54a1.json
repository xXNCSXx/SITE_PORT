{"ast":null,"code":"// src/Animated.ts\nimport { defineHidden } from \"@react-spring/shared\";\nvar $node = Symbol.for(\"Animated:node\");\nvar isAnimated = value => !!value && value[$node] === value;\nvar getAnimated = owner => owner && owner[$node];\nvar setAnimated = (owner, node) => defineHidden(owner, $node, node);\nvar getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nvar Animated = class {\n  constructor() {\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload() {\n    return this.payload || [];\n  }\n};\n\n// src/AnimatedValue.ts\nimport { is } from \"@react-spring/shared\";\nvar AnimatedValue = class extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.durationProgress = 0;\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  /** @internal */\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n  getPayload() {\n    return [this];\n  }\n  getValue() {\n    return this._value;\n  }\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n      if (step) {\n        value = Math.round(value / step) * step;\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n    if (this._value === value) {\n      return false;\n    }\n    this._value = value;\n    return true;\n  }\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n};\n\n// src/AnimatedString.ts\nimport { is as is2, createInterpolator } from \"@react-spring/shared\";\nvar AnimatedString = class extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n  /** @internal */\n  static create(value) {\n    return new AnimatedString(value);\n  }\n  getValue() {\n    const value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n  setValue(value) {\n    if (is2.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n    return true;\n  }\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n    this._value = 0;\n    super.reset();\n  }\n};\n\n// src/AnimatedArray.ts\nimport { isAnimatedString } from \"@react-spring/shared\";\n\n// src/AnimatedObject.ts\nimport { each, eachProp, getFluidValue, hasFluidValue } from \"@react-spring/shared\";\n\n// src/context.ts\nvar TreeContext = {\n  dependencies: null\n};\n\n// src/AnimatedObject.ts\nvar AnimatedObject = class extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n  _makePayload(source) {\n    if (source) {\n      const payload = /* @__PURE__ */new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n    const payload = getPayload(source);\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n};\n\n// src/AnimatedArray.ts\nvar AnimatedArray = class extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n  /** @internal */\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n  setValue(source) {\n    const payload = this.getPayload();\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n};\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\n// src/getAnimatedType.ts\nimport { is as is3, isAnimatedString as isAnimatedString2 } from \"@react-spring/shared\";\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is3.arr(value) ? AnimatedArray : isAnimatedString2(value) ? AnimatedString : AnimatedValue;\n}\n\n// src/createHost.ts\nimport { is as is5, eachProp as eachProp2 } from \"@react-spring/shared\";\n\n// src/withAnimated.tsx\nimport * as React from \"react\";\nimport { forwardRef, useRef, useCallback, useEffect } from \"react\";\nimport { is as is4, each as each2, raf, useForceUpdate, useOnce, addFluidObserver, removeFluidObserver, useIsomorphicLayoutEffect } from \"@react-spring/shared\";\nvar withAnimated = (Component, host) => {\n  const hasInstance =\n  // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is4.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance &&\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n    const callback = () => {\n      const instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer;\n      each2(deps, dep => addFluidObserver(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          each2(observerRef.current.deps, dep => removeFluidObserver(dep, observerRef.current));\n          raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each2(observer2.deps, dep => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */React.createElement(Component, {\n      ...usedProps,\n      ref\n    });\n  });\n};\nvar PropsObserver = class {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n};\nfunction getAnimatedState(props, host) {\n  const dependencies = /* @__PURE__ */new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = {\n    ...props,\n    style: host.createAnimatedStyle(props.style)\n  };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is4.fun(ref)) ref(value);else ref.current = value;\n  }\n  return value;\n}\n\n// src/createHost.ts\nvar cacheKey = Symbol.for(\"AnimatedComponent\");\nvar createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n    if (is5.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n  eachProp2(components, (Component, key) => {\n    if (is5.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\nvar getDisplayName = arg => is5.str(arg) ? arg : arg && is5.str(arg.displayName) ? arg.displayName : is5.fun(arg) && arg.name || null;\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["../src/Animated.ts","../src/AnimatedValue.ts","../src/AnimatedString.ts","../src/AnimatedArray.ts","../src/AnimatedObject.ts","../src/context.ts","../src/getAnimatedType.ts","../src/createHost.ts","../src/withAnimated.tsx"],"names":["is","isAnimatedString","observer"],"mappings":";AAAA,SAAS,YAAA,QAAoB,sBAAA;AAG7B,IAAM,KAAA,GAAa,MAAA,CAAO,GAAA,CAAI,eAAe,CAAA;AAEtC,IAAM,UAAA,GAAuB,KAAA,IAClC,CAAC,CAAC,KAAA,IAAS,KAAA,CAAM,KAAK,CAAA,KAAM,KAAA;AAGvB,IAAM,WAAA,GAAwB,KAAA,IACnC,KAAA,IAAS,KAAA,CAAM,KAAK,CAAA;AAGf,IAAM,WAAA,GAAc,CAAC,KAAA,EAAY,IAAA,KACtC,YAAA,CAAa,KAAA,EAAO,KAAA,EAAO,IAAI,CAAA;AAG1B,IAAM,UAAA,GAAc,KAAA,IACzB,KAAA,IAAS,KAAA,CAAM,KAAK,CAAA,IAAK,KAAA,CAAM,KAAK,CAAA,CAAE,UAAA,CAAW,CAAA;AAE5C,IAAe,QAAA,GAAf,MAAiC;EAItC,WAAA,CAAA,EAAc;IAEZ,WAAA,CAAY,IAAA,EAAM,IAAI,CAAA;EACxB;EAAA;EAYA,UAAA,CAAA,EAAsB;IACpB,OAAO,IAAA,CAAK,OAAA,IAAW,EAAC;EAC1B;AACF,CAAA;;;AC1CA,SAAS,EAAA,QAAU,sBAAA;AAIZ,IAAM,aAAA,GAAN,cAAqC,QAAA,CAAS;EAQnD,WAAA,CAAsB,MAAA,EAAW;IAC/B,KAAA,CAAM,CAAA;IADc,IAAA,CAAA,MAAA,GAAA,MAAA;IAPtB,IAAA,CAAA,IAAA,GAAO,IAAA;IAKP,IAAA,CAAA,gBAAA,GAAmB,CAAA;IAIjB,IAAI,EAAA,CAAG,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;MACvB,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,MAAA;IAC3B;EACF;EAAA;EAGA,OAAO,MAAA,CAAO,KAAA,EAAY;IACxB,OAAO,IAAI,aAAA,CAAc,KAAK,CAAA;EAChC;EAEA,UAAA,CAAA,EAAsB;IACpB,OAAO,CAAC,IAAI,CAAA;EACd;EAEA,QAAA,CAAA,EAAW;IACT,OAAO,IAAA,CAAK,MAAA;EACd;EAEA,QAAA,CAAS,KAAA,EAAU,IAAA,EAAe;IAChC,IAAI,EAAA,CAAG,GAAA,CAAI,KAAK,CAAA,EAAG;MACjB,IAAA,CAAK,YAAA,GAAe,KAAA;MACpB,IAAI,IAAA,EAAM;QACR,KAAA,GAAS,IAAA,CAAK,KAAA,CAAM,KAAA,GAAQ,IAAI,CAAA,GAAI,IAAA;QACpC,IAAI,IAAA,CAAK,IAAA,EAAM;UACb,IAAA,CAAK,YAAA,GAAe,KAAA;QACtB;MACF;IACF;IACA,IAAI,IAAA,CAAK,MAAA,KAAW,KAAA,EAAO;MACzB,OAAO,KAAA;IACT;IACA,IAAA,CAAK,MAAA,GAAS,KAAA;IACd,OAAO,IAAA;EACT;EAEA,KAAA,CAAA,EAAQ;IACN,MAAM;MAAE;IAAK,CAAA,GAAI,IAAA;IACjB,IAAA,CAAK,IAAA,GAAO,KAAA;IACZ,IAAI,EAAA,CAAG,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,EAAG;MACvB,IAAA,CAAK,WAAA,GAAc,CAAA;MACnB,IAAA,CAAK,gBAAA,GAAmB,CAAA;MACxB,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,MAAA;MACzB,IAAI,IAAA,EAAM,IAAA,CAAK,YAAA,GAAe,IAAA;MAC9B,IAAA,CAAK,EAAA,GAAK,IAAA;IACZ;EACF;AACF,CAAA;;;AC3DA,SAAS,EAAA,IAAA,GAAA,EAAI,kBAAA,QAA0B,sBAAA;AAIhC,IAAM,cAAA,GAAN,cAA6B,aAAA,CAAqB;EAKvD,WAAA,CAAY,KAAA,EAAe;IACzB,KAAA,CAAM,CAAC,CAAA;IAJT,IAAA,CAAU,OAAA,GAAyB,IAAA;IAKjC,IAAA,CAAK,SAAA,GAAY,kBAAA,CAAmB;MAClC,MAAA,EAAQ,CAAC,KAAA,EAAO,KAAK;IACvB,CAAC,CAAA;EACH;EAAA;EAGA,OAAO,MAAA,CAAO,KAAA,EAAe;IAC3B,OAAO,IAAI,cAAA,CAAe,KAAK,CAAA;EACjC;EAEA,QAAA,CAAA,EAAW;IACT,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA;IACnB,OAAO,KAAA,IAAS,IAAA,GAAQ,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAM,CAAA,GAAK,KAAA;EACxE;EAEA,QAAA,CAAS,KAAA,EAAc;IACrB,IAAIA,GAAAA,CAAG,GAAA,CAAI,KAAK,CAAA,EAAG;MACjB,IAAI,KAAA,IAAS,IAAA,CAAK,OAAA,EAAS;QACzB,OAAO,KAAA;MACT;MACA,IAAA,CAAK,OAAA,GAAU,KAAA;MACf,IAAA,CAAK,MAAA,GAAS,CAAA;IAChB,CAAA,MAAA,IAAW,KAAA,CAAM,QAAA,CAAS,KAAK,CAAA,EAAG;MAChC,IAAA,CAAK,OAAA,GAAU,IAAA;IACjB,CAAA,MAAO;MACL,OAAO,KAAA;IACT;IACA,OAAO,IAAA;EACT;EAEA,KAAA,CAAM,IAAA,EAAe;IACnB,IAAI,IAAA,EAAM;MACR,IAAA,CAAK,SAAA,GAAY,kBAAA,CAAmB;QAClC,MAAA,EAAQ,CAAC,IAAA,CAAK,QAAA,CAAS,CAAA,EAAG,IAAI;MAChC,CAAC,CAAA;IACH;IACA,IAAA,CAAK,MAAA,GAAS,CAAA;IACd,KAAA,CAAM,KAAA,CAAM,CAAA;EACd;AACF,CAAA;;;ACnDA,SAAS,gBAAA,QAAwB,sBAAA;;;ACCjC,SACE,IAAA,EACA,QAAA,EACA,aAAA,EACA,aAAA,QACK,sBAAA;;;ACIA,IAAM,WAAA,GAA2B;EAAE,YAAA,EAAc;AAAK,CAAA;;;ADEtD,IAAM,cAAA,GAAN,cAA6B,QAAA,CAAS;EAC3C,WAAA,CAAsB,MAAA,EAAgB;IACpC,KAAA,CAAM,CAAA;IADc,IAAA,CAAA,MAAA,GAAA,MAAA;IAEpB,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA;EACtB;EAEA,QAAA,CAAS,QAAA,EAAoB;IAC3B,MAAM,MAAA,GAAiB,CAAC,CAAA;IACxB,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,CAAC,MAAA,EAAQ,GAAA,KAAQ;MACrC,IAAI,UAAA,CAAW,MAAM,CAAA,EAAG;QACtB,MAAA,CAAO,GAAG,CAAA,GAAI,MAAA,CAAO,QAAA,CAAS,QAAQ,CAAA;MACxC,CAAA,MAAA,IAAW,aAAA,CAAc,MAAM,CAAA,EAAG;QAChC,MAAA,CAAO,GAAG,CAAA,GAAI,aAAA,CAAc,MAAM,CAAA;MACpC,CAAA,MAAA,IAAW,CAAC,QAAA,EAAU;QACpB,MAAA,CAAO,GAAG,CAAA,GAAI,MAAA;MAChB;IACF,CAAC,CAAA;IACD,OAAO,MAAA;EACT;EAAA;EAGA,QAAA,CAAS,MAAA,EAAgB;IACvB,IAAA,CAAK,MAAA,GAAS,MAAA;IACd,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,MAAM,CAAA;EACzC;EAEA,KAAA,CAAA,EAAQ;IACN,IAAI,IAAA,CAAK,OAAA,EAAS;MAChB,IAAA,CAAK,IAAA,CAAK,OAAA,EAAS,IAAA,IAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;IACzC;EACF;EAAA;EAGU,YAAA,CAAa,MAAA,EAAgB;IACrC,IAAI,MAAA,EAAQ;MACV,MAAM,OAAA,GAAU,eAAA,IAAI,GAAA,CAAmB,CAAA;MACvC,QAAA,CAAS,MAAA,EAAQ,IAAA,CAAK,aAAA,EAAe,OAAO,CAAA;MAC5C,OAAO,KAAA,CAAM,IAAA,CAAK,OAAO,CAAA;IAC3B;EACF;EAAA;EAGU,aAAA,CAAwC,MAAA,EAAa;IAC7D,IAAI,WAAA,CAAY,YAAA,IAAgB,aAAA,CAAc,MAAM,CAAA,EAAG;MACrD,WAAA,CAAY,YAAA,CAAa,GAAA,CAAI,MAAM,CAAA;IACrC;IACA,MAAM,OAAA,GAAU,UAAA,CAAW,MAAM,CAAA;IACjC,IAAI,OAAA,EAAS;MACX,IAAA,CAAK,OAAA,EAAS,IAAA,IAAQ,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA;IACtC;EACF;AACF,CAAA;;;ADtDO,IAAM,aAAA,GAAN,cAEG,cAAA,CAAe;EAEvB,WAAA,CAAY,MAAA,EAAW;IACrB,KAAA,CAAM,MAAM,CAAA;EACd;EAAA;EAGA,OAAO,MAAA,CAAuC,MAAA,EAAW;IACvD,OAAO,IAAI,aAAA,CAAc,MAAM,CAAA;EACjC;EAEA,QAAA,CAAA,EAAc;IACZ,OAAO,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,IAAQ,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;EAChD;EAEA,QAAA,CAAS,MAAA,EAAW;IAClB,MAAM,OAAA,GAAU,IAAA,CAAK,UAAA,CAAW,CAAA;IAEhC,IAAI,MAAA,CAAO,MAAA,IAAU,OAAA,CAAQ,MAAA,EAAQ;MACnC,OAAO,OAAA,CAAQ,GAAA,CAAI,CAAC,IAAA,EAAM,CAAA,KAAM,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;IACxE;IAEA,KAAA,CAAM,QAAA,CAAS,MAAA,CAAO,GAAA,CAAI,YAAY,CAAC,CAAA;IACvC,OAAO,IAAA;EACT;AACF,CAAA;AAEA,SAAS,YAAA,CAAa,KAAA,EAAY;EAChC,MAAM,QAAA,GAAW,gBAAA,CAAiB,KAAK,CAAA,GAAI,cAAA,GAAiB,aAAA;EAC5D,OAAO,QAAA,CAAS,MAAA,CAAO,KAAK,CAAA;AAC9B;;;AGzCA,SAAS,EAAA,IAAA,GAAA,EAAI,gBAAA,IAAA,iBAAA,QAAwB,sBAAA;AAQ9B,SAAS,eAAA,CAAgB,KAAA,EAA0B;EACxD,MAAM,UAAA,GAAa,WAAA,CAAY,KAAK,CAAA;EACpC,OAAO,UAAA,GACF,UAAA,CAAW,WAAA,GACZA,GAAAA,CAAG,GAAA,CAAI,KAAK,CAAA,GACV,aAAA,GACAC,iBAAAA,CAAiB,KAAK,CAAA,GACpB,cAAA,GACA,aAAA;AACV;;;AChBA,SAAS,EAAA,IAAA,GAAA,EAAI,QAAA,IAAA,SAAA,QAAgB,sBAAA;;;ACD7B,OAAA,KAAY,KAAA,MAAW,OAAA;AACvB,SAAS,UAAA,EAAY,MAAA,EAAa,WAAA,EAAa,SAAA,QAAiB,OAAA;AAChE,SACE,EAAA,IAAA,GAAA,EACA,IAAA,IAAA,KAAA,EACA,GAAA,EACA,cAAA,EACA,OAAA,EAGA,gBAAA,EACA,mBAAA,EACA,yBAAA,QACK,sBAAA;AASA,IAAM,YAAA,GAAe,CAAC,SAAA,EAAgB,IAAA,KAAqB;EAChE,MAAM,WAAA;EAAA;EAAA;EAGJ,CAACD,GAAAA,CAAG,GAAA,CAAI,SAAS,CAAA,IAChB,SAAA,CAAU,SAAA,IAAa,SAAA,CAAU,SAAA,CAAU,gBAAA;EAE9C,OAAO,UAAA,CAAW,CAAC,UAAA,EAAiB,QAAA,KAAuB;IACzD,MAAM,WAAA,GAAc,MAAA,CAAY,IAAI,CAAA;IAIpC,MAAM,GAAA,GACJ,WAAA;IAAA;IAEA,WAAA,CACG,KAAA,IAAe;MACd,WAAA,CAAY,OAAA,GAAU,SAAA,CAAU,QAAA,EAAU,KAAK,CAAA;IACjD,CAAA,EACA,CAAC,QAAQ,CACX,CAAA;IAEF,MAAM,CAAC,KAAA,EAAO,IAAI,CAAA,GAAI,gBAAA,CAAiB,UAAA,EAAY,IAAI,CAAA;IAEvD,MAAM,WAAA,GAAc,cAAA,CAAe,CAAA;IAEnC,MAAM,QAAA,GAAW,CAAA,KAAM;MACrB,MAAM,QAAA,GAAW,WAAA,CAAY,OAAA;MAC7B,IAAI,WAAA,IAAe,CAAC,QAAA,EAAU;QAG5B;MACF;MAEA,MAAM,SAAA,GAAY,QAAA,GACd,IAAA,CAAK,mBAAA,CAAoB,QAAA,EAAU,KAAA,CAAM,QAAA,CAAS,IAAI,CAAC,CAAA,GACvD,KAAA;MAGJ,IAAI,SAAA,KAAc,KAAA,EAAO;QACvB,WAAA,CAAY,CAAA;MACd;IACF,CAAA;IAEA,MAAM,QAAA,GAAW,IAAI,aAAA,CAAc,QAAA,EAAU,IAAI,CAAA;IAEjD,MAAM,WAAA,GAAc,MAAA,CAAsB,CAAA;IAC1C,yBAAA,CAA0B,MAAM;MAC9B,WAAA,CAAY,OAAA,GAAU,QAAA;MAGtB,KAAA,CAAK,IAAA,EAAM,GAAA,IAAO,gBAAA,CAAiB,GAAA,EAAK,QAAQ,CAAC,CAAA;MAEjD,OAAO,MAAM;QAEX,IAAI,WAAA,CAAY,OAAA,EAAS;UACvB,KAAA,CAAK,WAAA,CAAY,OAAA,CAAQ,IAAA,EAAM,GAAA,IAC7B,mBAAA,CAAoB,GAAA,EAAK,WAAA,CAAY,OAAQ,CAC/C,CAAA;UACA,GAAA,CAAI,MAAA,CAAO,WAAA,CAAY,OAAA,CAAQ,MAAM,CAAA;QACvC;MACF,CAAA;IACF,CAAC,CAAA;IAGD,SAAA,CAAU,QAAA,EAAU,EAAE,CAAA;IAEtB,OAAA,CAAQ,MAAM,MAAM;MAClB,MAAME,SAAAA,GAAW,WAAA,CAAY,OAAA;MAC7B,KAAA,CAAKA,SAAAA,CAAS,IAAA,EAAM,GAAA,IAAO,mBAAA,CAAoB,GAAA,EAAKA,SAAQ,CAAC,CAAA;IAC/D,CAAC,CAAA;IAED,MAAM,SAAA,GAAY,IAAA,CAAK,iBAAA,CAAkB,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA;IACzD,OAAO,eAAA,KAAA,CAAA,aAAA,CAAC,SAAA,EAAA;MAAW,GAAG,SAAA;MAAW;IAAA,CAAU,CAAA;EAC7C,CAAC,CAAA;AACH,CAAA;AAEA,IAAM,aAAA,GAAN,MAAoB;EAClB,WAAA,CACW,MAAA,EACA,IAAA,EACT;IAFS,IAAA,CAAA,MAAA,GAAA,MAAA;IACA,IAAA,CAAA,IAAA,GAAA,IAAA;EACR;EACH,aAAA,CAAc,KAAA,EAAmB;IAC/B,IAAI,KAAA,CAAM,IAAA,IAAQ,QAAA,EAAU;MAC1B,GAAA,CAAI,KAAA,CAAM,IAAA,CAAK,MAAM,CAAA;IACvB;EACF;AACF,CAAA;AAIA,SAAS,gBAAA,CAAiB,KAAA,EAAY,IAAA,EAAiC;EACrE,MAAM,YAAA,GAAe,eAAA,IAAI,GAAA,CAAgB,CAAA;EACzC,WAAA,CAAY,YAAA,GAAe,YAAA;EAG3B,IAAI,KAAA,CAAM,KAAA,EACR,KAAA,GAAQ;IACN,GAAG,KAAA;IACH,KAAA,EAAO,IAAA,CAAK,mBAAA,CAAoB,KAAA,CAAM,KAAK;EAC7C,CAAA;EAGF,KAAA,GAAQ,IAAI,cAAA,CAAe,KAAK,CAAA;EAEhC,WAAA,CAAY,YAAA,GAAe,IAAA;EAC3B,OAAO,CAAC,KAAA,EAAO,YAAY,CAAA;AAC7B;AAEA,SAAS,SAAA,CAAa,GAAA,EAAa,KAAA,EAAU;EAC3C,IAAI,GAAA,EAAK;IACP,IAAIF,GAAAA,CAAG,GAAA,CAAI,GAAG,CAAA,EAAG,GAAA,CAAI,KAAK,CAAA,CAAA,KACpB,GAAA,CAAY,OAAA,GAAU,KAAA;EAC9B;EACA,OAAO,KAAA;AACT;;;ADnHA,IAAM,QAAA,GAAW,MAAA,CAAO,GAAA,CAAI,mBAAmB,CAAA;AAExC,IAAM,UAAA,GAAa,CACxB,UAAA,EACA;EACE,mBAAA,GAAsB,CAAA,KAAM,KAAA;EAC5B,mBAAA,GAAsB,KAAA,IAAS,IAAI,cAAA,CAAe,KAAK,CAAA;EACvD,iBAAA,GAAoB,KAAA,IAAS;AAC/B,CAAA,GAAyB,CAAC,CAAA,KACvB;EACH,MAAM,UAAA,GAAyB;IAC7B,mBAAA;IACA,mBAAA;IACA;EACF,CAAA;EAEA,MAAM,QAAA,GAA0B,SAAA,IAAmB;IACjD,MAAM,WAAA,GAAc,cAAA,CAAe,SAAS,CAAA,IAAK,WAAA;IAEjD,IAAIA,GAAAA,CAAG,GAAA,CAAI,SAAS,CAAA,EAAG;MACrB,SAAA,GACE,QAAA,CAAS,SAAS,CAAA,KACjB,QAAA,CAAS,SAAS,CAAA,GAAI,YAAA,CAAa,SAAA,EAAW,UAAU,CAAA,CAAA;IAC7D,CAAA,MAAO;MACL,SAAA,GACE,SAAA,CAAU,QAAQ,CAAA,KACjB,SAAA,CAAU,QAAQ,CAAA,GAAI,YAAA,CAAa,SAAA,EAAW,UAAU,CAAA,CAAA;IAC7D;IAEA,SAAA,CAAU,WAAA,GAAc,YAAY,WAAA,GAAA;IACpC,OAAO,SAAA;EACT,CAAA;EAEA,SAAA,CAAS,UAAA,EAAY,CAAC,SAAA,EAAW,GAAA,KAAQ;IACvC,IAAIA,GAAAA,CAAG,GAAA,CAAI,UAAU,CAAA,EAAG;MACtB,GAAA,GAAM,cAAA,CAAe,SAAS,CAAA;IAChC;IACA,QAAA,CAAS,GAAG,CAAA,GAAI,QAAA,CAAS,SAAS,CAAA;EACpC,CAAC,CAAA;EAED,OAAO;IACL;EACF,CAAA;AACF,CAAA;AAEA,IAAM,cAAA,GAAkB,GAAA,IACtBA,GAAAA,CAAG,GAAA,CAAI,GAAG,CAAA,GACN,GAAA,GACA,GAAA,IAAOA,GAAAA,CAAG,GAAA,CAAI,GAAA,CAAI,WAAW,CAAA,GAC3B,GAAA,CAAI,WAAA,GACHA,GAAAA,CAAG,GAAA,CAAI,GAAG,CAAA,IAAK,GAAA,CAAI,IAAA,IAAS,IAAA","sourcesContent":["import { defineHidden } from '@react-spring/shared'\nimport { AnimatedValue } from './AnimatedValue'\n\nconst $node: any = Symbol.for('Animated:node')\n\nexport const isAnimated = <T = any>(value: any): value is Animated<T> =>\n  !!value && value[$node] === value\n\n/** Get the owner's `Animated` node. */\nexport const getAnimated = <T = any>(owner: any): Animated<T> | undefined =>\n  owner && owner[$node]\n\n/** Set the owner's `Animated` node. */\nexport const setAnimated = (owner: any, node: Animated) =>\n  defineHidden(owner, $node, node)\n\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\nexport const getPayload = (owner: any): AnimatedValue[] | undefined =>\n  owner && owner[$node] && owner[$node].getPayload()\n\nexport abstract class Animated<T = any> {\n  /** The cache of animated values */\n  protected payload?: Payload\n\n  constructor() {\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this)\n  }\n\n  /** Get the current value. Pass `true` for only animated values. */\n  abstract getValue(animated?: boolean): T\n\n  /** Set the current value. Returns `true` if the value changed. */\n  abstract setValue(value: T): boolean | void\n\n  /** Reset any animation state. */\n  abstract reset(goal?: T): void\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload(): Payload {\n    return this.payload || []\n  }\n}\n\nexport type Payload = readonly AnimatedValue[]\n","import { is } from '@react-spring/shared'\nimport { Animated, Payload } from './Animated'\n\n/** An animated number or a native attribute value */\nexport class AnimatedValue<T = any> extends Animated {\n  done = true\n  elapsedTime!: number\n  lastPosition!: number\n  lastVelocity?: number | null\n  v0?: number | null\n  durationProgress = 0\n\n  constructor(protected _value: T) {\n    super()\n    if (is.num(this._value)) {\n      this.lastPosition = this._value\n    }\n  }\n\n  /** @internal */\n  static create(value: any) {\n    return new AnimatedValue(value)\n  }\n\n  getPayload(): Payload {\n    return [this]\n  }\n\n  getValue() {\n    return this._value\n  }\n\n  setValue(value: T, step?: number) {\n    if (is.num(value)) {\n      this.lastPosition = value\n      if (step) {\n        value = (Math.round(value / step) * step) as any\n        if (this.done) {\n          this.lastPosition = value as any\n        }\n      }\n    }\n    if (this._value === value) {\n      return false\n    }\n    this._value = value\n    return true\n  }\n\n  reset() {\n    const { done } = this\n    this.done = false\n    if (is.num(this._value)) {\n      this.elapsedTime = 0\n      this.durationProgress = 0\n      this.lastPosition = this._value\n      if (done) this.lastVelocity = null\n      this.v0 = null\n    }\n  }\n}\n","import { AnimatedValue } from './AnimatedValue'\nimport { is, createInterpolator } from '@react-spring/shared'\n\ntype Value = string | number\n\nexport class AnimatedString extends AnimatedValue<Value> {\n  protected declare _value: number\n  protected _string: string | null = null\n  protected _toString: (input: number) => string\n\n  constructor(value: string) {\n    super(0)\n    this._toString = createInterpolator({\n      output: [value, value],\n    })\n  }\n\n  /** @internal */\n  static create(value: string) {\n    return new AnimatedString(value)\n  }\n\n  getValue() {\n    const value = this._string\n    return value == null ? (this._string = this._toString(this._value)) : value\n  }\n\n  setValue(value: Value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false\n      }\n      this._string = value\n      this._value = 1\n    } else if (super.setValue(value)) {\n      this._string = null\n    } else {\n      return false\n    }\n    return true\n  }\n\n  reset(goal?: string) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal],\n      })\n    }\n    this._value = 0\n    super.reset()\n  }\n}\n","import { isAnimatedString } from '@react-spring/shared'\nimport { AnimatedObject } from './AnimatedObject'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\n\ntype Value = number | string\ntype Source = AnimatedValue<Value>[]\n\n/** An array of animated nodes */\nexport class AnimatedArray<\n  T extends ReadonlyArray<Value> = Value[],\n> extends AnimatedObject {\n  protected declare source: Source\n  constructor(source: T) {\n    super(source)\n  }\n\n  /** @internal */\n  static create<T extends ReadonlyArray<Value>>(source: T) {\n    return new AnimatedArray(source)\n  }\n\n  getValue(): T {\n    return this.source.map(node => node.getValue()) as any\n  }\n\n  setValue(source: T) {\n    const payload = this.getPayload()\n    // Reuse the payload when lengths are equal.\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean)\n    }\n    // Remake the payload when length changes.\n    super.setValue(source.map(makeAnimated))\n    return true\n  }\n}\n\nfunction makeAnimated(value: any) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue\n  return nodeType.create(value)\n}\n","import { Lookup } from '@react-spring/types'\nimport {\n  each,\n  eachProp,\n  getFluidValue,\n  hasFluidValue,\n} from '@react-spring/shared'\nimport { Animated, isAnimated, getPayload } from './Animated'\nimport { AnimatedValue } from './AnimatedValue'\nimport { TreeContext } from './context'\n\n/** An object containing `Animated` nodes */\nexport class AnimatedObject extends Animated {\n  constructor(protected source: Lookup) {\n    super()\n    this.setValue(source)\n  }\n\n  getValue(animated?: boolean) {\n    const values: Lookup = {}\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated)\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source)\n      } else if (!animated) {\n        values[key] = source\n      }\n    })\n    return values\n  }\n\n  /** Replace the raw object data */\n  setValue(source: Lookup) {\n    this.source = source\n    this.payload = this._makePayload(source)\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset())\n    }\n  }\n\n  /** Create a payload set. */\n  protected _makePayload(source: Lookup) {\n    if (source) {\n      const payload = new Set<AnimatedValue>()\n      eachProp(source, this._addToPayload, payload)\n      return Array.from(payload)\n    }\n  }\n\n  /** Add to a payload set. */\n  protected _addToPayload(this: Set<AnimatedValue>, source: any) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source)\n    }\n    const payload = getPayload(source)\n    if (payload) {\n      each(payload, node => this.add(node))\n    }\n  }\n}\n","import { FluidValue } from '@react-spring/shared'\n\nexport type TreeContext = {\n  /**\n   * Any animated values found when updating the payload of an `AnimatedObject`\n   * are also added to this `Set` to be observed by an animated component.\n   */\n  dependencies: Set<FluidValue> | null\n}\n\nexport const TreeContext: TreeContext = { dependencies: null }\n","import { is, isAnimatedString } from '@react-spring/shared'\nimport { AnimatedType } from './types'\nimport { AnimatedArray } from './AnimatedArray'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\nimport { getAnimated } from './Animated'\n\n/** Return the `Animated` node constructor for a given value */\nexport function getAnimatedType(value: any): AnimatedType {\n  const parentNode = getAnimated(value)\n  return parentNode\n    ? (parentNode.constructor as any)\n    : is.arr(value)\n      ? AnimatedArray\n      : isAnimatedString(value)\n        ? AnimatedString\n        : AnimatedValue\n}\n","import { Lookup } from '@react-spring/types'\nimport { is, eachProp } from '@react-spring/shared'\nimport { AnimatableComponent, withAnimated } from './withAnimated'\nimport { Animated } from './Animated'\nimport { AnimatedObject } from './AnimatedObject'\n\nexport interface HostConfig {\n  /** Provide custom logic for native updates */\n  applyAnimatedValues: (node: any, props: Lookup) => boolean | void\n  /** Wrap the `style` prop with an animated node */\n  createAnimatedStyle: (style: Lookup) => Animated\n  /** Intercept props before they're passed to an animated component */\n  getComponentProps: (props: Lookup) => typeof props\n}\n\n// A stub type that gets replaced by @react-spring/web and others.\ntype WithAnimated = {\n  (Component: AnimatableComponent): any\n  [key: string]: any\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent')\n\nexport const createHost = (\n  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },\n  {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props,\n  }: Partial<HostConfig> = {}\n) => {\n  const hostConfig: HostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps,\n  }\n\n  const animated: WithAnimated = (Component: any) => {\n    const displayName = getDisplayName(Component) || 'Anonymous'\n\n    if (is.str(Component)) {\n      Component =\n        animated[Component] ||\n        (animated[Component] = withAnimated(Component, hostConfig))\n    } else {\n      Component =\n        Component[cacheKey] ||\n        (Component[cacheKey] = withAnimated(Component, hostConfig))\n    }\n\n    Component.displayName = `Animated(${displayName})`\n    return Component\n  }\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component)!\n    }\n    animated[key] = animated(Component)\n  })\n\n  return {\n    animated,\n  }\n}\n\nconst getDisplayName = (arg: AnimatableComponent) =>\n  is.str(arg)\n    ? arg\n    : arg && is.str(arg.displayName)\n      ? arg.displayName\n      : (is.fun(arg) && arg.name) || null\n","import * as React from 'react'\nimport { forwardRef, useRef, Ref, useCallback, useEffect } from 'react'\nimport {\n  is,\n  each,\n  raf,\n  useForceUpdate,\n  useOnce,\n  FluidEvent,\n  FluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n  useIsomorphicLayoutEffect,\n} from '@react-spring/shared'\nimport { ElementType } from '@react-spring/types'\n\nimport { AnimatedObject } from './AnimatedObject'\nimport { TreeContext } from './context'\nimport { HostConfig } from './createHost'\n\nexport type AnimatableComponent = string | Exclude<ElementType, string>\n\nexport const withAnimated = (Component: any, host: HostConfig) => {\n  const hasInstance: boolean =\n    // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) ||\n    (Component.prototype && Component.prototype.isReactComponent)\n\n  return forwardRef((givenProps: any, givenRef: Ref<any>) => {\n    const instanceRef = useRef<any>(null)\n\n    // The `hasInstance` value is constant, so we can safely avoid\n    // the `useCallback` invocation when `hasInstance` is false.\n    const ref =\n      hasInstance &&\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useCallback(\n        (value: any) => {\n          instanceRef.current = updateRef(givenRef, value)\n        },\n        [givenRef]\n      )\n\n    const [props, deps] = getAnimatedState(givenProps, host)\n\n    const forceUpdate = useForceUpdate()\n\n    const callback = () => {\n      const instance = instanceRef.current\n      if (hasInstance && !instance) {\n        // Either this component was unmounted before changes could be\n        // applied, or the wrapped component forgot to forward its ref.\n        return\n      }\n\n      const didUpdate = instance\n        ? host.applyAnimatedValues(instance, props.getValue(true))\n        : false\n\n      // Re-render the component when native updates fail.\n      if (didUpdate === false) {\n        forceUpdate()\n      }\n    }\n\n    const observer = new PropsObserver(callback, deps)\n\n    const observerRef = useRef<PropsObserver>()\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer\n\n      // Observe the latest dependencies.\n      each(deps, dep => addFluidObserver(dep, observer))\n\n      return () => {\n        // Stop observing previous dependencies.\n        if (observerRef.current) {\n          each(observerRef.current.deps, dep =>\n            removeFluidObserver(dep, observerRef.current!)\n          )\n          raf.cancel(observerRef.current.update)\n        }\n      }\n    })\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(callback, [])\n    // Stop observing on unmount.\n    useOnce(() => () => {\n      const observer = observerRef.current!\n      each(observer.deps, dep => removeFluidObserver(dep, observer))\n    })\n\n    const usedProps = host.getComponentProps(props.getValue())\n    return <Component {...usedProps} ref={ref} />\n  })\n}\n\nclass PropsObserver {\n  constructor(\n    readonly update: () => void,\n    readonly deps: Set<FluidValue>\n  ) {}\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      raf.write(this.update)\n    }\n  }\n}\n\ntype AnimatedState = [props: AnimatedObject, dependencies: Set<FluidValue>]\n\nfunction getAnimatedState(props: any, host: HostConfig): AnimatedState {\n  const dependencies = new Set<FluidValue>()\n  TreeContext.dependencies = dependencies\n\n  // Search the style for dependencies.\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style),\n    }\n\n  // Search the props for dependencies.\n  props = new AnimatedObject(props)\n\n  TreeContext.dependencies = null\n  return [props, dependencies]\n}\n\nfunction updateRef<T>(ref: Ref<T>, value: T) {\n  if (ref) {\n    if (is.fun(ref)) ref(value)\n    else (ref as any).current = value\n  }\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}