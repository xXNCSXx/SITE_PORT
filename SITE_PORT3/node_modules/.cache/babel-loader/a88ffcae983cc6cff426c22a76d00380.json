{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function (manager) {\n  Loader.call(this, manager);\n  this.propertyNameMapping = {};\n};\nPLYLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PLYLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setPropertyNameMapping: function (mapping) {\n    this.propertyNameMapping = mapping;\n  },\n  parse: function (data) {\n    function parseHeader(data) {\n      var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      var headerText = '';\n      var headerLength = 0;\n      var result = patternHeader.exec(data);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      var header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      var lines = headerText.split('\\n');\n      var currentElement;\n      var lineType, lineValues;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        var property = {\n          type: propertValues[0]\n        };\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        lineValues = line.split(/\\s+/);\n        lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case 'comment':\n            header.comments.push(line);\n            break;\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      var values = line.split(/\\s+/);\n      var element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          var n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var result;\n      var patternBody = /end_header\\s([\\s\\S]*)$/;\n      var body = '';\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n      var lines = body.split('\\n');\n      var currentElement = 0;\n      var currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n        if (line === '') {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        var element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      var geometry = new BufferGeometry(); // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z);\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n        }\n      } else if (elementName === 'face') {\n        var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n        var texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      var element = {};\n      var result,\n        read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          var n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data, header) {\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var little_endian = header.format === 'binary_little_endian';\n      var body = new DataView(data, header.headerLength);\n      var result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          var element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    } //\n\n    var geometry;\n    var scope = this;\n    if (data instanceof ArrayBuffer) {\n      var text = LoaderUtils.decodeText(new Uint8Array(data));\n      var header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n});\nexport { PLYLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PLYLoader","manager","call","propertyNameMapping","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","lineType","lineValues","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","shift","join","format","version","push","undefined","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","ArrayBuffer","decodeText","Uint8Array"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/PLYLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function (manager) {\n  Loader.call(this, manager);\n  this.propertyNameMapping = {};\n};\n\nPLYLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: PLYLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  setPropertyNameMapping: function (mapping) {\n    this.propertyNameMapping = mapping;\n  },\n  parse: function (data) {\n    function parseHeader(data) {\n      var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      var headerText = '';\n      var headerLength = 0;\n      var result = patternHeader.exec(data);\n\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n\n      var header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      var lines = headerText.split('\\n');\n      var currentElement;\n      var lineType, lineValues;\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        var property = {\n          type: propertValues[0]\n        };\n\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n\n        return property;\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        lineValues = line.split(/\\s+/);\n        lineType = lineValues.shift();\n        line = lineValues.join(' ');\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n\n          case 'comment':\n            header.comments.push(line);\n            break;\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n\n      return header;\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      var values = line.split(/\\s+/);\n      var element = {};\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          var n = parseASCIINumber(values.shift(), properties[i].countType);\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n\n      return element;\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var result;\n      var patternBody = /end_header\\s([\\s\\S]*)$/;\n      var body = '';\n\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n\n      var lines = body.split('\\n');\n      var currentElement = 0;\n      var currentElementCount = 0;\n\n      for (let i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n\n        if (line === '') {\n          continue;\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n\n        var element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n\n      return postProcess(buffer);\n    }\n\n    function postProcess(buffer) {\n      var geometry = new BufferGeometry(); // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z);\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n        }\n      } else if (elementName === 'face') {\n        var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n        var texcoord = element.texcoord;\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      var element = {};\n      var result,\n          read = 0;\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          var list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          var n = result[0];\n          read += result[1];\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n\n      return [element, read];\n    }\n\n    function parseBinary(data, header) {\n      var buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      var little_endian = header.format === 'binary_little_endian';\n      var body = new DataView(data, header.headerLength);\n      var result,\n          loc = 0;\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          var element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n\n      return postProcess(buffer);\n    } //\n\n\n    var geometry;\n    var scope = this;\n\n    if (data instanceof ArrayBuffer) {\n      var text = LoaderUtils.decodeText(new Uint8Array(data));\n      var header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n\n    return geometry;\n  }\n});\n\nexport { PLYLoader };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,UAAU,EAAEC,WAAW,EAAEC,cAAc,EAAEC,sBAAsB,QAAQ,OAAO;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,SAAS,GAAG,SAAAA,CAAUC,OAAO,EAAE;EACjCN,MAAM,CAACO,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC;EAC1B,IAAI,CAACE,mBAAmB,GAAG,CAAC,CAAC;AAC/B,CAAC;AAEDH,SAAS,CAACI,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,MAAM,CAACZ,MAAM,CAACS,SAAS,CAAC,EAAE;EACnEI,WAAW,EAAER,SAAS;EACtBS,IAAI,EAAE,SAAAA,CAAUC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;IAChD,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIC,MAAM,GAAG,IAAInB,UAAU,CAAC,IAAI,CAACK,OAAO,CAAC;IACzCc,MAAM,CAACC,OAAO,CAAC,IAAI,CAACC,IAAI,CAAC;IACzBF,MAAM,CAACG,eAAe,CAAC,aAAa,CAAC;IACrCH,MAAM,CAACI,gBAAgB,CAAC,IAAI,CAACC,aAAa,CAAC;IAC3CL,MAAM,CAACM,kBAAkB,CAAC,IAAI,CAACC,eAAe,CAAC;IAC/CP,MAAM,CAACN,IAAI,CAACC,GAAG,EAAE,UAAUa,IAAI,EAAE;MAC/B,IAAI;QACFZ,MAAM,CAACG,KAAK,CAACU,KAAK,CAACD,IAAI,CAAC,CAAC;MAC3B,CAAC,CAAC,OAAOE,CAAC,EAAE;QACV,IAAIZ,OAAO,EAAE;UACXA,OAAO,CAACY,CAAC,CAAC;QACZ,CAAC,MAAM;UACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;QAClB;QAEAX,KAAK,CAACb,OAAO,CAAC2B,SAAS,CAAClB,GAAG,CAAC;MAC9B;IACF,CAAC,EAAEE,UAAU,EAAEC,OAAO,CAAC;EACzB,CAAC;EACDgB,sBAAsB,EAAE,SAAAA,CAAUC,OAAO,EAAE;IACzC,IAAI,CAAC3B,mBAAmB,GAAG2B,OAAO;EACpC,CAAC;EACDN,KAAK,EAAE,SAAAA,CAAUO,IAAI,EAAE;IACrB,SAASC,WAAWA,CAACD,IAAI,EAAE;MACzB,IAAIE,aAAa,GAAG,6BAA6B;MACjD,IAAIC,UAAU,GAAG,EAAE;MACnB,IAAIC,YAAY,GAAG,CAAC;MACpB,IAAIC,MAAM,GAAGH,aAAa,CAACI,IAAI,CAACN,IAAI,CAAC;MAErC,IAAIK,MAAM,KAAK,IAAI,EAAE;QACnBF,UAAU,GAAGE,MAAM,CAAC,CAAC,CAAC;QACtBD,YAAY,GAAG,IAAIG,IAAI,CAAC,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAACG,IAAI;MAC3C;MAEA,IAAIC,MAAM,GAAG;QACXC,QAAQ,EAAE,EAAE;QACZC,QAAQ,EAAE,EAAE;QACZP,YAAY,EAAEA,YAAY;QAC1BQ,OAAO,EAAE;MACX,CAAC;MACD,IAAIC,KAAK,GAAGV,UAAU,CAACW,KAAK,CAAC,IAAI,CAAC;MAClC,IAAIC,cAAc;MAClB,IAAIC,QAAQ,EAAEC,UAAU;MAExB,SAASC,yBAAyBA,CAACC,aAAa,EAAE/C,mBAAmB,EAAE;QACrE,IAAIgD,QAAQ,GAAG;UACbC,IAAI,EAAEF,aAAa,CAAC,CAAC;QACvB,CAAC;QAED,IAAIC,QAAQ,CAACC,IAAI,KAAK,MAAM,EAAE;UAC5BD,QAAQ,CAACE,IAAI,GAAGH,aAAa,CAAC,CAAC,CAAC;UAChCC,QAAQ,CAACG,SAAS,GAAGJ,aAAa,CAAC,CAAC,CAAC;UACrCC,QAAQ,CAACI,QAAQ,GAAGL,aAAa,CAAC,CAAC,CAAC;QACtC,CAAC,MAAM;UACLC,QAAQ,CAACE,IAAI,GAAGH,aAAa,CAAC,CAAC,CAAC;QAClC;QAEA,IAAIC,QAAQ,CAACE,IAAI,IAAIlD,mBAAmB,EAAE;UACxCgD,QAAQ,CAACE,IAAI,GAAGlD,mBAAmB,CAACgD,QAAQ,CAACE,IAAI,CAAC;QACpD;QAEA,OAAOF,QAAQ;MACjB;MAEA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;QACrC,IAAIE,IAAI,GAAGd,KAAK,CAACY,CAAC,CAAC;QACnBE,IAAI,GAAGA,IAAI,CAACC,IAAI,CAAC,CAAC;QAClB,IAAID,IAAI,KAAK,EAAE,EAAE;QACjBV,UAAU,GAAGU,IAAI,CAACb,KAAK,CAAC,KAAK,CAAC;QAC9BE,QAAQ,GAAGC,UAAU,CAACY,KAAK,CAAC,CAAC;QAC7BF,IAAI,GAAGV,UAAU,CAACa,IAAI,CAAC,GAAG,CAAC;QAE3B,QAAQd,QAAQ;UACd,KAAK,QAAQ;YACXP,MAAM,CAACsB,MAAM,GAAGd,UAAU,CAAC,CAAC,CAAC;YAC7BR,MAAM,CAACuB,OAAO,GAAGf,UAAU,CAAC,CAAC,CAAC;YAC9B;UAEF,KAAK,SAAS;YACZR,MAAM,CAACC,QAAQ,CAACuB,IAAI,CAACN,IAAI,CAAC;YAC1B;UAEF,KAAK,SAAS;YACZ,IAAIZ,cAAc,KAAKmB,SAAS,EAAE;cAChCzB,MAAM,CAACE,QAAQ,CAACsB,IAAI,CAAClB,cAAc,CAAC;YACtC;YAEAA,cAAc,GAAG,CAAC,CAAC;YACnBA,cAAc,CAACO,IAAI,GAAGL,UAAU,CAAC,CAAC,CAAC;YACnCF,cAAc,CAACoB,KAAK,GAAGC,QAAQ,CAACnB,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9CF,cAAc,CAACsB,UAAU,GAAG,EAAE;YAC9B;UAEF,KAAK,UAAU;YACbtB,cAAc,CAACsB,UAAU,CAACJ,IAAI,CAACf,yBAAyB,CAACD,UAAU,EAAElC,KAAK,CAACX,mBAAmB,CAAC,CAAC;YAChG;UAEF,KAAK,UAAU;YACbqC,MAAM,CAACG,OAAO,GAAGe,IAAI;YACrB;UAEF;YACEhC,OAAO,CAAC2C,GAAG,CAAC,WAAW,EAAEtB,QAAQ,EAAEC,UAAU,CAAC;QAClD;MACF;MAEA,IAAIF,cAAc,KAAKmB,SAAS,EAAE;QAChCzB,MAAM,CAACE,QAAQ,CAACsB,IAAI,CAAClB,cAAc,CAAC;MACtC;MAEA,OAAON,MAAM;IACf;IAEA,SAAS8B,gBAAgBA,CAACC,CAAC,EAAEnB,IAAI,EAAE;MACjC,QAAQA,IAAI;QACV,KAAK,MAAM;QACX,KAAK,OAAO;QACZ,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,KAAK;QACV,KAAK,MAAM;QACX,KAAK,MAAM;QACX,KAAK,OAAO;QACZ,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,OAAO;QACZ,KAAK,QAAQ;UACX,OAAOe,QAAQ,CAACI,CAAC,CAAC;QAEpB,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,SAAS;QACd,KAAK,SAAS;UACZ,OAAOC,UAAU,CAACD,CAAC,CAAC;MACxB;IACF;IAEA,SAASE,iBAAiBA,CAACL,UAAU,EAAEV,IAAI,EAAE;MAC3C,IAAIgB,MAAM,GAAGhB,IAAI,CAACb,KAAK,CAAC,KAAK,CAAC;MAC9B,IAAI8B,OAAO,GAAG,CAAC,CAAC;MAEhB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,UAAU,CAACX,MAAM,EAAED,CAAC,EAAE,EAAE;QAC1C,IAAIY,UAAU,CAACZ,CAAC,CAAC,CAACJ,IAAI,KAAK,MAAM,EAAE;UACjC,IAAIwB,IAAI,GAAG,EAAE;UACb,IAAIL,CAAC,GAAGD,gBAAgB,CAACI,MAAM,CAACd,KAAK,CAAC,CAAC,EAAEQ,UAAU,CAACZ,CAAC,CAAC,CAACF,SAAS,CAAC;UAEjE,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;YAC1BD,IAAI,CAACZ,IAAI,CAACM,gBAAgB,CAACI,MAAM,CAACd,KAAK,CAAC,CAAC,EAAEQ,UAAU,CAACZ,CAAC,CAAC,CAACD,QAAQ,CAAC,CAAC;UACrE;UAEAoB,OAAO,CAACP,UAAU,CAACZ,CAAC,CAAC,CAACH,IAAI,CAAC,GAAGuB,IAAI;QACpC,CAAC,MAAM;UACLD,OAAO,CAACP,UAAU,CAACZ,CAAC,CAAC,CAACH,IAAI,CAAC,GAAGiB,gBAAgB,CAACI,MAAM,CAACd,KAAK,CAAC,CAAC,EAAEQ,UAAU,CAACZ,CAAC,CAAC,CAACJ,IAAI,CAAC;QACpF;MACF;MAEA,OAAOuB,OAAO;IAChB;IAEA,SAASG,UAAUA,CAAC/C,IAAI,EAAES,MAAM,EAAE;MAChC;MACA,IAAIuC,MAAM,GAAG;QACXC,OAAO,EAAE,EAAE;QACXC,QAAQ,EAAE,EAAE;QACZC,OAAO,EAAE,EAAE;QACXC,GAAG,EAAE,EAAE;QACPC,aAAa,EAAE,EAAE;QACjBC,MAAM,EAAE;MACV,CAAC;MACD,IAAIjD,MAAM;MACV,IAAIkD,WAAW,GAAG,wBAAwB;MAC1C,IAAIC,IAAI,GAAG,EAAE;MAEb,IAAI,CAACnD,MAAM,GAAGkD,WAAW,CAACjD,IAAI,CAACN,IAAI,CAAC,MAAM,IAAI,EAAE;QAC9CwD,IAAI,GAAGnD,MAAM,CAAC,CAAC,CAAC;MAClB;MAEA,IAAIQ,KAAK,GAAG2C,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAAC;MAC5B,IAAIC,cAAc,GAAG,CAAC;MACtB,IAAI0C,mBAAmB,GAAG,CAAC;MAE3B,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;QACrC,IAAIE,IAAI,GAAGd,KAAK,CAACY,CAAC,CAAC;QACnBE,IAAI,GAAGA,IAAI,CAACC,IAAI,CAAC,CAAC;QAElB,IAAID,IAAI,KAAK,EAAE,EAAE;UACf;QACF;QAEA,IAAI8B,mBAAmB,IAAIhD,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACoB,KAAK,EAAE;UAChEpB,cAAc,EAAE;UAChB0C,mBAAmB,GAAG,CAAC;QACzB;QAEA,IAAIb,OAAO,GAAGF,iBAAiB,CAACjC,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACsB,UAAU,EAAEV,IAAI,CAAC;QACjF+B,aAAa,CAACV,MAAM,EAAEvC,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACO,IAAI,EAAEsB,OAAO,CAAC;QACpEa,mBAAmB,EAAE;MACvB;MAEA,OAAOE,WAAW,CAACX,MAAM,CAAC;IAC5B;IAEA,SAASW,WAAWA,CAACX,MAAM,EAAE;MAC3B,IAAIY,QAAQ,GAAG,IAAI7F,cAAc,CAAC,CAAC,CAAC,CAAC;;MAErC,IAAIiF,MAAM,CAACC,OAAO,CAACvB,MAAM,GAAG,CAAC,EAAE;QAC7BkC,QAAQ,CAACC,QAAQ,CAACb,MAAM,CAACC,OAAO,CAAC;MACnC;MAEAW,QAAQ,CAACE,YAAY,CAAC,UAAU,EAAE,IAAI9F,sBAAsB,CAACgF,MAAM,CAACE,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEnF,IAAIF,MAAM,CAACG,OAAO,CAACzB,MAAM,GAAG,CAAC,EAAE;QAC7BkC,QAAQ,CAACE,YAAY,CAAC,QAAQ,EAAE,IAAI9F,sBAAsB,CAACgF,MAAM,CAACG,OAAO,EAAE,CAAC,CAAC,CAAC;MAChF;MAEA,IAAIH,MAAM,CAACI,GAAG,CAAC1B,MAAM,GAAG,CAAC,EAAE;QACzBkC,QAAQ,CAACE,YAAY,CAAC,IAAI,EAAE,IAAI9F,sBAAsB,CAACgF,MAAM,CAACI,GAAG,EAAE,CAAC,CAAC,CAAC;MACxE;MAEA,IAAIJ,MAAM,CAACM,MAAM,CAAC5B,MAAM,GAAG,CAAC,EAAE;QAC5BkC,QAAQ,CAACE,YAAY,CAAC,OAAO,EAAE,IAAI9F,sBAAsB,CAACgF,MAAM,CAACM,MAAM,EAAE,CAAC,CAAC,CAAC;MAC9E;MAEA,IAAIN,MAAM,CAACK,aAAa,CAAC3B,MAAM,GAAG,CAAC,EAAE;QACnCkC,QAAQ,GAAGA,QAAQ,CAACG,YAAY,CAAC,CAAC;QAClCH,QAAQ,CAACE,YAAY,CAAC,IAAI,EAAE,IAAI9F,sBAAsB,CAACgF,MAAM,CAACK,aAAa,EAAE,CAAC,CAAC,CAAC;MAClF;MAEAO,QAAQ,CAACI,qBAAqB,CAAC,CAAC;MAChC,OAAOJ,QAAQ;IACjB;IAEA,SAASF,aAAaA,CAACV,MAAM,EAAEiB,WAAW,EAAErB,OAAO,EAAE;MACnD,IAAIqB,WAAW,KAAK,QAAQ,EAAE;QAC5BjB,MAAM,CAACE,QAAQ,CAACjB,IAAI,CAACW,OAAO,CAACsB,CAAC,EAAEtB,OAAO,CAACuB,CAAC,EAAEvB,OAAO,CAACwB,CAAC,CAAC;QAErD,IAAI,IAAI,IAAIxB,OAAO,IAAI,IAAI,IAAIA,OAAO,IAAI,IAAI,IAAIA,OAAO,EAAE;UACzDI,MAAM,CAACG,OAAO,CAAClB,IAAI,CAACW,OAAO,CAACyB,EAAE,EAAEzB,OAAO,CAAC0B,EAAE,EAAE1B,OAAO,CAAC2B,EAAE,CAAC;QACzD;QAEA,IAAI,GAAG,IAAI3B,OAAO,IAAI,GAAG,IAAIA,OAAO,EAAE;UACpCI,MAAM,CAACI,GAAG,CAACnB,IAAI,CAACW,OAAO,CAAC4B,CAAC,EAAE5B,OAAO,CAAC6B,CAAC,CAAC;QACvC;QAEA,IAAI,KAAK,IAAI7B,OAAO,IAAI,OAAO,IAAIA,OAAO,IAAI,MAAM,IAAIA,OAAO,EAAE;UAC/DI,MAAM,CAACM,MAAM,CAACrB,IAAI,CAACW,OAAO,CAAC8B,GAAG,GAAG,KAAK,EAAE9B,OAAO,CAAC+B,KAAK,GAAG,KAAK,EAAE/B,OAAO,CAACgC,IAAI,GAAG,KAAK,CAAC;QACtF;MACF,CAAC,MAAM,IAAIX,WAAW,KAAK,MAAM,EAAE;QACjC,IAAIY,cAAc,GAAGjC,OAAO,CAACiC,cAAc,IAAIjC,OAAO,CAACkC,YAAY,CAAC,CAAC;;QAErE,IAAIC,QAAQ,GAAGnC,OAAO,CAACmC,QAAQ;QAE/B,IAAIF,cAAc,CAACnD,MAAM,KAAK,CAAC,EAAE;UAC/BsB,MAAM,CAACC,OAAO,CAAChB,IAAI,CAAC4C,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,CAAC;UAE5E,IAAIE,QAAQ,IAAIA,QAAQ,CAACrD,MAAM,KAAK,CAAC,EAAE;YACrCsB,MAAM,CAACK,aAAa,CAACpB,IAAI,CAAC8C,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnD/B,MAAM,CAACK,aAAa,CAACpB,IAAI,CAAC8C,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnD/B,MAAM,CAACK,aAAa,CAACpB,IAAI,CAAC8C,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;UACrD;QACF,CAAC,MAAM,IAAIF,cAAc,CAACnD,MAAM,KAAK,CAAC,EAAE;UACtCsB,MAAM,CAACC,OAAO,CAAChB,IAAI,CAAC4C,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,CAAC;UAC5E7B,MAAM,CAACC,OAAO,CAAChB,IAAI,CAAC4C,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,EAAEA,cAAc,CAAC,CAAC,CAAC,CAAC;QAC9E;MACF;IACF;IAEA,SAASG,UAAUA,CAACC,QAAQ,EAAEC,EAAE,EAAE7D,IAAI,EAAE8D,aAAa,EAAE;MACrD,QAAQ9D,IAAI;QACV;QACA,KAAK,MAAM;QACX,KAAK,MAAM;UACT,OAAO,CAAC4D,QAAQ,CAACG,OAAO,CAACF,EAAE,CAAC,EAAE,CAAC,CAAC;QAElC,KAAK,OAAO;QACZ,KAAK,OAAO;UACV,OAAO,CAACD,QAAQ,CAACI,QAAQ,CAACH,EAAE,CAAC,EAAE,CAAC,CAAC;QAEnC,KAAK,OAAO;QACZ,KAAK,OAAO;UACV,OAAO,CAACD,QAAQ,CAACK,QAAQ,CAACJ,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;QAElD,KAAK,QAAQ;QACb,KAAK,QAAQ;UACX,OAAO,CAACF,QAAQ,CAACM,SAAS,CAACL,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;QAEnD,KAAK,OAAO;QACZ,KAAK,KAAK;UACR,OAAO,CAACF,QAAQ,CAACO,QAAQ,CAACN,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;QAElD,KAAK,QAAQ;QACb,KAAK,MAAM;UACT,OAAO,CAACF,QAAQ,CAACQ,SAAS,CAACP,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;QAEnD,KAAK,SAAS;QACd,KAAK,OAAO;UACV,OAAO,CAACF,QAAQ,CAACS,UAAU,CAACR,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;QAEpD,KAAK,SAAS;QACd,KAAK,QAAQ;UACX,OAAO,CAACF,QAAQ,CAACU,UAAU,CAACT,EAAE,EAAEC,aAAa,CAAC,EAAE,CAAC,CAAC;MACtD;IACF;IAEA,SAASS,iBAAiBA,CAACX,QAAQ,EAAEC,EAAE,EAAE7C,UAAU,EAAE8C,aAAa,EAAE;MAClE,IAAIvC,OAAO,GAAG,CAAC,CAAC;MAChB,IAAIvC,MAAM;QACNwF,IAAI,GAAG,CAAC;MAEZ,KAAK,IAAIpE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,UAAU,CAACX,MAAM,EAAED,CAAC,EAAE,EAAE;QAC1C,IAAIY,UAAU,CAACZ,CAAC,CAAC,CAACJ,IAAI,KAAK,MAAM,EAAE;UACjC,IAAIwB,IAAI,GAAG,EAAE;UACbxC,MAAM,GAAG2E,UAAU,CAACC,QAAQ,EAAEC,EAAE,GAAGW,IAAI,EAAExD,UAAU,CAACZ,CAAC,CAAC,CAACF,SAAS,EAAE4D,aAAa,CAAC;UAChF,IAAI3C,CAAC,GAAGnC,MAAM,CAAC,CAAC,CAAC;UACjBwF,IAAI,IAAIxF,MAAM,CAAC,CAAC,CAAC;UAEjB,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;YAC1BzC,MAAM,GAAG2E,UAAU,CAACC,QAAQ,EAAEC,EAAE,GAAGW,IAAI,EAAExD,UAAU,CAACZ,CAAC,CAAC,CAACD,QAAQ,EAAE2D,aAAa,CAAC;YAC/EtC,IAAI,CAACZ,IAAI,CAAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;YACpBwF,IAAI,IAAIxF,MAAM,CAAC,CAAC,CAAC;UACnB;UAEAuC,OAAO,CAACP,UAAU,CAACZ,CAAC,CAAC,CAACH,IAAI,CAAC,GAAGuB,IAAI;QACpC,CAAC,MAAM;UACLxC,MAAM,GAAG2E,UAAU,CAACC,QAAQ,EAAEC,EAAE,GAAGW,IAAI,EAAExD,UAAU,CAACZ,CAAC,CAAC,CAACJ,IAAI,EAAE8D,aAAa,CAAC;UAC3EvC,OAAO,CAACP,UAAU,CAACZ,CAAC,CAAC,CAACH,IAAI,CAAC,GAAGjB,MAAM,CAAC,CAAC,CAAC;UACvCwF,IAAI,IAAIxF,MAAM,CAAC,CAAC,CAAC;QACnB;MACF;MAEA,OAAO,CAACuC,OAAO,EAAEiD,IAAI,CAAC;IACxB;IAEA,SAASC,WAAWA,CAAC9F,IAAI,EAAES,MAAM,EAAE;MACjC,IAAIuC,MAAM,GAAG;QACXC,OAAO,EAAE,EAAE;QACXC,QAAQ,EAAE,EAAE;QACZC,OAAO,EAAE,EAAE;QACXC,GAAG,EAAE,EAAE;QACPC,aAAa,EAAE,EAAE;QACjBC,MAAM,EAAE;MACV,CAAC;MACD,IAAI6B,aAAa,GAAG1E,MAAM,CAACsB,MAAM,KAAK,sBAAsB;MAC5D,IAAIyB,IAAI,GAAG,IAAIuC,QAAQ,CAAC/F,IAAI,EAAES,MAAM,CAACL,YAAY,CAAC;MAClD,IAAIC,MAAM;QACN2F,GAAG,GAAG,CAAC;MAEX,KAAK,IAAIjF,cAAc,GAAG,CAAC,EAAEA,cAAc,GAAGN,MAAM,CAACE,QAAQ,CAACe,MAAM,EAAEX,cAAc,EAAE,EAAE;QACtF,KAAK,IAAI0C,mBAAmB,GAAG,CAAC,EAAEA,mBAAmB,GAAGhD,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACoB,KAAK,EAAEsB,mBAAmB,EAAE,EAAE;UACpHpD,MAAM,GAAGuF,iBAAiB,CAACpC,IAAI,EAAEwC,GAAG,EAAEvF,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACsB,UAAU,EAAE8C,aAAa,CAAC;UAChGa,GAAG,IAAI3F,MAAM,CAAC,CAAC,CAAC;UAChB,IAAIuC,OAAO,GAAGvC,MAAM,CAAC,CAAC,CAAC;UACvBqD,aAAa,CAACV,MAAM,EAAEvC,MAAM,CAACE,QAAQ,CAACI,cAAc,CAAC,CAACO,IAAI,EAAEsB,OAAO,CAAC;QACtE;MACF;MAEA,OAAOe,WAAW,CAACX,MAAM,CAAC;IAC5B,CAAC,CAAC;;IAGF,IAAIY,QAAQ;IACZ,IAAI7E,KAAK,GAAG,IAAI;IAEhB,IAAIiB,IAAI,YAAYiG,WAAW,EAAE;MAC/B,IAAIzG,IAAI,GAAG1B,WAAW,CAACoI,UAAU,CAAC,IAAIC,UAAU,CAACnG,IAAI,CAAC,CAAC;MACvD,IAAIS,MAAM,GAAGR,WAAW,CAACT,IAAI,CAAC;MAC9BoE,QAAQ,GAAGnD,MAAM,CAACsB,MAAM,KAAK,OAAO,GAAGgB,UAAU,CAACvD,IAAI,EAAEiB,MAAM,CAAC,GAAGqF,WAAW,CAAC9F,IAAI,EAAES,MAAM,CAAC;IAC7F,CAAC,MAAM;MACLmD,QAAQ,GAAGb,UAAU,CAAC/C,IAAI,EAAEC,WAAW,CAACD,IAAI,CAAC,CAAC;IAChD;IAEA,OAAO4D,QAAQ;EACjB;AACF,CAAC,CAAC;AAEF,SAAS3F,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}