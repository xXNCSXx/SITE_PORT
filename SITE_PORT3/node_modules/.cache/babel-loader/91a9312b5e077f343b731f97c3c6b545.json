{"ast":null,"code":"import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */function () {\n  function RestWalker() {}\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n    forEach(prod.definition, function (subProd, index) {\n      var currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this;\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    var fullOrRest = currRest.concat(prevRest);\n    // walk all different alternatives\n    forEach(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new Alternative({\n        definition: [alt]\n      });\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n  return RestWalker;\n}();\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new Option({\n    definition: [new Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/rest.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new Alternative({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new Option({\n            definition: [new Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map"]},"metadata":{},"sourceType":"module"}