{"ast":null,"code":"import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\nvar Reflector = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader; //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  this.material = material;\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n    scope.visible = true;\n  };\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Reflector };","map":{"version":3,"names":["Mesh","Color","Plane","Vector3","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","LinearFilter","RGBFormat","Reflector","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor","tDiffuse","join"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/objects/Reflector.js"],"sourcesContent":["import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar Reflector = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader; //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexport { Reflector };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}