{"ast":null,"code":"import { Color, Vector2, MeshBasicMaterial, DoubleSide, WebGLRenderTarget, MeshDepthMaterial, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nvar OutlinePass = function (resolution, scene, camera, selectedObjects) {\n  this.renderScene = scene;\n  this.renderCamera = camera;\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n  this.visibleEdgeColor = new Color(1, 1, 1);\n  this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n  this.edgeGlow = 0.0;\n  this.usePatternTexture = false;\n  this.edgeThickness = 1.0;\n  this.edgeStrength = 3.0;\n  this.downSampleRatio = 2;\n  this.pulsePeriod = 0;\n  this._visibilityCache = new Map();\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\n  this.maskBufferMaterial = new MeshBasicMaterial({\n    color: 0xffffff\n  });\n  this.maskBufferMaterial.side = DoubleSide;\n  this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n  this.depthMaterial = new MeshDepthMaterial();\n  this.depthMaterial.side = DoubleSide;\n  this.depthMaterial.depthPacking = RGBADepthPacking;\n  this.depthMaterial.blending = NoBlending;\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n  this.prepareMaskMaterial.side = DoubleSide;\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n  this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n  this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n  this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n  this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n  var MAX_EDGE_THICKNESS = 4;\n  var MAX_EDGE_GLOW = 4;\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n  if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.fsQuad = new FullScreenQuad(null);\n  this.tempPulseColor1 = new Color();\n  this.tempPulseColor2 = new Color();\n  this.textureMatrix = new Matrix4();\n  function replaceDepthToViewZ(string, camera) {\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n  }\n};\nOutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: OutlinePass,\n  dispose: function () {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  },\n  setSize: function (width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    var resx = Math.round(width / this.downSampleRatio);\n    var resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  },\n  changeVisibilityOfSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  },\n  changeVisibilityOfNonSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n    var selectedMeshes = [];\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        var bFound = false;\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          var selectedObjectId = selectedMeshes[i].id;\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n        if (bFound === false) {\n          var visibility = object.visible;\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  },\n  updateTextureMatrix: function () {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      var currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  },\n  getPrepareMaskMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\t#include <skinbase_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\tvPosition = mvPosition;', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\n'),\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n    });\n  },\n  getEdgeDetectionMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}'\n    });\n  },\n  getSeperableBlurMaterial: function (maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}'\n    });\n  },\n  getOverlayMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}',\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n});\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { OutlinePass };","map":{"version":3,"names":["Color","Vector2","MeshBasicMaterial","DoubleSide","WebGLRenderTarget","MeshDepthMaterial","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","pars","minFilter","magFilter","format","resx","Math","round","resy","maskBufferMaterial","color","side","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","type","isPerspectiveCamera","replace","prototype","Object","assign","create","constructor","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","join","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"sourcesContent":["import { Color, Vector2, MeshBasicMaterial, DoubleSide, WebGLRenderTarget, MeshDepthMaterial, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar OutlinePass = function (resolution, scene, camera, selectedObjects) {\n  this.renderScene = scene;\n  this.renderCamera = camera;\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n  this.visibleEdgeColor = new Color(1, 1, 1);\n  this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n  this.edgeGlow = 0.0;\n  this.usePatternTexture = false;\n  this.edgeThickness = 1.0;\n  this.edgeStrength = 3.0;\n  this.downSampleRatio = 2;\n  this.pulsePeriod = 0;\n  this._visibilityCache = new Map();\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\n  this.maskBufferMaterial = new MeshBasicMaterial({\n    color: 0xffffff\n  });\n  this.maskBufferMaterial.side = DoubleSide;\n  this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n  this.depthMaterial = new MeshDepthMaterial();\n  this.depthMaterial.side = DoubleSide;\n  this.depthMaterial.depthPacking = RGBADepthPacking;\n  this.depthMaterial.blending = NoBlending;\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n  this.prepareMaskMaterial.side = DoubleSide;\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n  this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n  this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n  this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n  this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n  var MAX_EDGE_THICKNESS = 4;\n  var MAX_EDGE_GLOW = 4;\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n  if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.fsQuad = new FullScreenQuad(null);\n  this.tempPulseColor1 = new Color();\n  this.tempPulseColor2 = new Color();\n  this.textureMatrix = new Matrix4();\n\n  function replaceDepthToViewZ(string, camera) {\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n  }\n};\n\nOutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: OutlinePass,\n  dispose: function () {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  },\n  setSize: function (width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    var resx = Math.round(width / this.downSampleRatio);\n    var resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  },\n  changeVisibilityOfSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  },\n  changeVisibilityOfNonSelectedObjects: function (bVisible) {\n    var cache = this._visibilityCache;\n    var selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        var bFound = false;\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          var selectedObjectId = selectedMeshes[i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          var visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  },\n  updateTextureMatrix: function () {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      var currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  },\n  getPrepareMaskMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\t#include <skinbase_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\tvPosition = mvPosition;', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\n'),\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n    });\n  },\n  getEdgeDetectionMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}'\n    });\n  },\n  getSeperableBlurMaterial: function (maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}'\n    });\n  },\n  getOverlayMaterial: function () {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}',\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n});\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\n\nexport { OutlinePass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}