{"ast":null,"code":"/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nconst DRACOExporter = () => {};\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function (object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n      if (options.exportNormals === true) {\n        const normals = geometry.getAttribute('normal');\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n      if (options.exportUvs === true) {\n        const uvs = geometry.getAttribute('uv');\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n    let length;\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n    dracoEncoder.destroy(dracoObject);\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n    const outputData = new Int8Array(new ArrayBuffer(length));\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\nexport { DRACOExporter };","map":{"version":3,"names":["DRACOExporter","prototype","constructor","parse","object","options","isBufferGeometry","Error","DracoEncoderModule","undefined","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","Mesh","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/DRACOExporter.js"],"sourcesContent":["/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nconst DRACOExporter = () => {};\n\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function (object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n\n      if (options.exportNormals === true) {\n        const normals = geometry.getAttribute('normal');\n\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs === true) {\n        const uvs = geometry.getAttribute('uv');\n\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n\n    let length;\n\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n\n    const outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n\nexport { DRACOExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}