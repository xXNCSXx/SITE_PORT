{"ast":null,"code":"'use client';\n\nvar _jsxFileName = \"C:\\\\Users\\\\drncs\\\\OneDrive\\\\\\xC1rea de Trabalho\\\\PORTIFOLIO\\\\SITE3\\\\src\\\\components\\\\SplashCursor\\\\SplashCursor.jsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction SplashCursor({\n  SIM_RESOLUTION = 128,\n  DYE_RESOLUTION = 1440,\n  CAPTURE_RESOLUTION = 512,\n  DENSITY_DISSIPATION = 3.5,\n  VELOCITY_DISSIPATION = 2,\n  PRESSURE = 0.1,\n  PRESSURE_ITERATIONS = 20,\n  CURL = 3,\n  SPLAT_RADIUS = 0.2,\n  SPLAT_FORCE = 6000,\n  SHADING = true,\n  COLOR_UPDATE_SPEED = 10,\n  BACK_COLOR = {\n    r: 0.5,\n    g: 0,\n    b: 0\n  },\n  TRANSPARENT = true\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    function pointerPrototype() {\n      this.id = -1;\n      this.texcoordX = 0;\n      this.texcoordY = 0;\n      this.prevTexcoordX = 0;\n      this.prevTexcoordY = 0;\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.down = false;\n      this.moved = false;\n      this.color = [0, 0, 0];\n    }\n    let config = {\n      SIM_RESOLUTION,\n      DYE_RESOLUTION,\n      CAPTURE_RESOLUTION,\n      DENSITY_DISSIPATION,\n      VELOCITY_DISSIPATION,\n      PRESSURE,\n      PRESSURE_ITERATIONS,\n      CURL,\n      SPLAT_RADIUS,\n      SPLAT_FORCE,\n      SHADING,\n      COLOR_UPDATE_SPEED,\n      PAUSED: false,\n      BACK_COLOR,\n      TRANSPARENT\n    };\n    let pointers = [new pointerPrototype()];\n    const {\n      gl,\n      ext\n    } = getWebGLContext(canvas);\n    if (!ext.supportLinearFiltering) {\n      config.DYE_RESOLUTION = 256;\n      config.SHADING = false;\n    }\n    function getWebGLContext(canvas) {\n      const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n      };\n      let gl = canvas.getContext('webgl2', params);\n      const isWebGL2 = !!gl;\n      if (!isWebGL2) gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);\n      let halfFloat;\n      let supportLinearFiltering;\n      if (isWebGL2) {\n        gl.getExtension('EXT_color_buffer_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n      } else {\n        halfFloat = gl.getExtension('OES_texture_half_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;\n      let formatRGBA;\n      let formatRG;\n      let formatR;\n      if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n      } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      }\n      return {\n        gl,\n        ext: {\n          formatRGBA,\n          formatRG,\n          formatR,\n          halfFloatTexType,\n          supportLinearFiltering\n        }\n      };\n    }\n    function getSupportedFormat(gl, internalFormat, format, type) {\n      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch (internalFormat) {\n          case gl.R16F:\n            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n          case gl.RG16F:\n            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n          default:\n            return null;\n        }\n      }\n      return {\n        internalFormat,\n        format\n      };\n    }\n    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      return status === gl.FRAMEBUFFER_COMPLETE;\n    }\n    class Material {\n      constructor(vertexShader, fragmentShaderSource) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n      }\n      setKeywords(keywords) {\n        let hash = 0;\n        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n          let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n          program = createProgram(this.vertexShader, fragmentShader);\n          this.programs[hash] = program;\n        }\n        if (program === this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n      }\n      bind() {\n        gl.useProgram(this.activeProgram);\n      }\n    }\n    class Program {\n      constructor(vertexShader, fragmentShader) {\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n      }\n      bind() {\n        gl.useProgram(this.program);\n      }\n    }\n    function createProgram(vertexShader, fragmentShader) {\n      let program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n      return program;\n    }\n    function getUniforms(program) {\n      let uniforms = [];\n      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n      }\n      return uniforms;\n    }\n    function compileShader(type, source, keywords) {\n      source = addKeywords(source, keywords);\n      const shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n      return shader;\n    }\n    function addKeywords(source, keywords) {\n      if (!keywords) return source;\n      let keywordsString = '';\n      keywords.forEach(keyword => {\n        keywordsString += '#define ' + keyword + '\\n';\n      });\n      return keywordsString + source;\n    }\n    const baseVertexShader = compileShader(gl.VERTEX_SHADER, `\n        precision highp float;\n        attribute vec2 aPosition;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform vec2 texelSize;\n\n        void main () {\n            vUv = aPosition * 0.5 + 0.5;\n            vL = vUv - vec2(texelSize.x, 0.0);\n            vR = vUv + vec2(texelSize.x, 0.0);\n            vT = vUv + vec2(0.0, texelSize.y);\n            vB = vUv - vec2(0.0, texelSize.y);\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `);\n    const copyShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n\n        void main () {\n            gl_FragColor = texture2D(uTexture, vUv);\n        }\n      `);\n    const clearShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform float value;\n\n        void main () {\n            gl_FragColor = value * texture2D(uTexture, vUv);\n        }\n      `);\n    const displayShaderSource = `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    `;\n    const splatShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uTarget;\n        uniform float aspectRatio;\n        uniform vec3 color;\n        uniform vec2 point;\n        uniform float radius;\n\n        void main () {\n            vec2 p = vUv - point.xy;\n            p.x *= aspectRatio;\n            vec3 splat = exp(-dot(p, p) / radius) * color;\n            vec3 base = texture2D(uTarget, vUv).xyz;\n            gl_FragColor = vec4(base + splat, 1.0);\n        }\n      `);\n    const advectionShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uSource;\n        uniform vec2 texelSize;\n        uniform vec2 dyeTexelSize;\n        uniform float dt;\n        uniform float dissipation;\n\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n            vec2 st = uv / tsize - 0.5;\n            vec2 iuv = floor(st);\n            vec2 fuv = fract(st);\n\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n        }\n\n        void main () {\n            #ifdef MANUAL_FILTERING\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n            #else\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n                vec4 result = texture2D(uSource, coord);\n            #endif\n            float decay = 1.0 + dissipation * dt;\n            gl_FragColor = result / decay;\n        }\n      `, ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']);\n    const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).x;\n            float R = texture2D(uVelocity, vR).x;\n            float T = texture2D(uVelocity, vT).y;\n            float B = texture2D(uVelocity, vB).y;\n\n            vec2 C = texture2D(uVelocity, vUv).xy;\n            if (vL.x < 0.0) { L = -C.x; }\n            if (vR.x > 1.0) { R = -C.x; }\n            if (vT.y > 1.0) { T = -C.y; }\n            if (vB.y < 0.0) { B = -C.y; }\n\n            float div = 0.5 * (R - L + T - B);\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n        }\n      `);\n    const curlShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).y;\n            float R = texture2D(uVelocity, vR).y;\n            float T = texture2D(uVelocity, vT).x;\n            float B = texture2D(uVelocity, vB).x;\n            float vorticity = R - L - T + B;\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n        }\n      `);\n    const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uCurl;\n        uniform float curl;\n        uniform float dt;\n\n        void main () {\n            float L = texture2D(uCurl, vL).x;\n            float R = texture2D(uCurl, vR).x;\n            float T = texture2D(uCurl, vT).x;\n            float B = texture2D(uCurl, vB).x;\n            float C = texture2D(uCurl, vUv).x;\n\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n            force /= length(force) + 0.0001;\n            force *= curl * C;\n            force.y *= -1.0;\n\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity += force * dt;\n            velocity = min(max(velocity, -1000.0), 1000.0);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `);\n    const pressureShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uDivergence;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            float C = texture2D(uPressure, vUv).x;\n            float divergence = texture2D(uDivergence, vUv).x;\n            float pressure = (L + R + B + T - divergence) * 0.25;\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n        }\n      `);\n    const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity.xy -= vec2(R - L, T - B);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `);\n    const blit = (() => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      return (target, clear = false) => {\n        if (target == null) {\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n          gl.viewport(0, 0, target.width, target.height);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      };\n    })();\n    let dye, velocity, divergence, curl, pressure;\n    const copyProgram = new Program(baseVertexShader, copyShader);\n    const clearProgram = new Program(baseVertexShader, clearShader);\n    const splatProgram = new Program(baseVertexShader, splatShader);\n    const advectionProgram = new Program(baseVertexShader, advectionShader);\n    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n    const curlProgram = new Program(baseVertexShader, curlShader);\n    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n    const pressureProgram = new Program(baseVertexShader, pressureShader);\n    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n    function initFramebuffers() {\n      let simRes = getResolution(config.SIM_RESOLUTION);\n      let dyeRes = getResolution(config.DYE_RESOLUTION);\n      const texType = ext.halfFloatTexType;\n      const rgba = ext.formatRGBA;\n      const rg = ext.formatRG;\n      const r = ext.formatR;\n      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n      gl.disable(gl.BLEND);\n      if (!dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n      if (!velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n      divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    }\n    function createFBO(w, h, internalFormat, format, type, param) {\n      gl.activeTexture(gl.TEXTURE0);\n      let texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n      let fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      gl.viewport(0, 0, w, h);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      let texelSizeX = 1.0 / w;\n      let texelSizeY = 1.0 / h;\n      return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id) {\n          gl.activeTexture(gl.TEXTURE0 + id);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          return id;\n        }\n      };\n    }\n    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n      return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read() {\n          return fbo1;\n        },\n        set read(value) {\n          fbo1 = value;\n        },\n        get write() {\n          return fbo2;\n        },\n        set write(value) {\n          fbo2 = value;\n        },\n        swap() {\n          let temp = fbo1;\n          fbo1 = fbo2;\n          fbo2 = temp;\n        }\n      };\n    }\n    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n      copyProgram.bind();\n      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n      blit(newFBO);\n      return newFBO;\n    }\n    function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n      if (target.width === w && target.height === h) return target;\n      target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n      target.write = createFBO(w, h, internalFormat, format, type, param);\n      target.width = w;\n      target.height = h;\n      target.texelSizeX = 1.0 / w;\n      target.texelSizeY = 1.0 / h;\n      return target;\n    }\n    function updateKeywords() {\n      let displayKeywords = [];\n      if (config.SHADING) displayKeywords.push('SHADING');\n      displayMaterial.setKeywords(displayKeywords);\n    }\n    updateKeywords();\n    initFramebuffers();\n    let lastUpdateTime = Date.now();\n    let colorUpdateTimer = 0.0;\n    function updateFrame() {\n      const dt = calcDeltaTime();\n      if (resizeCanvas()) initFramebuffers();\n      updateColors(dt);\n      applyInputs();\n      step(dt);\n      render(null);\n      requestAnimationFrame(updateFrame);\n    }\n    function calcDeltaTime() {\n      let now = Date.now();\n      let dt = (now - lastUpdateTime) / 1000;\n      dt = Math.min(dt, 0.016666);\n      lastUpdateTime = now;\n      return dt;\n    }\n    function resizeCanvas() {\n      let width = scaleByPixelRatio(canvas.clientWidth);\n      let height = scaleByPixelRatio(canvas.clientHeight);\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n    function updateColors(dt) {\n      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n      if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach(p => {\n          p.color = generateColor();\n        });\n      }\n    }\n    function applyInputs() {\n      pointers.forEach(p => {\n        if (p.moved) {\n          p.moved = false;\n          splatPointer(p);\n        }\n      });\n    }\n    function step(dt) {\n      gl.disable(gl.BLEND);\n      curlProgram.bind();\n      gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(curl);\n      vorticityProgram.bind();\n      gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n      blit(velocity.write);\n      velocity.swap();\n      divergenceProgram.bind();\n      gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(divergence);\n      clearProgram.bind();\n      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n      blit(pressure.write);\n      pressure.swap();\n      pressureProgram.bind();\n      gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write);\n        pressure.swap();\n      }\n      gradienSubtractProgram.bind();\n      gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n      gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n      blit(velocity.write);\n      velocity.swap();\n      advectionProgram.bind();\n      gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n      let velocityId = velocity.read.attach(0);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n      gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n      blit(velocity.write);\n      velocity.swap();\n      if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n      gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n      blit(dye.write);\n      dye.swap();\n    }\n    function render(target) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n      drawDisplay(target);\n    }\n    function drawDisplay(target) {\n      let width = target == null ? gl.drawingBufferWidth : target.width;\n      let height = target == null ? gl.drawingBufferHeight : target.height;\n      displayMaterial.bind();\n      if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n      blit(target);\n    }\n    function splatPointer(pointer) {\n      let dx = pointer.deltaX * config.SPLAT_FORCE;\n      let dy = pointer.deltaY * config.SPLAT_FORCE;\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n    }\n    function clickSplat(pointer) {\n      const color = generateColor();\n      color.r *= 10.0;\n      color.g *= 10.0;\n      color.b *= 10.0;\n      let dx = 10 * (Math.random() - 0.5);\n      let dy = 30 * (Math.random() - 0.5);\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n    }\n    function splat(x, y, dx, dy, color) {\n      splatProgram.bind();\n      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n      gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n      gl.uniform2f(splatProgram.uniforms.point, x, y);\n      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n      gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n      blit(velocity.write);\n      velocity.swap();\n      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n      blit(dye.write);\n      dye.swap();\n    }\n    function correctRadius(radius) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) radius *= aspectRatio;\n      return radius;\n    }\n    function updatePointerDownData(pointer, id, posX, posY) {\n      pointer.id = id;\n      pointer.down = true;\n      pointer.moved = false;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.deltaX = 0;\n      pointer.deltaY = 0;\n      pointer.color = generateColor();\n    }\n    function updatePointerMoveData(pointer, posX, posY, color) {\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n      pointer.color = color;\n    }\n    function updatePointerUpData(pointer) {\n      pointer.down = false;\n    }\n    function correctDeltaX(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio < 1) delta *= aspectRatio;\n      return delta;\n    }\n    function correctDeltaY(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) delta /= aspectRatio;\n      return delta;\n    }\n    function generateColor() {\n      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n      c.r *= 0.15;\n      c.g *= 0.15;\n      c.b *= 0.15;\n      return c;\n    }\n    function HSVtoRGB(h, s, v) {\n      let r, g, b, i, f, p, q, t;\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n        default:\n          break;\n      }\n      return {\n        r,\n        g,\n        b\n      };\n    }\n    function wrap(value, min, max) {\n      const range = max - min;\n      if (range === 0) return min;\n      return (value - min) % range + min;\n    }\n    function getResolution(resolution) {\n      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n      const min = Math.round(resolution);\n      const max = Math.round(resolution * aspectRatio);\n      if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n        width: max,\n        height: min\n      };else return {\n        width: min,\n        height: max\n      };\n    }\n    function scaleByPixelRatio(input) {\n      const pixelRatio = window.devicePixelRatio || 1;\n      return Math.floor(input * pixelRatio);\n    }\n    function hashCode(s) {\n      if (s.length === 0) return 0;\n      let hash = 0;\n      for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0;\n      }\n      return hash;\n    }\n    window.addEventListener('mousedown', e => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      updatePointerDownData(pointer, -1, posX, posY);\n      clickSplat(pointer);\n    });\n    document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = generateColor();\n      updateFrame();\n      updatePointerMoveData(pointer, posX, posY, color);\n      document.body.removeEventListener('mousemove', handleFirstMouseMove);\n    });\n    window.addEventListener('mousemove', e => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = pointer.color;\n      updatePointerMoveData(pointer, posX, posY, color);\n    });\n    document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updateFrame();\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n      document.body.removeEventListener('touchstart', handleFirstTouchStart);\n    });\n    window.addEventListener('touchstart', e => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n    });\n    window.addEventListener('touchmove', e => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerMoveData(pointer, posX, posY, pointer.color);\n      }\n    }, false);\n    window.addEventListener('touchend', e => {\n      const touches = e.changedTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        updatePointerUpData(pointer);\n      }\n    });\n    updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [SIM_RESOLUTION, DYE_RESOLUTION, CAPTURE_RESOLUTION, DENSITY_DISSIPATION, VELOCITY_DISSIPATION, PRESSURE, PRESSURE_ITERATIONS, CURL, SPLAT_RADIUS, SPLAT_FORCE, SHADING, COLOR_UPDATE_SPEED, BACK_COLOR, TRANSPARENT]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      zIndex: 50,\n      pointerEvents: 'none',\n      width: '100%',\n      height: '100%'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      id: \"fluid\",\n      style: {\n        width: '100vw',\n        height: '100vh',\n        display: 'block'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1195,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1184,\n    columnNumber: 5\n  }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nexport default SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");","map":{"version":3,"names":["_jsxFileName","_s","$RefreshSig$","useEffect","useRef","jsxDEV","_jsxDEV","SplashCursor","SIM_RESOLUTION","DYE_RESOLUTION","CAPTURE_RESOLUTION","DENSITY_DISSIPATION","VELOCITY_DISSIPATION","PRESSURE","PRESSURE_ITERATIONS","CURL","SPLAT_RADIUS","SPLAT_FORCE","SHADING","COLOR_UPDATE_SPEED","BACK_COLOR","r","g","b","TRANSPARENT","canvasRef","canvas","current","pointerPrototype","id","texcoordX","texcoordY","prevTexcoordX","prevTexcoordY","deltaX","deltaY","down","moved","color","config","PAUSED","pointers","gl","ext","getWebGLContext","supportLinearFiltering","params","alpha","depth","stencil","antialias","preserveDrawingBuffer","getContext","isWebGL2","halfFloat","getExtension","clearColor","halfFloatTexType","HALF_FLOAT","HALF_FLOAT_OES","formatRGBA","formatRG","formatR","getSupportedFormat","RGBA16F","RGBA","RG16F","RG","R16F","RED","internalFormat","format","type","supportRenderTextureFormat","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","fbo","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","status","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Material","constructor","vertexShader","fragmentShaderSource","programs","activeProgram","uniforms","setKeywords","keywords","hash","i","length","hashCode","program","fragmentShader","compileShader","FRAGMENT_SHADER","createProgram","getUniforms","bind","useProgram","Program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","console","trace","getProgramInfoLog","uniformCount","ACTIVE_UNIFORMS","uniformName","getActiveUniform","name","getUniformLocation","source","addKeywords","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","keywordsString","forEach","keyword","baseVertexShader","VERTEX_SHADER","copyShader","clearShader","displayShaderSource","splatShader","advectionShader","divergenceShader","curlShader","vorticityShader","pressureShader","gradientSubtractShader","blit","bindBuffer","ARRAY_BUFFER","createBuffer","bufferData","Float32Array","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","Uint16Array","vertexAttribPointer","FLOAT","enableVertexAttribArray","target","clear","viewport","drawingBufferWidth","drawingBufferHeight","width","height","COLOR_BUFFER_BIT","drawElements","TRIANGLES","UNSIGNED_SHORT","dye","velocity","divergence","curl","pressure","copyProgram","clearProgram","splatProgram","advectionProgram","divergenceProgram","curlProgram","vorticityProgram","pressureProgram","gradienSubtractProgram","displayMaterial","initFramebuffers","simRes","getResolution","dyeRes","texType","rgba","rg","filtering","LINEAR","disable","BLEND","createDoubleFBO","resizeDoubleFBO","createFBO","w","h","param","activeTexture","TEXTURE0","texelSizeX","texelSizeY","attach","fbo1","fbo2","read","value","write","swap","temp","resizeFBO","newFBO","uniform1i","uTexture","updateKeywords","displayKeywords","push","lastUpdateTime","Date","now","colorUpdateTimer","updateFrame","dt","calcDeltaTime","resizeCanvas","updateColors","applyInputs","step","render","requestAnimationFrame","Math","min","scaleByPixelRatio","clientWidth","clientHeight","wrap","p","generateColor","splatPointer","uniform2f","texelSize","uVelocity","uCurl","uniform1f","uDivergence","uPressure","dyeTexelSize","velocityId","uSource","dissipation","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","enable","drawDisplay","pointer","dx","dy","splat","clickSplat","random","x","y","uTarget","aspectRatio","point","uniform3f","radius","correctRadius","updatePointerDownData","posX","posY","updatePointerMoveData","correctDeltaX","correctDeltaY","abs","updatePointerUpData","delta","c","HSVtoRGB","s","v","f","q","t","floor","max","range","resolution","round","input","pixelRatio","window","devicePixelRatio","charCodeAt","addEventListener","e","clientX","clientY","document","body","handleFirstMouseMove","removeEventListener","handleFirstTouchStart","touches","targetTouches","identifier","changedTouches","style","position","top","left","zIndex","pointerEvents","children","ref","display","fileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/src/components/SplashCursor/SplashCursor.jsx"],"sourcesContent":["'use client';\nimport { useEffect, useRef } from 'react';\n\nfunction SplashCursor({\n  SIM_RESOLUTION = 128,\n  DYE_RESOLUTION = 1440,\n  CAPTURE_RESOLUTION = 512,\n  DENSITY_DISSIPATION = 3.5,\n  VELOCITY_DISSIPATION = 2,\n  PRESSURE = 0.1,\n  PRESSURE_ITERATIONS = 20,\n  CURL = 3,\n  SPLAT_RADIUS = 0.2,\n  SPLAT_FORCE = 6000,\n  SHADING = true,\n  COLOR_UPDATE_SPEED = 10,\n  BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n  TRANSPARENT = true\n}) {\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    function pointerPrototype() {\n      this.id = -1;\n      this.texcoordX = 0;\n      this.texcoordY = 0;\n      this.prevTexcoordX = 0;\n      this.prevTexcoordY = 0;\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.down = false;\n      this.moved = false;\n      this.color = [0, 0, 0];\n    }\n\n    let config = {\n      SIM_RESOLUTION,\n      DYE_RESOLUTION,\n      CAPTURE_RESOLUTION,\n      DENSITY_DISSIPATION,\n      VELOCITY_DISSIPATION,\n      PRESSURE,\n      PRESSURE_ITERATIONS,\n      CURL,\n      SPLAT_RADIUS,\n      SPLAT_FORCE,\n      SHADING,\n      COLOR_UPDATE_SPEED,\n      PAUSED: false,\n      BACK_COLOR,\n      TRANSPARENT,\n    };\n\n    let pointers = [new pointerPrototype()];\n\n    const { gl, ext } = getWebGLContext(canvas);\n    if (!ext.supportLinearFiltering) {\n      config.DYE_RESOLUTION = 256;\n      config.SHADING = false;\n    }\n\n    function getWebGLContext(canvas) {\n      const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false,\n      };\n      let gl = canvas.getContext('webgl2', params);\n      const isWebGL2 = !!gl;\n      if (!isWebGL2)\n        gl =\n          canvas.getContext('webgl', params) ||\n          canvas.getContext('experimental-webgl', params);\n\n      let halfFloat;\n      let supportLinearFiltering;\n      if (isWebGL2) {\n        gl.getExtension('EXT_color_buffer_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n      } else {\n        halfFloat = gl.getExtension('OES_texture_half_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n      const halfFloatTexType = isWebGL2\n        ? gl.HALF_FLOAT\n        : halfFloat && halfFloat.HALF_FLOAT_OES;\n      let formatRGBA;\n      let formatRG;\n      let formatR;\n\n      if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n      } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      }\n\n      return {\n        gl,\n        ext: {\n          formatRGBA,\n          formatRG,\n          formatR,\n          halfFloatTexType,\n          supportLinearFiltering,\n        },\n      };\n    }\n\n    function getSupportedFormat(gl, internalFormat, format, type) {\n      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch (internalFormat) {\n          case gl.R16F:\n            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n          case gl.RG16F:\n            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n          default:\n            return null;\n        }\n      }\n      return { internalFormat, format };\n    }\n\n    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        texture,\n        0\n      );\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      return status === gl.FRAMEBUFFER_COMPLETE;\n    }\n\n    class Material {\n      constructor(vertexShader, fragmentShaderSource) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n      }\n      setKeywords(keywords) {\n        let hash = 0;\n        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n          let fragmentShader = compileShader(\n            gl.FRAGMENT_SHADER,\n            this.fragmentShaderSource,\n            keywords\n          );\n          program = createProgram(this.vertexShader, fragmentShader);\n          this.programs[hash] = program;\n        }\n        if (program === this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n      }\n      bind() {\n        gl.useProgram(this.activeProgram);\n      }\n    }\n\n    class Program {\n      constructor(vertexShader, fragmentShader) {\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n      }\n      bind() {\n        gl.useProgram(this.program);\n      }\n    }\n\n    function createProgram(vertexShader, fragmentShader) {\n      let program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        console.trace(gl.getProgramInfoLog(program));\n      return program;\n    }\n\n    function getUniforms(program) {\n      let uniforms = [];\n      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n      }\n      return uniforms;\n    }\n\n    function compileShader(type, source, keywords) {\n      source = addKeywords(source, keywords);\n      const shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n        console.trace(gl.getShaderInfoLog(shader));\n      return shader;\n    }\n\n    function addKeywords(source, keywords) {\n      if (!keywords) return source;\n      let keywordsString = '';\n      keywords.forEach((keyword) => {\n        keywordsString += '#define ' + keyword + '\\n';\n      });\n      return keywordsString + source;\n    }\n\n    const baseVertexShader = compileShader(\n      gl.VERTEX_SHADER,\n      `\n        precision highp float;\n        attribute vec2 aPosition;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform vec2 texelSize;\n\n        void main () {\n            vUv = aPosition * 0.5 + 0.5;\n            vL = vUv - vec2(texelSize.x, 0.0);\n            vR = vUv + vec2(texelSize.x, 0.0);\n            vT = vUv + vec2(0.0, texelSize.y);\n            vB = vUv - vec2(0.0, texelSize.y);\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `\n    );\n\n    const copyShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n\n        void main () {\n            gl_FragColor = texture2D(uTexture, vUv);\n        }\n      `\n    );\n\n    const clearShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform float value;\n\n        void main () {\n            gl_FragColor = value * texture2D(uTexture, vUv);\n        }\n      `\n    );\n\n    const displayShaderSource = `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    `;\n\n    const splatShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uTarget;\n        uniform float aspectRatio;\n        uniform vec3 color;\n        uniform vec2 point;\n        uniform float radius;\n\n        void main () {\n            vec2 p = vUv - point.xy;\n            p.x *= aspectRatio;\n            vec3 splat = exp(-dot(p, p) / radius) * color;\n            vec3 base = texture2D(uTarget, vUv).xyz;\n            gl_FragColor = vec4(base + splat, 1.0);\n        }\n      `\n    );\n\n    const advectionShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uSource;\n        uniform vec2 texelSize;\n        uniform vec2 dyeTexelSize;\n        uniform float dt;\n        uniform float dissipation;\n\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n            vec2 st = uv / tsize - 0.5;\n            vec2 iuv = floor(st);\n            vec2 fuv = fract(st);\n\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n        }\n\n        void main () {\n            #ifdef MANUAL_FILTERING\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n            #else\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n                vec4 result = texture2D(uSource, coord);\n            #endif\n            float decay = 1.0 + dissipation * dt;\n            gl_FragColor = result / decay;\n        }\n      `,\n      ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']\n    );\n\n    const divergenceShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).x;\n            float R = texture2D(uVelocity, vR).x;\n            float T = texture2D(uVelocity, vT).y;\n            float B = texture2D(uVelocity, vB).y;\n\n            vec2 C = texture2D(uVelocity, vUv).xy;\n            if (vL.x < 0.0) { L = -C.x; }\n            if (vR.x > 1.0) { R = -C.x; }\n            if (vT.y > 1.0) { T = -C.y; }\n            if (vB.y < 0.0) { B = -C.y; }\n\n            float div = 0.5 * (R - L + T - B);\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n        }\n      `\n    );\n\n    const curlShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).y;\n            float R = texture2D(uVelocity, vR).y;\n            float T = texture2D(uVelocity, vT).x;\n            float B = texture2D(uVelocity, vB).x;\n            float vorticity = R - L - T + B;\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n        }\n      `\n    );\n\n    const vorticityShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uCurl;\n        uniform float curl;\n        uniform float dt;\n\n        void main () {\n            float L = texture2D(uCurl, vL).x;\n            float R = texture2D(uCurl, vR).x;\n            float T = texture2D(uCurl, vT).x;\n            float B = texture2D(uCurl, vB).x;\n            float C = texture2D(uCurl, vUv).x;\n\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n            force /= length(force) + 0.0001;\n            force *= curl * C;\n            force.y *= -1.0;\n\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity += force * dt;\n            velocity = min(max(velocity, -1000.0), 1000.0);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `\n    );\n\n    const pressureShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uDivergence;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            float C = texture2D(uPressure, vUv).x;\n            float divergence = texture2D(uDivergence, vUv).x;\n            float pressure = (L + R + B + T - divergence) * 0.25;\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n        }\n      `\n    );\n\n    const gradientSubtractShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity.xy -= vec2(R - L, T - B);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `\n    );\n\n    const blit = (() => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(\n        gl.ARRAY_BUFFER,\n        new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),\n        gl.STATIC_DRAW\n      );\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(\n        gl.ELEMENT_ARRAY_BUFFER,\n        new Uint16Array([0, 1, 2, 0, 2, 3]),\n        gl.STATIC_DRAW\n      );\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      return (target, clear = false) => {\n        if (target == null) {\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n          gl.viewport(0, 0, target.width, target.height);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      };\n    })();\n\n    let dye, velocity, divergence, curl, pressure;\n\n    const copyProgram = new Program(baseVertexShader, copyShader);\n    const clearProgram = new Program(baseVertexShader, clearShader);\n    const splatProgram = new Program(baseVertexShader, splatShader);\n    const advectionProgram = new Program(baseVertexShader, advectionShader);\n    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n    const curlProgram = new Program(baseVertexShader, curlShader);\n    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n    const pressureProgram = new Program(baseVertexShader, pressureShader);\n    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n\n    function initFramebuffers() {\n      let simRes = getResolution(config.SIM_RESOLUTION);\n      let dyeRes = getResolution(config.DYE_RESOLUTION);\n      const texType = ext.halfFloatTexType;\n      const rgba = ext.formatRGBA;\n      const rg = ext.formatRG;\n      const r = ext.formatR;\n      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n      gl.disable(gl.BLEND);\n\n      if (!dye)\n        dye = createDoubleFBO(\n          dyeRes.width,\n          dyeRes.height,\n          rgba.internalFormat,\n          rgba.format,\n          texType,\n          filtering\n        );\n      else\n        dye = resizeDoubleFBO(\n          dye,\n          dyeRes.width,\n          dyeRes.height,\n          rgba.internalFormat,\n          rgba.format,\n          texType,\n          filtering\n        );\n\n      if (!velocity)\n        velocity = createDoubleFBO(\n          simRes.width,\n          simRes.height,\n          rg.internalFormat,\n          rg.format,\n          texType,\n          filtering\n        );\n      else\n        velocity = resizeDoubleFBO(\n          velocity,\n          simRes.width,\n          simRes.height,\n          rg.internalFormat,\n          rg.format,\n          texType,\n          filtering\n        );\n\n      divergence = createFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST\n      );\n      curl = createFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST\n      );\n      pressure = createDoubleFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST\n      );\n    }\n\n    function createFBO(w, h, internalFormat, format, type, param) {\n      gl.activeTexture(gl.TEXTURE0);\n      let texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n      let fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        texture,\n        0\n      );\n      gl.viewport(0, 0, w, h);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      let texelSizeX = 1.0 / w;\n      let texelSizeY = 1.0 / h;\n      return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id) {\n          gl.activeTexture(gl.TEXTURE0 + id);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          return id;\n        },\n      };\n    }\n\n    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n      return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read() {\n          return fbo1;\n        },\n        set read(value) {\n          fbo1 = value;\n        },\n        get write() {\n          return fbo2;\n        },\n        set write(value) {\n          fbo2 = value;\n        },\n        swap() {\n          let temp = fbo1;\n          fbo1 = fbo2;\n          fbo2 = temp;\n        },\n      };\n    }\n\n    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n      copyProgram.bind();\n      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n      blit(newFBO);\n      return newFBO;\n    }\n\n    function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n      if (target.width === w && target.height === h) return target;\n      target.read = resizeFBO(\n        target.read,\n        w,\n        h,\n        internalFormat,\n        format,\n        type,\n        param\n      );\n      target.write = createFBO(w, h, internalFormat, format, type, param);\n      target.width = w;\n      target.height = h;\n      target.texelSizeX = 1.0 / w;\n      target.texelSizeY = 1.0 / h;\n      return target;\n    }\n\n    function updateKeywords() {\n      let displayKeywords = [];\n      if (config.SHADING) displayKeywords.push('SHADING');\n      displayMaterial.setKeywords(displayKeywords);\n    }\n\n    updateKeywords();\n    initFramebuffers();\n    let lastUpdateTime = Date.now();\n    let colorUpdateTimer = 0.0;\n\n    function updateFrame() {\n      const dt = calcDeltaTime();\n      if (resizeCanvas()) initFramebuffers();\n      updateColors(dt);\n      applyInputs();\n      step(dt);\n      render(null);\n      requestAnimationFrame(updateFrame);\n    }\n\n    function calcDeltaTime() {\n      let now = Date.now();\n      let dt = (now - lastUpdateTime) / 1000;\n      dt = Math.min(dt, 0.016666);\n      lastUpdateTime = now;\n      return dt;\n    }\n\n    function resizeCanvas() {\n      let width = scaleByPixelRatio(canvas.clientWidth);\n      let height = scaleByPixelRatio(canvas.clientHeight);\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n\n    function updateColors(dt) {\n      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n      if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach((p) => {\n          p.color = generateColor();\n        });\n      }\n    }\n\n    function applyInputs() {\n      pointers.forEach((p) => {\n        if (p.moved) {\n          p.moved = false;\n          splatPointer(p);\n        }\n      });\n    }\n\n    function step(dt) {\n      gl.disable(gl.BLEND);\n      curlProgram.bind();\n      gl.uniform2f(\n        curlProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(curl);\n\n      vorticityProgram.bind();\n      gl.uniform2f(\n        vorticityProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n      blit(velocity.write);\n      velocity.swap();\n\n      divergenceProgram.bind();\n      gl.uniform2f(\n        divergenceProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(divergence);\n\n      clearProgram.bind();\n      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n      blit(pressure.write);\n      pressure.swap();\n\n      pressureProgram.bind();\n      gl.uniform2f(\n        pressureProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write);\n        pressure.swap();\n      }\n\n      gradienSubtractProgram.bind();\n      gl.uniform2f(\n        gradienSubtractProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      gl.uniform1i(\n        gradienSubtractProgram.uniforms.uPressure,\n        pressure.read.attach(0)\n      );\n      gl.uniform1i(\n        gradienSubtractProgram.uniforms.uVelocity,\n        velocity.read.attach(1)\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      advectionProgram.bind();\n      gl.uniform2f(\n        advectionProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY\n      );\n      if (!ext.supportLinearFiltering)\n        gl.uniform2f(\n          advectionProgram.uniforms.dyeTexelSize,\n          velocity.texelSizeX,\n          velocity.texelSizeY\n        );\n      let velocityId = velocity.read.attach(0);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n      gl.uniform1f(\n        advectionProgram.uniforms.dissipation,\n        config.VELOCITY_DISSIPATION\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      if (!ext.supportLinearFiltering)\n        gl.uniform2f(\n          advectionProgram.uniforms.dyeTexelSize,\n          dye.texelSizeX,\n          dye.texelSizeY\n        );\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n      gl.uniform1f(\n        advectionProgram.uniforms.dissipation,\n        config.DENSITY_DISSIPATION\n      );\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function render(target) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n      drawDisplay(target);\n    }\n\n    function drawDisplay(target) {\n      let width = target == null ? gl.drawingBufferWidth : target.width;\n      let height = target == null ? gl.drawingBufferHeight : target.height;\n      displayMaterial.bind();\n      if (config.SHADING)\n        gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n      blit(target);\n    }\n\n    function splatPointer(pointer) {\n      let dx = pointer.deltaX * config.SPLAT_FORCE;\n      let dy = pointer.deltaY * config.SPLAT_FORCE;\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n    }\n\n    function clickSplat(pointer) {\n      const color = generateColor();\n      color.r *= 10.0;\n      color.g *= 10.0;\n      color.b *= 10.0;\n      let dx = 10 * (Math.random() - 0.5);\n      let dy = 30 * (Math.random() - 0.5);\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n    }\n\n    function splat(x, y, dx, dy, color) {\n      splatProgram.bind();\n      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n      gl.uniform1f(\n        splatProgram.uniforms.aspectRatio,\n        canvas.width / canvas.height\n      );\n      gl.uniform2f(splatProgram.uniforms.point, x, y);\n      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n      gl.uniform1f(\n        splatProgram.uniforms.radius,\n        correctRadius(config.SPLAT_RADIUS / 100.0)\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function correctRadius(radius) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) radius *= aspectRatio;\n      return radius;\n    }\n\n    function updatePointerDownData(pointer, id, posX, posY) {\n      pointer.id = id;\n      pointer.down = true;\n      pointer.moved = false;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.deltaX = 0;\n      pointer.deltaY = 0;\n      pointer.color = generateColor();\n    }\n\n    function updatePointerMoveData(pointer, posX, posY, color) {\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n      pointer.color = color;\n    }\n\n    function updatePointerUpData(pointer) {\n      pointer.down = false;\n    }\n\n    function correctDeltaX(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio < 1) delta *= aspectRatio;\n      return delta;\n    }\n\n    function correctDeltaY(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) delta /= aspectRatio;\n      return delta;\n    }\n\n    function generateColor() {\n      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n      c.r *= 0.15;\n      c.g *= 0.15;\n      c.b *= 0.15;\n      return c;\n    }\n\n    function HSVtoRGB(h, s, v) {\n      let r, g, b, i, f, p, q, t;\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n        default:\n          break;\n      }\n      return { r, g, b };\n    }\n\n    function wrap(value, min, max) {\n      const range = max - min;\n      if (range === 0) return min;\n      return ((value - min) % range) + min;\n    }\n\n    function getResolution(resolution) {\n      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n      const min = Math.round(resolution);\n      const max = Math.round(resolution * aspectRatio);\n      if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n        return { width: max, height: min };\n      else return { width: min, height: max };\n    }\n\n    function scaleByPixelRatio(input) {\n      const pixelRatio = window.devicePixelRatio || 1;\n      return Math.floor(input * pixelRatio);\n    }\n\n    function hashCode(s) {\n      if (s.length === 0) return 0;\n      let hash = 0;\n      for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0;\n      }\n      return hash;\n    }\n\n    window.addEventListener('mousedown', (e) => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      updatePointerDownData(pointer, -1, posX, posY);\n      clickSplat(pointer);\n    });\n\n    document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = generateColor();\n      updateFrame();\n      updatePointerMoveData(pointer, posX, posY, color);\n      document.body.removeEventListener('mousemove', handleFirstMouseMove);\n    });\n\n    window.addEventListener('mousemove', (e) => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = pointer.color;\n      updatePointerMoveData(pointer, posX, posY, color);\n    });\n\n    document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updateFrame();\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n      document.body.removeEventListener('touchstart', handleFirstTouchStart);\n    });\n\n    window.addEventListener('touchstart', (e) => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n    });\n\n    window.addEventListener(\n      'touchmove',\n      (e) => {\n        const touches = e.targetTouches;\n        let pointer = pointers[0];\n        for (let i = 0; i < touches.length; i++) {\n          let posX = scaleByPixelRatio(touches[i].clientX);\n          let posY = scaleByPixelRatio(touches[i].clientY);\n          updatePointerMoveData(pointer, posX, posY, pointer.color);\n        }\n      },\n      false\n    );\n\n    window.addEventListener('touchend', (e) => {\n      const touches = e.changedTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        updatePointerUpData(pointer);\n      }\n    });\n\n    updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    SIM_RESOLUTION,\n    DYE_RESOLUTION,\n    CAPTURE_RESOLUTION,\n    DENSITY_DISSIPATION,\n    VELOCITY_DISSIPATION,\n    PRESSURE,\n    PRESSURE_ITERATIONS,\n    CURL,\n    SPLAT_RADIUS,\n    SPLAT_FORCE,\n    SHADING,\n    COLOR_UPDATE_SPEED,\n    BACK_COLOR,\n    TRANSPARENT,\n  ]);\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        zIndex: 50,\n        pointerEvents: 'none',\n        width: '100%',\n        height: '100%',\n      }}\n    >\n      <canvas\n        ref={canvasRef}\n        id=\"fluid\"\n        style={{\n          width: '100vw',\n          height: '100vh',\n          display: 'block',\n        }}\n      />\n    </div>\n  );\n}\n\nexport default SplashCursor;\n"],"mappings":"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AC+F,gBAAgB,CAACL,MAAM,CAAC,CAAC;MAC5C,OAAOA,MAAM;IACf;IAEA,SAASD,WAAWA,CAACD,MAAM,EAAE3B,QAAQ,EAAE;MACrC,IAAI,CAACA,QAAQ,EAAE,OAAO2B,MAAM;MAC5B,IAAIQ,cAAc,GAAG,EAAE;MACvBnC,QAAQ,CAACoC,OAAO,CAAEC,OAAO,IAAK;QAC5BF,cAAc,IAAI,UAAU,GAAGE,OAAO,GAAG,IAAI;MAC/C,CAAC,CAAC;MACF,OAAOF,cAAc,GAAGR,MAAM;IAChC;IAEA,MAAMW,gBAAgB,GAAG/B,aAAa,CACpCpE,EAAE,CAACoG,aAAa,EAChB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMC,UAAU,GAAGjC,aAAa,CAC9BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMiC,WAAW,GAAGlC,aAAa,CAC/BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMkC,mBAAmB,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;IAED,MAAMC,WAAW,GAAGpC,aAAa,CAC/BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMoC,eAAe,GAAGrC,aAAa,CACnCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EACDpE,GAAG,CAACE,sBAAsB,GAAG,IAAI,GAAG,CAAC,kBAAkB,CACzD,CAAC;IAED,MAAMuG,gBAAgB,GAAGtC,aAAa,CACpCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMsC,UAAU,GAAGvC,aAAa,CAC9BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMuC,eAAe,GAAGxC,aAAa,CACnCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMwC,cAAc,GAAGzC,aAAa,CAClCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMyC,sBAAsB,GAAG1C,aAAa,CAC1CpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAM0C,IAAI,GAAG,CAAC,MAAM;MAClB/G,EAAE,CAACgH,UAAU,CAAChH,EAAE,CAACiH,YAAY,EAAEjH,EAAE,CAACkH,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","ignoreList":[]},"metadata":{},"sourceType":"module"}