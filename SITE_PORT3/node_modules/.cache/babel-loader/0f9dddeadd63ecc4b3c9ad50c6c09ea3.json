{"ast":null,"code":"import { Vector3, Color, Vector2, Matrix3 } from 'three';\nconst OBJExporter = () => {};\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function (object) {\n    let output = '';\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let i;\n    let j;\n    let k;\n    let l;\n    let m;\n    const face = [];\n    const parseMesh = mesh => {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n      const vertices = geometry.getAttribute('position');\n      const normals = geometry.getAttribute('normal');\n      const uvs = geometry.getAttribute('uv');\n      const indices = geometry.getIndex(); // name of the mesh object\n\n      output += `o ${mesh.name}\\n`; // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += `usemtl ${mesh.material.name}\\n`;\n      } // vertices\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      } // uvs\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += `vt ${uv.x} ${uv.y}\\n`;\n        }\n      } // normals\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += `vn ${normal.x} ${normal.y} ${normal.z}\\n`;\n        }\n      } // faces\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } // update index\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n    const parseLine = line => {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n      const vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += `o ${line.name}\\n`;\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      }\n      if (type === 'Line') {\n        output += 'l ';\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += `${indexVertex + j} `;\n        }\n        output += '\\n';\n      }\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += `l ${indexVertex + j} ${indexVertex + k}\\n`;\n        }\n      } // update index\n\n      indexVertex += nbVertex;\n    };\n    const parsePoints = points => {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      const vertices = geometry.getAttribute('position');\n      const colors = geometry.getAttribute('color');\n      output += `o ${points.name}\\n`;\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}`;\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += ` ${color.r} ${color.g} ${color.b}`;\n          }\n          output += '\\n';\n        }\n      }\n      output += 'p ';\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += `${indexVertex + j} `;\n      }\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\nexport { OBJExporter };","map":{"version":3,"names":["Vector3","Color","Vector2","Matrix3","OBJExporter","prototype","constructor","parse","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","i","j","k","l","m","face","parseMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","join","parseLine","line","type","parsePoints","points","colors","fromBufferAttribute","r","g","b","traverse","child","isMesh","isLine","isPoints"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/OBJExporter.js"],"sourcesContent":["import { Vector3, Color, Vector2, Matrix3 } from 'three';\n\nconst OBJExporter = () => {};\n\nOBJExporter.prototype = {\n  constructor: OBJExporter,\n  parse: function (object) {\n    let output = '';\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let i;\n    let j;\n    let k;\n    let l;\n    let m;\n    const face = [];\n\n    const parseMesh = mesh => {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position');\n      const normals = geometry.getAttribute('normal');\n      const uvs = geometry.getAttribute('uv');\n      const indices = geometry.getIndex(); // name of the mesh object\n\n      output += `o ${mesh.name}\\n`; // name of the mesh material\n\n      if (mesh.material && mesh.material.name) {\n        output += `usemtl ${mesh.material.name}\\n`;\n      } // vertices\n\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      } // uvs\n\n\n      if (uvs !== undefined) {\n        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.x = uvs.getX(i);\n          uv.y = uvs.getY(i); // transform the uv to export format\n\n          output += `vt ${uv.x} ${uv.y}\\n`;\n        }\n      } // normals\n\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.x = normals.getX(i);\n          normal.y = normals.getY(i);\n          normal.z = normals.getZ(i); // transform the normal to world space\n\n          normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          output += `vn ${normal.x} ${normal.y} ${normal.z}\\n`;\n        }\n      } // faces\n\n\n      if (indices !== null) {\n        for (i = 0, l = indices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } else {\n        for (i = 0, l = vertices.count; i < l; i += 3) {\n          for (m = 0; m < 3; m++) {\n            j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? `/${uvs ? indexVertexUvs + j : ''}${normals ? `/${indexNormals + j}` : ''}` : '');\n          } // transform the face to export format\n\n\n          output += `f ${face.join(' ')}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    const parseLine = line => {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n\n      const vertices = geometry.getAttribute('position'); // name of the line object\n\n      output += `o ${line.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}\\n`;\n        }\n      }\n\n      if (type === 'Line') {\n        output += 'l ';\n\n        for (j = 1, l = vertices.count; j <= l; j++) {\n          output += `${indexVertex + j} `;\n        }\n\n        output += '\\n';\n      }\n\n      if (type === 'LineSegments') {\n        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += `l ${indexVertex + j} ${indexVertex + k}\\n`;\n        }\n      } // update index\n\n\n      indexVertex += nbVertex;\n    };\n\n    const parsePoints = points => {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const vertices = geometry.getAttribute('position');\n      const colors = geometry.getAttribute('color');\n      output += `o ${points.name}\\n`;\n\n      if (vertices !== undefined) {\n        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += `v ${vertex.x} ${vertex.y} ${vertex.z}`;\n\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            output += ` ${color.r} ${color.g} ${color.b}`;\n          }\n\n          output += '\\n';\n        }\n      }\n\n      output += 'p ';\n\n      for (j = 1, l = vertices.count; j <= l; j++) {\n        output += `${indexVertex + j} `;\n      }\n\n      output += '\\n'; // update index\n\n      indexVertex += nbVertex;\n    };\n\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n};\n\nexport { OBJExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}