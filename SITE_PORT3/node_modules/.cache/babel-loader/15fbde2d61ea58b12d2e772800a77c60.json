{"ast":null,"code":"import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read } from 'ktx-parse';\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nvar DFDModel = {\n  ETC1S: 163,\n  UASTC: 166\n};\nvar DFDChannel = {\n  ETC1S: {\n    RGB: 0,\n    RRR: 3,\n    GGG: 4,\n    AAA: 15\n  },\n  UASTC: {\n    RGB: 0,\n    RGBA: 3,\n    RRR: 4,\n    RRRG: 5\n  }\n};\nvar SupercompressionScheme = {\n  ZSTD: 2\n};\nvar Transfer = {\n  SRGB: 2\n}; //\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === DFDModel.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n}\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n    for (let levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n      if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === DFDModel.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === DFDChannel.UASTC.RGBA) {\n        return true;\n      }\n      return false;\n    } // ETC1S\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === DFDChannel.ETC1S.AAA) {\n      return true;\n    }\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & 1);\n  }\n};\nexport { KTX2Loader };","map":{"version":3,"names":["CompressedTextureLoader","CompressedTexture","FileLoader","sRGBEncoding","LinearEncoding","BasisTextureLoader","ZSTDDecoder","read","DFDModel","ETC1S","UASTC","DFDChannel","RGB","RRR","GGG","AAA","RGBA","RRRG","SupercompressionScheme","ZSTD","Transfer","SRGB","KTX2Loader","constructor","manager","basisLoader","zstd","init","MSC_TRANSCODER","console","warn","setTranscoderPath","path","setWorkerLimit","detectSupport","renderer","dispose","load","url","onLoad","onProgress","onError","scope","texture","bufferPending","Promise","resolve","reject","setPath","setResponseType","then","buffer","parse","_texture","copy","needsUpdate","catch","ktx","Uint8Array","pixelDepth","Error","layerCount","faceCount","dfd","KTX2Utils","getBasicDFD","createLevels","levels","basisFormat","colorModel","BasisFormat","UASTC_4x4","parseConfig","width","pixelWidth","height","pixelHeight","hasAlpha","getAlpha","globalData","parseInternalAsync","encoding","transferFunction","premultiplyAlpha","getPremultiplyAlpha","supercompressionScheme","levelIndex","length","levelWidth","Math","max","floor","pow","levelHeight","levelData","decode","uncompressedByteLength","push","index","data","dataFormatDescriptor","samples","channelID","flags"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/KTX2Loader.js"],"sourcesContent":["import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read } from 'ktx-parse';\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nvar DFDModel = {\n  ETC1S: 163,\n  UASTC: 166\n};\nvar DFDChannel = {\n  ETC1S: {\n    RGB: 0,\n    RRR: 3,\n    GGG: 4,\n    AAA: 15\n  },\n  UASTC: {\n    RGB: 0,\n    RGBA: 3,\n    RRR: 4,\n    RRRG: 5\n  }\n};\nvar SupercompressionScheme = {\n  ZSTD: 2\n};\nvar Transfer = {\n  SRGB: 2\n}; //\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === DFDModel.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n\n    for (let levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n\n      if (ktx.supercompressionScheme === SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === DFDModel.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === DFDChannel.UASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === DFDChannel.ETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & 1);\n  }\n};\n\nexport { KTX2Loader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}