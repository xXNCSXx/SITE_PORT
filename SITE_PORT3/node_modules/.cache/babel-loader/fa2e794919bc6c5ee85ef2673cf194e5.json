{"ast":null,"code":"import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes);\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexport function expandCategories(tokenTypes) {\n  var result = cloneArr(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n  while (searching) {\n    categories = compact(flatten(map(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    }\n    // CATEGORIES? : TokenType | TokenType[]\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES)\n    // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexport function hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}","map":{"version":3,"sources":["../../../src/scan/tokens.ts"],"names":[],"mappings":"AAAA,SACE,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,UAAU,EACV,OAAO,EACP,OAAO,EACP,GAAG,EACH,OAAO,EACP,OAAO,EACP,GAAG,QACE,gBAAgB;AAGvB,OAAM,SAAU,sBAAsB,CAAC,WAAW,EAAE,cAAc,EAAA;EAChE,IAAM,YAAY,GAAG,WAAW,CAAC,YAAY;EAC7C,IAAI,YAAY,KAAK,cAAc,CAAC,YAAY,EAAE;IAChD,OAAO,IAAI;GACZ,MAAM;IACL,OACE,cAAc,CAAC,QAAQ,KAAK,IAAI,IAChC,cAAc,CAAC,kBAAkB,CAAC,YAAY,CAAC,KAAK,IAAI;EAE3D;AACH;AAEA;AACA;AACA,OAAM,SAAU,kCAAkC,CAAC,KAAK,EAAE,OAAO,EAAA;EAC/D,OAAO,KAAK,CAAC,YAAY,KAAK,OAAO,CAAC,YAAY;AACpD;AAEA,OAAO,IAAI,iBAAiB,GAAG,CAAC;AAChC,OAAO,IAAM,eAAe,GAAG,CAAA,CAAE;AAEjC,OAAM,SAAU,iBAAiB,CAAC,UAAuB,EAAA;EACvD;EACA,IAAI,oBAAoB,GAAG,gBAAgB,CAAC,UAAU,CAAC;EAEvD;EACA,uBAAuB,CAAC,oBAAoB,CAAC;EAE7C;EACA,uBAAuB,CAAC,oBAAoB,CAAC;EAC7C,0BAA0B,CAAC,oBAAoB,CAAC;EAEhD,OAAO,CAAC,oBAAoB,EAAE,UAAC,OAAO,EAAA;IACpC,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC;EACvD,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,gBAAgB,CAAC,UAAuB,EAAA;EACtD,IAAI,MAAM,GAAG,QAAQ,CAAC,UAAU,CAAC;EAEjC,IAAI,UAAU,GAAG,UAAU;EAC3B,IAAI,SAAS,GAAG,IAAI;EACpB,OAAO,SAAS,EAAE;IAChB,UAAU,GAAG,OAAO,CAClB,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,UAAC,WAAW,EAAA;MAAK,OAAA,WAAW,CAAC,UAAU;IAAtB,CAAsB,CAAC,CAAC,CAClE;IAED,IAAI,aAAa,GAAG,UAAU,CAAC,UAAU,EAAE,MAAM,CAAC;IAElD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;IAErC,IAAI,OAAO,CAAC,aAAa,CAAC,EAAE;MAC1B,SAAS,GAAG,KAAK;KAClB,MAAM;MACL,UAAU,GAAG,aAAa;IAC3B;EACF;EACD,OAAO,MAAM;AACf;AAEA,OAAM,SAAU,uBAAuB,CAAC,UAAuB,EAAA;EAC7D,OAAO,CAAC,UAAU,EAAE,UAAC,WAAW,EAAA;IAC9B,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE;MACrC,eAAe,CAAC,iBAAiB,CAAC,GAAG,WAAW;MACzC,WAAY,CAAC,YAAY,GAAG,iBAAiB,EAAE;IACvD;IAED;IACA,IACE,qBAAqB,CAAC,WAAW,CAAC,IAClC,CAAC,OAAO,CAAC,WAAW,CAAC,UAAU;IAC/B;IACA;IAAA,EACA;MACA,WAAW,CAAC,UAAU,GAAG,CAAC,WAAW,CAAC,UAAU,CAAC;IAClD;IAED,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,EAAE;MACvC,WAAW,CAAC,UAAU,GAAG,EAAE;IAC5B;IAED,IAAI,CAAC,+BAA+B,CAAC,WAAW,CAAC,EAAE;MACjD,WAAW,CAAC,eAAe,GAAG,EAAE;IACjC;IAED,IAAI,CAAC,kCAAkC,CAAC,WAAW,CAAC,EAAE;MACpD,WAAW,CAAC,kBAAkB,GAAG,CAAA,CAAE;IACpC;EACH,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,0BAA0B,CAAC,UAAuB,EAAA;EAChE,OAAO,CAAC,UAAU,EAAE,UAAC,WAAW,EAAA;IAC9B;IACA,WAAW,CAAC,eAAe,GAAG,EAAE;IAChC,OAAO,CAAC,WAAW,CAAC,kBAAkB,EAAE,UAAC,GAAG,EAAE,GAAG,EAAA;MAC/C,WAAW,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC;IACrE,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,uBAAuB,CAAC,UAAuB,EAAA;EAC7D,OAAO,CAAC,UAAU,EAAE,UAAC,WAAW,EAAA;IAC9B,6BAA6B,CAAC,EAAE,EAAE,WAAW,CAAC;EAChD,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,6BAA6B,CAC3C,IAAiB,EACjB,QAAmB,EAAA;EAEnB,OAAO,CAAC,IAAI,EAAE,UAAC,QAAQ,EAAA;IACrB,QAAQ,CAAC,kBAAkB,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,IAAI;EAC3D,CAAC,CAAC;EAEF,OAAO,CAAC,QAAQ,CAAC,UAAU,EAAE,UAAC,YAAY,EAAA;IACxC,IAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;IACrC;IACA,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,YAAY,CAAC,EAAE;MACpC,6BAA6B,CAAC,OAAO,EAAE,YAAY,CAAC;IACrD;EACH,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,mBAAmB,CAAC,OAAkB,EAAA;EACpD,OAAO,GAAG,CAAC,OAAO,EAAE,cAAc,CAAC;AACrC;AAEA,OAAM,SAAU,qBAAqB,CAAC,OAAkB,EAAA;EACtD,OAAO,GAAG,CAAC,OAAO,EAAE,YAAY,CAAC;AACnC;AAEA,OAAM,SAAU,+BAA+B,CAAC,OAAkB,EAAA;EAChE,OAAO,GAAG,CAAC,OAAO,EAAE,iBAAiB,CAAC;AACxC;AAEA,OAAM,SAAU,kCAAkC,CAChD,OAAkB,EAAA;EAElB,OAAO,GAAG,CAAC,OAAO,EAAE,oBAAoB,CAAC;AAC3C;AAEA,OAAM,SAAU,WAAW,CAAC,OAAkB,EAAA;EAC5C,OAAO,GAAG,CAAC,OAAO,EAAE,cAAc,CAAC;AACrC","sourceRoot":"","sourcesContent":["import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    var result = cloneArr(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!contains(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map"]},"metadata":{},"sourceType":"module"}