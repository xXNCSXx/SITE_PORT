{"ast":null,"code":"import { WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending, Vector2, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\nvar BloomPass = function (strength, kernelSize, sigma, resolution) {\n  strength = strength !== undefined ? strength : 1;\n  kernelSize = kernelSize !== undefined ? kernelSize : 25;\n  sigma = sigma !== undefined ? sigma : 4.0;\n  resolution = resolution !== undefined ? resolution : 256; // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetX.texture.name = 'BloomPass.x';\n  this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetY.texture.name = 'BloomPass.y'; // copy material\n\n  if (CopyShader === undefined) console.error('THREE.BloomPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = strength;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    transparent: true\n  }); // convolution material\n\n  if (ConvolutionShader === undefined) console.error('THREE.BloomPass relies on ConvolutionShader');\n  var convolutionShader = ConvolutionShader;\n  this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n  this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n  this.convolutionUniforms['cKernel'].value = ConvolutionShader.buildKernel(sigma);\n  this.materialConvolution = new ShaderMaterial({\n    uniforms: this.convolutionUniforms,\n    vertexShader: convolutionShader.vertexShader,\n    fragmentShader: convolutionShader.fragmentShader,\n    defines: {\n      KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n      KERNEL_SIZE_INT: kernelSize.toFixed(0)\n    }\n  });\n  this.needsSwap = false;\n  this.fsQuad = new FullScreenQuad(null);\n};\nBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: BloomPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)\n\n    this.fsQuad.material = this.materialConvolution;\n    this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n    renderer.setRenderTarget(this.renderTargetX);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)\n\n    this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurY;\n    renderer.setRenderTarget(this.renderTargetY);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetY.texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    this.fsQuad.render(renderer);\n  }\n});\nBloomPass.blurX = new Vector2(0.001953125, 0.0);\nBloomPass.blurY = new Vector2(0.0, 0.001953125);\nexport { BloomPass };","map":{"version":3,"names":["WebGLRenderTarget","UniformsUtils","ShaderMaterial","AdditiveBlending","Vector2","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","ConvolutionShader","BloomPass","strength","kernelSize","sigma","resolution","undefined","pars","minFilter","magFilter","format","renderTargetX","texture","name","renderTargetY","console","error","copyShader","copyUniforms","clone","uniforms","value","materialCopy","vertexShader","fragmentShader","blending","transparent","convolutionShader","convolutionUniforms","blurX","buildKernel","materialConvolution","defines","KERNEL_SIZE_FLOAT","toFixed","KERNEL_SIZE_INT","needsSwap","fsQuad","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","state","buffers","stencil","setTest","material","setRenderTarget","clear","blurY"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/postprocessing/BloomPass.js"],"sourcesContent":["import { WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending, Vector2, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\n\nvar BloomPass = function (strength, kernelSize, sigma, resolution) {\n  strength = strength !== undefined ? strength : 1;\n  kernelSize = kernelSize !== undefined ? kernelSize : 25;\n  sigma = sigma !== undefined ? sigma : 4.0;\n  resolution = resolution !== undefined ? resolution : 256; // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetX.texture.name = 'BloomPass.x';\n  this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);\n  this.renderTargetY.texture.name = 'BloomPass.y'; // copy material\n\n  if (CopyShader === undefined) console.error('THREE.BloomPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = strength;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    transparent: true\n  }); // convolution material\n\n  if (ConvolutionShader === undefined) console.error('THREE.BloomPass relies on ConvolutionShader');\n  var convolutionShader = ConvolutionShader;\n  this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n  this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n  this.convolutionUniforms['cKernel'].value = ConvolutionShader.buildKernel(sigma);\n  this.materialConvolution = new ShaderMaterial({\n    uniforms: this.convolutionUniforms,\n    vertexShader: convolutionShader.vertexShader,\n    fragmentShader: convolutionShader.fragmentShader,\n    defines: {\n      KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n      KERNEL_SIZE_INT: kernelSize.toFixed(0)\n    }\n  });\n  this.needsSwap = false;\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: BloomPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)\n\n    this.fsQuad.material = this.materialConvolution;\n    this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n    renderer.setRenderTarget(this.renderTargetX);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)\n\n    this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurY;\n    renderer.setRenderTarget(this.renderTargetY);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetY.texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    this.fsQuad.render(renderer);\n  }\n});\nBloomPass.blurX = new Vector2(0.001953125, 0.0);\nBloomPass.blurY = new Vector2(0.0, 0.001953125);\n\nexport { BloomPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}