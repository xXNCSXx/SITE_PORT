{"ast":null,"code":"import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, has } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */function () {\n  function ErrorHandler() {}\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = has(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  };\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    get: function () {\n      return cloneArr(this._errors);\n    },\n    set: function (newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // TODO: consider caching the error message computed information\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  };\n  // TODO: consider caching the error message computed information\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n  return ErrorHandler;\n}();\nexport { ErrorHandler };","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/error_handler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, has } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        get: function () {\n            return cloneArr(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\nexport { ErrorHandler };\n//# sourceMappingURL=error_handler.js.map"]},"metadata":{},"sourceType":"module"}