{"ast":null,"code":"import { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, DoubleSide, BufferAttribute, MathUtils, InterpolateDiscrete, Matrix4, Scene, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\nconst GLTFExporter = (() => {\n  function GLTFExporter() {\n    this.pluginCallbacks = [];\n    this.register(writer => new GLTFLightExtension(writer));\n    this.register(writer => new GLTFMaterialsUnlitExtension(writer));\n    this.register(writer => new GLTFMaterialsPBRSpecularGlossiness(writer));\n  }\n  GLTFExporter.prototype = {\n    constructor: GLTFExporter,\n    register: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    },\n    unregister: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    },\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    parse: function (input, onDone, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n  }; //------------------------------------------------------------------------------\n  // Constants\n  //------------------------------------------------------------------------------\n\n  const WEBGL_CONSTANTS = {\n    POINTS: 0x0000,\n    LINES: 0x0001,\n    LINE_LOOP: 0x0002,\n    LINE_STRIP: 0x0003,\n    TRIANGLES: 0x0004,\n    TRIANGLE_STRIP: 0x0005,\n    TRIANGLE_FAN: 0x0006,\n    UNSIGNED_BYTE: 0x1401,\n    UNSIGNED_SHORT: 0x1403,\n    FLOAT: 0x1406,\n    UNSIGNED_INT: 0x1405,\n    ARRAY_BUFFER: 0x8892,\n    ELEMENT_ARRAY_BUFFER: 0x8893,\n    NEAREST: 0x2600,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_NEAREST: 0x2700,\n    LINEAR_MIPMAP_NEAREST: 0x2701,\n    NEAREST_MIPMAP_LINEAR: 0x2702,\n    LINEAR_MIPMAP_LINEAR: 0x2703,\n    CLAMP_TO_EDGE: 33071,\n    MIRRORED_REPEAT: 33648,\n    REPEAT: 10497\n  };\n  const THREE_TO_WEBGL = {};\n  THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\n  THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\n  THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n  THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\n  THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n  const PATH_PROPERTIES = {\n    scale: 'scale',\n    position: 'translation',\n    quaternion: 'rotation',\n    morphTargetInfluences: 'weights'\n  }; // GLB constants\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n  const GLB_HEADER_BYTES = 12;\n  const GLB_HEADER_MAGIC = 0x46546c67;\n  const GLB_VERSION = 2;\n  const GLB_CHUNK_PREFIX_BYTES = 8;\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  const GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n  function equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every((element, index) => element === array2[index]);\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n  function stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n    return array.buffer;\n  }\n  /**\n   * Is identity matrix\n   *\n   * @param {Matrix4} matrix\n   * @returns {Boolean} Returns true, if parameter is identity matrix\n   */\n\n  function isIdentityMatrix(matrix) {\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n  /**\n   * Get the min and max vectors from the given attribute\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n   * @param  {Integer} start\n   * @param  {Integer} count\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n   */\n\n  function getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n        output.min[a] = Math.min(output.min[a], value);\n        output.max[a] = Math.max(output.max[a], value);\n      }\n    }\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   *\n   * @param {Integer} bufferSize The size the original buffer.\n   * @returns {Integer} new buffer size with required padding.\n   *\n   */\n\n  function getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n    paddingByte = paddingByte || 0;\n    const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n      return array.buffer;\n    }\n    return arrayBuffer;\n  }\n  let cachedCanvas = null;\n  /**\n   * Writer\n   */\n\n  function GLTFWriter() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n  GLTFWriter.prototype = {\n    constructor: GLTFWriter,\n    setPlugins: function (plugins) {\n      this.plugins = plugins;\n    },\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    write: function (input, onDone, options) {\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n      if (this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n      this.processInput(input);\n      const writer = this;\n      Promise.all(this.pending).then(() => {\n        const buffers = writer.buffers;\n        const json = writer.json;\n        const options = writer.options;\n        const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        const blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        const extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n        if (options.binary === true) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n          reader.onloadend = () => {\n            // Binary chunk.\n            const binaryChunk = getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n            glbReader.onloadend = () => {\n              onDone(glbReader.result);\n            };\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var reader = new window.FileReader();\n            reader.readAsDataURL(blob);\n            reader.onloadend = () => {\n              const base64data = reader.result;\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    },\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n    serializeUserData: function (object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      const options = this.options;\n      const extensionsUsed = this.extensionsUsed;\n      try {\n        const json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n          for (let extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(`THREE.GLTFExporter: userData of '${object.name}' won't be serialized because of JSON.stringify error - ${error.message}`);\n      }\n    },\n    /**\n     * Assign and return a temporal unique id for an object\n     * especially which doesn't have .uuid\n     * @param  {Object} object\n     * @return {Integer}\n     */\n    getUID: function (object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    },\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n    isNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      const v = new Vector3();\n      for (let i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n      return true;\n    },\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n    createNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      const attribute = normal.clone();\n      const v = new Vector3();\n      for (let i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    },\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n    applyTextureTransform: function (mapDef, texture) {\n      let didTransform = false;\n      const transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    },\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n    processBuffer: function (buffer) {\n      const json = this.json;\n      const buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    },\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n    processBufferView: function (attribute, componentType, start, count, target) {\n      const json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      let componentSize;\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n      const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      const dataView = new DataView(new ArrayBuffer(byteLength));\n      let offset = 0;\n      for (let i = start; i < start + count; i++) {\n        for (let a = 0; a < attribute.itemSize; a++) {\n          let value;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n          offset += componentSize;\n        }\n      }\n      const bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      const output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    },\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n    processBufferViewImage: function (blob) {\n      const writer = this;\n      const json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(resolve => {\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = () => {\n          const buffer = getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    },\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n    processAccessor: function (attribute, geometry, start, count) {\n      const options = this.options;\n      const json = this.json;\n      const types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        const end = start + count;\n        const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n      if (count === 0) return null;\n      const minMax = getMinMax(attribute, start, count);\n      let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType,\n        count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    },\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n     * @param  {Boolean} flipY before writing out the image\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n    processImage: function (image, format, flipY) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      const key = `${mimeType}:flipY/${flipY.toString()}`;\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType\n      };\n      if (options.embedImages) {\n        const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        const ctx = canvas.getContext('2d');\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat && format !== RGBFormat) {\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n          let data = image.data;\n          if (format === RGBFormat) {\n            data = new Uint8ClampedArray(image.height * image.width * 4);\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n        if (options.binary === true) {\n          pending.push(new Promise(resolve => {\n            canvas.toBlob(blob => {\n              writer.processBufferViewImage(blob).then(bufferViewIndex => {\n                imageDef.bufferView = bufferViewIndex;\n                resolve();\n              });\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else {\n        imageDef.uri = image.src;\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    },\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n    processSampler: function (map) {\n      const json = this.json;\n      if (!json.samplers) json.samplers = [];\n      const samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    },\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n    processTexture: function (map) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      const textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(ext => {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      const index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    },\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n    processMaterial: function (material) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      const materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      } // pbrMetallicRoughness.baseColorFactor\n\n      const color = material.color.toArray().concat([material.opacity]);\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n      if (material.metalnessMap || material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap) {\n          const metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n      if (material.map) {\n        const baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if (material.emissive) {\n        // emissiveFactor\n        const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n        if (!equalArray(emissive, [0, 0, 0])) {\n          materialDef.emissiveFactor = emissive;\n        } // emissiveTexture\n\n        if (material.emissiveMap) {\n          const emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n      if (material.normalMap) {\n        const normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n        if (material.normalScale && material.normalScale.x !== -1) {\n          if (material.normalScale.x !== material.normalScale.y) {\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n          }\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n      if (material.aoMap) {\n        const occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(ext => {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      const index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    },\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n    processMesh: function (mesh) {\n      const cache = this.cache;\n      const json = this.json;\n      const meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (let i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      const meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      const geometry = mesh.geometry;\n      let mode; // Use the correct mode\n\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      const meshDef = {};\n      const attributes = {};\n      const primitives = [];\n      const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      const nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      const originalNormal = geometry.getAttribute('normal');\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n      let modifiedAttribute = null;\n      for (let attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = `_${attributeName}`;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n        modifiedAttribute = null;\n        const array = attribute.array;\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor !== null) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        const weights = [];\n        const targetNames = [];\n        const reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (let key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n          const target = {};\n          let warned = false;\n          for (let attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (attributeName !== 'position' && attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n              continue;\n            }\n            var attribute = geometry.morphAttributes[attributeName][i];\n            const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            const baseAttribute = geometry.attributes[attributeName];\n            if (cache.attributes.has(this.getUID(attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n              continue;\n            } // Clones attribute not to override\n\n            const relativeAttribute = attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (let j = 0, jl = attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[i]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      const isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      const materials = isMultiMaterial ? mesh.material : [mesh.material];\n      const groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n      for (let i = 0, il = groups.length; i < il; i++) {\n        const primitive = {\n          mode,\n          attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          let cacheKey = this.getUID(geometry.index);\n          if (groups[i].start !== undefined || groups[i].count !== undefined) {\n            cacheKey += `:${groups[i].start}:${groups[i].count}`;\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        const material = this.processMaterial(materials[groups[i].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(ext => {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      const index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    },\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n    processCamera: function (camera) {\n      const json = this.json;\n      if (!json.cameras) json.cameras = [];\n      const isOrtho = camera.isOrthographicCamera;\n      const cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    },\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n    processAnimation: function (clip, root) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      const tracks = clip.tracks;\n      const channels = [];\n      const samplers = [];\n      for (let i = 0; i < tracks.length; ++i) {\n        const track = tracks[i];\n        const trackBinding = PropertyBinding.parseTrackName(track.name);\n        let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        const inputItemSize = 1;\n        let outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || `clip_${json.animations.length}`,\n        samplers,\n        channels\n      });\n      return json.animations.length - 1;\n    },\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n    processSkin: function (object) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    },\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n    processNode: function (object) {\n      const json = this.json;\n      const options = this.options;\n      const nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      const nodeDef = {};\n      if (options.trs) {\n        const rotation = object.quaternion.toArray();\n        const position = object.position.toArray();\n        const scale = object.scale.toArray();\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if (object.isMesh || object.isLine || object.isPoints) {\n        const meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        const children = [];\n        for (let i = 0, l = object.children.length; i < l; i++) {\n          const child = object.children[i];\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex = this.processNode(child);\n            if (nodeIndex !== null) children.push(nodeIndex);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(ext => {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    },\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n    processScene: function (scene) {\n      const json = this.json;\n      const options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      const sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      const nodes = [];\n      for (let i = 0, l = scene.children.length; i < l; i++) {\n        const child = scene.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    },\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n    processObjects: function (objects) {\n      const scene = new Scene();\n      scene.name = 'AuxScene';\n      for (let i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    },\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n    processInput: function (input) {\n      const options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(ext => {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      const objectsWithoutScene = [];\n      for (let i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (let i = 0; i < this.skins.length; ++i) {\n        this.processSkin(this.skins[i]);\n      }\n      for (let i = 0; i < options.animations.length; ++i) {\n        this.processAnimation(options.animations[i], input[0]);\n      }\n      this._invokeAll(ext => {\n        ext.afterParse && ext.afterParse(input);\n      });\n    },\n    _invokeAll: function (func) {\n      for (let i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  };\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n  function GLTFLightExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  GLTFLightExtension.prototype = {\n    constructor: GLTFLightExtension,\n    writeNode: function (light, nodeDef) {\n      if (!light.isLight) return;\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n      const writer = this.writer;\n      const json = writer.json;\n      const extensionsUsed = writer.extensionsUsed;\n      const lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n  function GLTFMaterialsUnlitExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  GLTFMaterialsUnlitExtension.prototype = {\n    constructor: GLTFMaterialsUnlitExtension,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      const extensionDef = {};\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = material.glossiness;\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n      if (material.specularMap) {\n        const specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  };\n  /**\n   * Static utility functions\n   */\n\n  GLTFExporter.Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001; // 1ms\n\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n      if (track.times.length === 0) {\n        times[0] = time;\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i;\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack);\n          continue;\n        }\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n          }\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n        if (targetIndex === undefined) {\n          throw new Error(`THREE.GLTFExporter: Morph target name not found: ${sourceTrackBinding.propertyIndex}`);\n        }\n        let mergedTrack; // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          } // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n\n          mergedTrack.name = `${sourceTrackBinding.nodeName || ''}.morphTargetInfluences`;\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        } // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n      clip.tracks = tracks;\n      return clip;\n    }\n  };\n  return GLTFExporter;\n})();\nexport { GLTFExporter };","map":{"version":3,"names":["PropertyBinding","InterpolateLinear","Vector3","RGBAFormat","RGBFormat","DoubleSide","BufferAttribute","MathUtils","InterpolateDiscrete","Matrix4","Scene","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","prototype","constructor","callback","indexOf","push","unregister","splice","parse","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","window","TextEncoder","undefined","encode","buffer","array","Uint8Array","ArrayBuffer","value","charCodeAt","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","getX","getY","getZ","getW","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","set","cachedCanvas","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","blob","Blob","type","extensionsUsedList","keys","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","name","message","getUID","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","resolve","processAccessor","geometry","types","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","minMax","bufferViewTarget","bufferView","accessorDef","normalized","accessors","processImage","image","format","flipY","cachedImages","mimeType","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","data","Uint8ClampedArray","j","putImageData","ImageData","toBlob","bufferViewIndex","toDataURL","src","processSampler","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","source","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","substr","toUpperCase","validVertexAttributes","test","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["import { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, DoubleSide, BufferAttribute, MathUtils, InterpolateDiscrete, Matrix4, Scene, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nconst GLTFExporter = (() => {\n  function GLTFExporter() {\n    this.pluginCallbacks = [];\n    this.register(writer => new GLTFLightExtension(writer));\n    this.register(writer => new GLTFMaterialsUnlitExtension(writer));\n    this.register(writer => new GLTFMaterialsPBRSpecularGlossiness(writer));\n  }\n\n  GLTFExporter.prototype = {\n    constructor: GLTFExporter,\n    register: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    },\n    unregister: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    parse: function (input, onDone, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n  }; //------------------------------------------------------------------------------\n  // Constants\n  //------------------------------------------------------------------------------\n\n  const WEBGL_CONSTANTS = {\n    POINTS: 0x0000,\n    LINES: 0x0001,\n    LINE_LOOP: 0x0002,\n    LINE_STRIP: 0x0003,\n    TRIANGLES: 0x0004,\n    TRIANGLE_STRIP: 0x0005,\n    TRIANGLE_FAN: 0x0006,\n    UNSIGNED_BYTE: 0x1401,\n    UNSIGNED_SHORT: 0x1403,\n    FLOAT: 0x1406,\n    UNSIGNED_INT: 0x1405,\n    ARRAY_BUFFER: 0x8892,\n    ELEMENT_ARRAY_BUFFER: 0x8893,\n    NEAREST: 0x2600,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_NEAREST: 0x2700,\n    LINEAR_MIPMAP_NEAREST: 0x2701,\n    NEAREST_MIPMAP_LINEAR: 0x2702,\n    LINEAR_MIPMAP_LINEAR: 0x2703,\n    CLAMP_TO_EDGE: 33071,\n    MIRRORED_REPEAT: 33648,\n    REPEAT: 10497\n  };\n  const THREE_TO_WEBGL = {};\n  THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\n  THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\n  THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n  THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\n  THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n  const PATH_PROPERTIES = {\n    scale: 'scale',\n    position: 'translation',\n    quaternion: 'rotation',\n    morphTargetInfluences: 'weights'\n  }; // GLB constants\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n  const GLB_HEADER_BYTES = 12;\n  const GLB_HEADER_MAGIC = 0x46546c67;\n  const GLB_VERSION = 2;\n  const GLB_CHUNK_PREFIX_BYTES = 8;\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  const GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n  function equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every((element, index) => element === array2[index]);\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  function stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n  /**\n   * Is identity matrix\n   *\n   * @param {Matrix4} matrix\n   * @returns {Boolean} Returns true, if parameter is identity matrix\n   */\n\n\n  function isIdentityMatrix(matrix) {\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n  /**\n   * Get the min and max vectors from the given attribute\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n   * @param  {Integer} start\n   * @param  {Integer} count\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n   */\n\n\n  function getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        output.min[a] = Math.min(output.min[a], value);\n        output.max[a] = Math.max(output.max[a], value);\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   *\n   * @param {Integer} bufferSize The size the original buffer.\n   * @returns {Integer} new buffer size with required padding.\n   *\n   */\n\n\n  function getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n    paddingByte = paddingByte || 0;\n    const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n  let cachedCanvas = null;\n  /**\n   * Writer\n   */\n\n  function GLTFWriter() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n\n  GLTFWriter.prototype = {\n    constructor: GLTFWriter,\n    setPlugins: function (plugins) {\n      this.plugins = plugins;\n    },\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    write: function (input, onDone, options) {\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n\n      if (this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n\n      this.processInput(input);\n      const writer = this;\n      Promise.all(this.pending).then(() => {\n        const buffers = writer.buffers;\n        const json = writer.json;\n        const options = writer.options;\n        const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        const blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        const extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n        if (options.binary === true) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n\n          reader.onloadend = () => {\n            // Binary chunk.\n            const binaryChunk = getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = () => {\n              onDone(glbReader.result);\n            };\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var reader = new window.FileReader();\n            reader.readAsDataURL(blob);\n\n            reader.onloadend = () => {\n              const base64data = reader.result;\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    },\n\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n    serializeUserData: function (object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      const options = this.options;\n      const extensionsUsed = this.extensionsUsed;\n\n      try {\n        const json = JSON.parse(JSON.stringify(object.userData));\n\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n          for (let extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n\n          delete json.gltfExtensions;\n        }\n\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(`THREE.GLTFExporter: userData of '${object.name}' won't be serialized because of JSON.stringify error - ${error.message}`);\n      }\n    },\n\n    /**\n     * Assign and return a temporal unique id for an object\n     * especially which doesn't have .uuid\n     * @param  {Object} object\n     * @return {Integer}\n     */\n    getUID: function (object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    },\n\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n    isNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      const v = new Vector3();\n\n      for (let i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n    createNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      const attribute = normal.clone();\n      const v = new Vector3();\n\n      for (let i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    },\n\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n    applyTextureTransform: function (mapDef, texture) {\n      let didTransform = false;\n      const transformDef = {};\n\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    },\n\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n    processBuffer: function (buffer) {\n      const json = this.json;\n      const buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    },\n\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n    processBufferView: function (attribute, componentType, start, count, target) {\n      const json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      let componentSize;\n\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n\n      const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      const dataView = new DataView(new ArrayBuffer(byteLength));\n      let offset = 0;\n\n      for (let i = start; i < start + count; i++) {\n        for (let a = 0; a < attribute.itemSize; a++) {\n          let value;\n\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n\n          offset += componentSize;\n        }\n      }\n\n      const bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      const output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    },\n\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n    processBufferViewImage: function (blob) {\n      const writer = this;\n      const json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(resolve => {\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          const buffer = getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    },\n\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n    processAccessor: function (attribute, geometry, start, count) {\n      const options = this.options;\n      const json = this.json;\n      const types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        const end = start + count;\n        const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n      if (count === 0) return null;\n      const minMax = getMinMax(attribute, start, count);\n      let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType,\n        count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    },\n\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n     * @param  {Boolean} flipY before writing out the image\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n    processImage: function (image, format, flipY) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      const key = `${mimeType}:flipY/${flipY.toString()}`;\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType\n      };\n\n      if (options.embedImages) {\n        const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        const ctx = canvas.getContext('2d');\n\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat && format !== RGBFormat) {\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n          }\n\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n\n          let data = image.data;\n\n          if (format === RGBFormat) {\n            data = new Uint8ClampedArray(image.height * image.width * 4);\n\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n\n        if (options.binary === true) {\n          pending.push(new Promise(resolve => {\n            canvas.toBlob(blob => {\n              writer.processBufferViewImage(blob).then(bufferViewIndex => {\n                imageDef.bufferView = bufferViewIndex;\n                resolve();\n              });\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else {\n        imageDef.uri = image.src;\n      }\n\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    },\n\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n    processSampler: function (map) {\n      const json = this.json;\n      if (!json.samplers) json.samplers = [];\n      const samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    },\n\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n    processTexture: function (map) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      const textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n\n      this._invokeAll(ext => {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n\n      const index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    },\n\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n    processMaterial: function (material) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n\n      if (material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      const materialDef = {\n        pbrMetallicRoughness: {}\n      };\n\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      } // pbrMetallicRoughness.baseColorFactor\n\n\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n      if (material.metalnessMap || material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap) {\n          const metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n      if (material.map) {\n        const baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n\n      if (material.emissive) {\n        // emissiveFactor\n        const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n\n        if (!equalArray(emissive, [0, 0, 0])) {\n          materialDef.emissiveFactor = emissive;\n        } // emissiveTexture\n\n\n        if (material.emissiveMap) {\n          const emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n\n      if (material.normalMap) {\n        const normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n\n        if (material.normalScale && material.normalScale.x !== -1) {\n          if (material.normalScale.x !== material.normalScale.y) {\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n          }\n\n          normalMapDef.scale = material.normalScale.x;\n        }\n\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n\n      if (material.aoMap) {\n        const occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n\n      this._invokeAll(ext => {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n\n      const index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    },\n\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n    processMesh: function (mesh) {\n      const cache = this.cache;\n      const json = this.json;\n      const meshCacheKeyParts = [mesh.geometry.uuid];\n\n      if (Array.isArray(mesh.material)) {\n        for (let i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n\n      const meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      const geometry = mesh.geometry;\n      let mode; // Use the correct mode\n\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const meshDef = {};\n      const attributes = {};\n      const primitives = [];\n      const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      const nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      const originalNormal = geometry.getAttribute('normal');\n\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n\n      let modifiedAttribute = null;\n\n      for (let attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = `_${attributeName}`;\n\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n        modifiedAttribute = null;\n        const array = attribute.array;\n\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n\n        const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n        if (accessor !== null) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        const weights = [];\n        const targetNames = [];\n        const reverseDictionary = {};\n\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (let key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n\n        for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n          const target = {};\n          let warned = false;\n\n          for (let attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (attributeName !== 'position' && attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n\n              continue;\n            }\n\n            var attribute = geometry.morphAttributes[attributeName][i];\n            const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            const baseAttribute = geometry.attributes[attributeName];\n\n            if (cache.attributes.has(this.getUID(attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n              continue;\n            } // Clones attribute not to override\n\n\n            const relativeAttribute = attribute.clone();\n\n            if (!geometry.morphTargetsRelative) {\n              for (let j = 0, jl = attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[i]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n        }\n\n        meshDef.weights = weights;\n\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n\n      const isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      const materials = isMultiMaterial ? mesh.material : [mesh.material];\n      const groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n\n      for (let i = 0, il = groups.length; i < il; i++) {\n        const primitive = {\n          mode,\n          attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n\n        if (geometry.index !== null) {\n          let cacheKey = this.getUID(geometry.index);\n\n          if (groups[i].start !== undefined || groups[i].count !== undefined) {\n            cacheKey += `:${groups[i].start}:${groups[i].count}`;\n          }\n\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n\n          if (primitive.indices === null) delete primitive.indices;\n        }\n\n        const material = this.processMaterial(materials[groups[i].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n\n      this._invokeAll(ext => {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n\n      const index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    },\n\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n    processCamera: function (camera) {\n      const json = this.json;\n      if (!json.cameras) json.cameras = [];\n      const isOrtho = camera.isOrthographicCamera;\n      const cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    },\n\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n    processAnimation: function (clip, root) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      const tracks = clip.tracks;\n      const channels = [];\n      const samplers = [];\n\n      for (let i = 0; i < tracks.length; ++i) {\n        const track = tracks[i];\n        const trackBinding = PropertyBinding.parseTrackName(track.name);\n        let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n\n        const inputItemSize = 1;\n        let outputItemSize = track.values.length / track.times.length;\n\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n\n        let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n\n      json.animations.push({\n        name: clip.name || `clip_${json.animations.length}`,\n        samplers,\n        channels\n      });\n      return json.animations.length - 1;\n    },\n\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n    processSkin: function (object) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    },\n\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n    processNode: function (object) {\n      const json = this.json;\n      const options = this.options;\n      const nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      const nodeDef = {};\n\n      if (options.trs) {\n        const rotation = object.quaternion.toArray();\n        const position = object.position.toArray();\n        const scale = object.scale.toArray();\n\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n\n      if (object.isMesh || object.isLine || object.isPoints) {\n        const meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n\n      if (object.isSkinnedMesh) this.skins.push(object);\n\n      if (object.children.length > 0) {\n        const children = [];\n\n        for (let i = 0, l = object.children.length; i < l; i++) {\n          const child = object.children[i];\n\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex = this.processNode(child);\n            if (nodeIndex !== null) children.push(nodeIndex);\n          }\n        }\n\n        if (children.length > 0) nodeDef.children = children;\n      }\n\n      this._invokeAll(ext => {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    },\n\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n    processScene: function (scene) {\n      const json = this.json;\n      const options = this.options;\n\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n\n      const sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      const nodes = [];\n\n      for (let i = 0, l = scene.children.length; i < l; i++) {\n        const child = scene.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    },\n\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n    processObjects: function (objects) {\n      const scene = new Scene();\n      scene.name = 'AuxScene';\n\n      for (let i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n\n      this.processScene(scene);\n    },\n\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n    processInput: function (input) {\n      const options = this.options;\n      input = input instanceof Array ? input : [input];\n\n      this._invokeAll(ext => {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n\n      const objectsWithoutScene = [];\n\n      for (let i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n      for (let i = 0; i < this.skins.length; ++i) {\n        this.processSkin(this.skins[i]);\n      }\n\n      for (let i = 0; i < options.animations.length; ++i) {\n        this.processAnimation(options.animations[i], input[0]);\n      }\n\n      this._invokeAll(ext => {\n        ext.afterParse && ext.afterParse(input);\n      });\n    },\n    _invokeAll: function (func) {\n      for (let i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  };\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n  function GLTFLightExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  GLTFLightExtension.prototype = {\n    constructor: GLTFLightExtension,\n    writeNode: function (light, nodeDef) {\n      if (!light.isLight) return;\n\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n\n      const writer = this.writer;\n      const json = writer.json;\n      const extensionsUsed = writer.extensionsUsed;\n      const lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n\n      if (light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n\n      if (light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n  function GLTFMaterialsUnlitExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  GLTFMaterialsUnlitExtension.prototype = {\n    constructor: GLTFMaterialsUnlitExtension,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      const extensionDef = {};\n\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = material.glossiness;\n\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n\n      if (material.specularMap) {\n        const specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  };\n  /**\n   * Static utility functions\n   */\n\n  GLTFExporter.Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001; // 1ms\n\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n\n      if (track.times.length === 0) {\n        times[0] = time;\n\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack);\n          continue;\n        }\n\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n        if (targetIndex === undefined) {\n          throw new Error(`THREE.GLTFExporter: Morph target name not found: ${sourceTrackBinding.propertyIndex}`);\n        }\n\n        let mergedTrack; // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          } // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n\n\n          mergedTrack.name = `${sourceTrackBinding.nodeName || ''}.morphTargetInfluences`;\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        } // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n\n\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n\n      clip.tracks = tracks;\n      return clip;\n    }\n  };\n  return GLTFExporter;\n})();\n\nexport { GLTFExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}