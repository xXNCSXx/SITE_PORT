{"ast":null,"code":"import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearEncoding, NoToneMapping, LinearFilter, RGBFormat } from 'three';\n\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nvar Water = function (geometry, options) {\n  Mesh.call(this, geometry);\n  var scope = this;\n  options = options || {};\n  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n  var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n  var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : FrontSide;\n  var fog = options.fog !== undefined ? options.fog : false; //\n\n  var mirrorPlane = new Plane();\n  var normal = new Vector3();\n  var mirrorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var mirrorCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n  var mirrorShader = {\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n      normalSampler: {\n        value: null\n      },\n      mirrorSampler: {\n        value: null\n      },\n      alpha: {\n        value: 1.0\n      },\n      time: {\n        value: 0.0\n      },\n      size: {\n        value: 1.0\n      },\n      distortionScale: {\n        value: 20.0\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      sunColor: {\n        value: new Color(0x7f7f7f)\n      },\n      sunDirection: {\n        value: new Vector3(0.70707, 0.70707, 0)\n      },\n      eye: {\n        value: new Vector3()\n      },\n      waterColor: {\n        value: new Color(0x555555)\n      }\n    }]),\n    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '\tmirrorCoord = modelMatrix * vec4( position, 1.0 );', '\tworldPosition = mirrorCoord.xyzw;', '\tmirrorCoord = textureMatrix * mirrorCoord;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * mvPosition;', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '\tvec4 noise = texture2D( normalSampler, uv0 ) +', '\t\ttexture2D( normalSampler, uv1 ) +', '\t\ttexture2D( normalSampler, uv2 ) +', '\t\ttexture2D( normalSampler, uv3 );', '\treturn noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );', '\tspecularColor += pow( direction, shiny ) * sunColor * spec;', '\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '\tvec4 noise = getNoise( worldPosition.xz * size );', '\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '\tvec3 diffuseLight = vec3(0.0);', '\tvec3 specularLight = vec3(0.0);', '\tvec3 worldToEye = eye-worldPosition.xyz;', '\tvec3 eyeDirection = normalize( worldToEye );', '\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '\tfloat distance = length(worldToEye);', '\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '\tfloat rf0 = 0.3;', '\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '\tvec3 outgoingLight = albedo;', '\tgl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    fragmentShader: mirrorShader.fragmentShader,\n    vertexShader: mirrorShader.vertexShader,\n    uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n    lights: true,\n    side: side,\n    fog: fog\n  });\n  material.uniforms['mirrorSampler'].value = renderTarget.texture;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  material.uniforms['alpha'].value = alpha;\n  material.uniforms['time'].value = time;\n  material.uniforms['normalSampler'].value = normalSampler;\n  material.uniforms['sunColor'].value = sunColor;\n  material.uniforms['waterColor'].value = waterColor;\n  material.uniforms['sunDirection'].value = sunDirection;\n  material.uniforms['distortionScale'].value = distortionScale;\n  material.uniforms['eye'].value = eye;\n  scope.material = material;\n  scope.onBeforeRender = function (renderer, scene, camera) {\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n    eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n    if (renderer.outputEncoding !== LinearEncoding) {\n      console.warn('THREE.Water: WebGLRenderer must use LinearEncoding as outputEncoding.');\n      scope.onBeforeRender = function () {};\n      return;\n    }\n    if (renderer.toneMapping !== NoToneMapping) {\n      console.warn('THREE.Water: WebGLRenderer must use NoToneMapping as toneMapping.');\n      scope.onBeforeRender = function () {};\n      return;\n    }\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    scope.visible = false;\n    renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, mirrorCamera);\n    scope.visible = true;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n  };\n};\nWater.prototype = Object.create(Mesh.prototype);\nWater.prototype.constructor = Water;\nexport { Water };","map":{"version":3,"names":["Mesh","Vector3","Color","FrontSide","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","MathUtils","UniformsUtils","UniformsLib","ShaderMaterial","LinearEncoding","NoToneMapping","LinearFilter","RGBFormat","Water","geometry","options","call","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","join","fragmentShader","material","clone","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","outputEncoding","console","warn","toneMapping","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/objects/Water.js"],"sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearEncoding, NoToneMapping, LinearFilter, RGBFormat } from 'three';\n\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nvar Water = function (geometry, options) {\n  Mesh.call(this, geometry);\n  var scope = this;\n  options = options || {};\n  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n  var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n  var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : FrontSide;\n  var fog = options.fog !== undefined ? options.fog : false; //\n\n  var mirrorPlane = new Plane();\n  var normal = new Vector3();\n  var mirrorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var mirrorCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var mirrorShader = {\n    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n      normalSampler: {\n        value: null\n      },\n      mirrorSampler: {\n        value: null\n      },\n      alpha: {\n        value: 1.0\n      },\n      time: {\n        value: 0.0\n      },\n      size: {\n        value: 1.0\n      },\n      distortionScale: {\n        value: 20.0\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      sunColor: {\n        value: new Color(0x7f7f7f)\n      },\n      sunDirection: {\n        value: new Vector3(0.70707, 0.70707, 0)\n      },\n      eye: {\n        value: new Vector3()\n      },\n      waterColor: {\n        value: new Color(0x555555)\n      }\n    }]),\n    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '\tmirrorCoord = modelMatrix * vec4( position, 1.0 );', '\tworldPosition = mirrorCoord.xyzw;', '\tmirrorCoord = textureMatrix * mirrorCoord;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * mvPosition;', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '\tvec4 noise = texture2D( normalSampler, uv0 ) +', '\t\ttexture2D( normalSampler, uv1 ) +', '\t\ttexture2D( normalSampler, uv2 ) +', '\t\ttexture2D( normalSampler, uv3 );', '\treturn noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );', '\tspecularColor += pow( direction, shiny ) * sunColor * spec;', '\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '\tvec4 noise = getNoise( worldPosition.xz * size );', '\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '\tvec3 diffuseLight = vec3(0.0);', '\tvec3 specularLight = vec3(0.0);', '\tvec3 worldToEye = eye-worldPosition.xyz;', '\tvec3 eyeDirection = normalize( worldToEye );', '\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '\tfloat distance = length(worldToEye);', '\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '\tfloat rf0 = 0.3;', '\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '\tvec3 outgoingLight = albedo;', '\tgl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    fragmentShader: mirrorShader.fragmentShader,\n    vertexShader: mirrorShader.vertexShader,\n    uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n    lights: true,\n    side: side,\n    fog: fog\n  });\n  material.uniforms['mirrorSampler'].value = renderTarget.texture;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  material.uniforms['alpha'].value = alpha;\n  material.uniforms['time'].value = time;\n  material.uniforms['normalSampler'].value = normalSampler;\n  material.uniforms['sunColor'].value = sunColor;\n  material.uniforms['waterColor'].value = waterColor;\n  material.uniforms['sunDirection'].value = sunDirection;\n  material.uniforms['distortionScale'].value = distortionScale;\n  material.uniforms['eye'].value = eye;\n  scope.material = material;\n\n  scope.onBeforeRender = function (renderer, scene, camera) {\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n    eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n    if (renderer.outputEncoding !== LinearEncoding) {\n      console.warn('THREE.Water: WebGLRenderer must use LinearEncoding as outputEncoding.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    if (renderer.toneMapping !== NoToneMapping) {\n      console.warn('THREE.Water: WebGLRenderer must use NoToneMapping as toneMapping.');\n\n      scope.onBeforeRender = function () {};\n\n      return;\n    }\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    scope.visible = false;\n    renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, mirrorCamera);\n    scope.visible = true;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n  };\n};\n\nWater.prototype = Object.create(Mesh.prototype);\nWater.prototype.constructor = Water;\n\nexport { Water };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}