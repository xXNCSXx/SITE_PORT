{"ast":null,"code":"import { Loader, Texture, FileLoader } from 'three';\nvar TGALoader = function (manager) {\n  Loader.call(this, manager);\n};\nTGALoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: TGALoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new Texture();\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      texture.image = scope.parse(buffer);\n      texture.needsUpdate = true;\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  },\n  parse: function (buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n          break;\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n          break;\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.');\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n      } // check image width and height\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.');\n      } // check image pixel size\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n      }\n    } // parse tga image buffer\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      var pixel_data, pixel_size, pixel_total, palettes;\n      pixel_size = header.pixel_size >> 3;\n      pixel_total = header.width * header.height * pixel_size; // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      } // read RLE\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        var c, count, i;\n        var shift = 0;\n        var pixels = new Uint8Array(pixel_size);\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1; // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            } // copy pixel array\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n            count *= pixel_size;\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      var colormap = palettes;\n      var color,\n        i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n        i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n        i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n        x,\n        y;\n      var width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n      return imageData;\n    }\n    function getTgaRGBA(data, width, height, image, palette) {\n      var x_start, y_start, x_step, y_step, x_end, y_end;\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } // Load image data according to specific method\n      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n      return data;\n    } // TGA constants\n\n    var TGA_TYPE_NO_DATA = 0,\n      TGA_TYPE_INDEXED = 1,\n      TGA_TYPE_RGB = 2,\n      TGA_TYPE_GREY = 3,\n      TGA_TYPE_RLE_INDEXED = 9,\n      TGA_TYPE_RLE_RGB = 10,\n      TGA_TYPE_RLE_GREY = 11,\n      TGA_ORIGIN_MASK = 0x30,\n      TGA_ORIGIN_SHIFT = 0x04,\n      TGA_ORIGIN_BL = 0x00,\n      TGA_ORIGIN_BR = 0x01,\n      TGA_ORIGIN_UL = 0x02,\n      TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n    var content = new Uint8Array(buffer),\n      offset = 0,\n      header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | content[offset++] << 8,\n        colormap_length: content[offset++] | content[offset++] << 8,\n        colormap_size: content[offset++],\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n        width: content[offset++] | content[offset++] << 8,\n        height: content[offset++] | content[offset++] << 8,\n        pixel_size: content[offset++],\n        flags: content[offset++]\n      }; // check tga if it is valid format\n\n    tgaCheckHeader(header);\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.');\n    } // skip the needn't data\n\n    offset += header.id_length; // get targa information about RLE compression and palette\n\n    var use_rle = false,\n      use_pal = false,\n      use_grey = false;\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n      case TGA_TYPE_RGB:\n        break;\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    } //\n\n    var useOffscreen = typeof OffscreenCanvas !== 'undefined';\n    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');\n    canvas.width = header.width;\n    canvas.height = header.height;\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(header.width, header.height);\n    var result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n});\nexport { TGALoader };","map":{"version":3,"names":["Loader","Texture","FileLoader","TGALoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","texture","loader","setResponseType","setPath","path","setWithCredentials","withCredentials","buffer","image","parse","needsUpdate","undefined","tgaCheckHeader","header","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle","use_pal","offset","data","pixel_data","pixel_total","palettes","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData","y_start","y_step","y_end","x_start","x_step","x_end","colormap","color","x","y","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","content","id_length","colormap_index","origin","useOffscreen","OffscreenCanvas","canvas","document","createElement","context","getContext","createImageData","result","putImageData"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/TGALoader.js"],"sourcesContent":["import { Loader, Texture, FileLoader } from 'three';\n\nvar TGALoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nTGALoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: TGALoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new Texture();\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      texture.image = scope.parse(buffer);\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  },\n  parse: function (buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n\n          break;\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n\n          break;\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.');\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n      } // check image width and height\n\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.');\n      } // check image pixel size\n\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n      }\n    } // parse tga image buffer\n\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      var pixel_data, pixel_size, pixel_total, palettes;\n      pixel_size = header.pixel_size >> 3;\n      pixel_total = header.width * header.height * pixel_size; // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      } // read RLE\n\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        var c, count, i;\n        var shift = 0;\n        var pixels = new Uint8Array(pixel_size);\n\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1; // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            } // copy pixel array\n\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n            count *= pixel_size;\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      var colormap = palettes;\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n\n      return imageData;\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      var x_start, y_start, x_step, y_step, x_end, y_end;\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } // Load image data according to specific method\n      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n      return data;\n    } // TGA constants\n\n\n    var TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n        TGA_ORIGIN_MASK = 0x30,\n        TGA_ORIGIN_SHIFT = 0x04,\n        TGA_ORIGIN_BL = 0x00,\n        TGA_ORIGIN_BR = 0x01,\n        TGA_ORIGIN_UL = 0x02,\n        TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n    var content = new Uint8Array(buffer),\n        offset = 0,\n        header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    }; // check tga if it is valid format\n\n    tgaCheckHeader(header);\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.');\n    } // skip the needn't data\n\n\n    offset += header.id_length; // get targa information about RLE compression and palette\n\n    var use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n\n      case TGA_TYPE_RGB:\n        break;\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    } //\n\n\n    var useOffscreen = typeof OffscreenCanvas !== 'undefined';\n    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');\n    canvas.width = header.width;\n    canvas.height = header.height;\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(header.width, header.height);\n    var result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n});\n\nexport { TGALoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}