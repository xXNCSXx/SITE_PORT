{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(BaseRegExpVisitor);\nexport function canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, function (char) {\n      return contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}","map":{"version":3,"names":["VERSION","BaseRegExpVisitor","forEach","contains","PRINT_ERROR","PRINT_WARNING","find","isArray","every","values","getRegExpAst","charCodeToOptimizedIndex","minOptimizationVal","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","CharCodeFinder","_super","__extends","_this","call","found","prototype","visitChildren","node","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["../../../src/scan/reg_exp.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}