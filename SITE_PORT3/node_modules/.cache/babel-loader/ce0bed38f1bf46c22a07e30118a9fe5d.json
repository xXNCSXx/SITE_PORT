{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = [];\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\nexport { OccurrenceValidationCollector };\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof AlternativeGAST || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(GAstVisitor);\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\nvar RepetionCollector = /** @class */function (_super) {\n  __extends(RepetionCollector, _super);\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetionCollector;\n}(GAstVisitor);\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = [];\n  // flatten\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"names":["utils","contains","every","findAll","flatten","forEach","isEmpty","map","reduce","reject","ParserDefinitionErrorType","getProductionDslName","isOptionalProd","containsPath","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","getProdType","isStrictPrefixOfPath","nextPossibleTokensAfter","Alternation","Alternative","AlternativeGAST","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","GAstVisitor","validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","currTopLevel","validateDuplicateProductions","leftRecursionErrors","currTopRule","validateNoLeftRecursion","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateEmptyOrAlternative","validateAmbiguousAlternationAlternatives","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","concat","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","groupBy","identifyProductionForDuplicates","duplicates","pick","currGroup","length","errors","values","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","defError","message","type","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","terminalType","nonTerminalName","_super","__extends","_this","apply","arguments","prototype","visitNonTerminal","subrule","push","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","alternations","node","orCollector","ors","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["../../../../src/parse/grammar/checks.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}