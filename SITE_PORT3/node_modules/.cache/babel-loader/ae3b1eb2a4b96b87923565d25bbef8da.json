{"ast":null,"code":"import { Vector3, Quaternion, Matrix4 } from 'three';\nimport { CharsetEncoder } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nconst MMDExporter = function () {\n  // Unicode to Shift_JIS table\n  let u2sTable;\n  function unicodeToShiftjis(str) {\n    if (u2sTable === undefined) {\n      const encoder = new CharsetEncoder(); // eslint-disable-line no-undef\n\n      const table = encoder.s2uTable;\n      u2sTable = {};\n      const keys = Object.keys(table);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i];\n        var value = table[key];\n        key = parseInt(key);\n        u2sTable[value] = key;\n      }\n    }\n    const array = [];\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i);\n      var value = u2sTable[code];\n      if (value === undefined) {\n        throw `cannot convert charcode 0x${code.toString(16)}`;\n      } else if (value > 0xff) {\n        array.push(value >> 8 & 0xff);\n        array.push(value & 0xff);\n      } else {\n        array.push(value & 0xff);\n      }\n    }\n    return new Uint8Array(array);\n  }\n  function getBindBones(skin) {\n    // any more efficient ways?\n    const poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n\n  this.parseVpd = (skin, outputShiftJis, useOriginalBones) => {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n      return null;\n    }\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6) num = 0;\n      let a = num.toString();\n      if (a.indexOf('.') === -1) {\n        a += '.';\n      }\n      a += '000000';\n      const index = a.indexOf('.');\n      const d = a.slice(0, index);\n      const p = a.slice(index + 1, index + 7);\n      return `${d}.${p}`;\n    }\n    function toStringsFromArray(array) {\n      const a = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]));\n      }\n      return a.join(',');\n    }\n    skin.updateMatrixWorld(true);\n    const bones = skin.skeleton.bones;\n    const bones2 = getBindBones(skin);\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const quaternion2 = new Quaternion();\n    const matrix = new Matrix4();\n    const array = [];\n    array.push('Vocaloid Pose Data file');\n    array.push('');\n    array.push(`${skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin'}.osm;`);\n    array.push(`${bones.length};`);\n    array.push('');\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      const bone2 = bones2[i];\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n\n      if (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      const pArray = position.sub(bone2.position).toArray();\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray(); // right to left\n\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(`Bone${i}{${bone.name}`);\n      array.push(`  ${toStringsFromArray(pArray)};`);\n      array.push(`  ${toStringsFromArray(qArray)};`);\n      array.push('}');\n      array.push('');\n    }\n    array.push('');\n    const lines = array.join('\\n');\n    return outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n  };\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n};\nexport { MMDExporter };","map":{"version":3,"names":["Vector3","Quaternion","Matrix4","CharsetEncoder","MMDExporter","u2sTable","unicodeToShiftjis","str","undefined","encoder","table","s2uTable","keys","Object","i","il","length","key","value","parseInt","array","code","charCodeAt","toString","push","Uint8Array","getBindBones","skin","poseSkin","clone","pose","skeleton","bones","parseVpd","outputShiftJis","useOriginalBones","isSkinnedMesh","console","warn","toStringsFromNumber","num","Math","abs","a","indexOf","index","d","slice","p","toStringsFromArray","join","updateMatrixWorld","bones2","position","quaternion","quaternion2","matrix","name","replace","bone","bone2","userData","ik","originalMatrix","fromArray","copy","setFromMatrixPosition","setFromRotationMatrix","pArray","sub","toArray","qArray","conjugate","multiply","lines"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/MMDExporter.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix4 } from 'three';\nimport { CharsetEncoder } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nconst MMDExporter = function () {\n  // Unicode to Shift_JIS table\n  let u2sTable;\n\n  function unicodeToShiftjis(str) {\n    if (u2sTable === undefined) {\n      const encoder = new CharsetEncoder(); // eslint-disable-line no-undef\n\n      const table = encoder.s2uTable;\n      u2sTable = {};\n      const keys = Object.keys(table);\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i];\n        var value = table[key];\n        key = parseInt(key);\n        u2sTable[value] = key;\n      }\n    }\n\n    const array = [];\n\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i);\n      var value = u2sTable[code];\n\n      if (value === undefined) {\n        throw `cannot convert charcode 0x${code.toString(16)}`;\n      } else if (value > 0xff) {\n        array.push(value >> 8 & 0xff);\n        array.push(value & 0xff);\n      } else {\n        array.push(value & 0xff);\n      }\n    }\n\n    return new Uint8Array(array);\n  }\n\n  function getBindBones(skin) {\n    // any more efficient ways?\n    const poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n\n\n  this.parseVpd = (skin, outputShiftJis, useOriginalBones) => {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n      return null;\n    }\n\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6) num = 0;\n      let a = num.toString();\n\n      if (a.indexOf('.') === -1) {\n        a += '.';\n      }\n\n      a += '000000';\n      const index = a.indexOf('.');\n      const d = a.slice(0, index);\n      const p = a.slice(index + 1, index + 7);\n      return `${d}.${p}`;\n    }\n\n    function toStringsFromArray(array) {\n      const a = [];\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]));\n      }\n\n      return a.join(',');\n    }\n\n    skin.updateMatrixWorld(true);\n    const bones = skin.skeleton.bones;\n    const bones2 = getBindBones(skin);\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const quaternion2 = new Quaternion();\n    const matrix = new Matrix4();\n    const array = [];\n    array.push('Vocaloid Pose Data file');\n    array.push('');\n    array.push(`${skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin'}.osm;`);\n    array.push(`${bones.length};`);\n    array.push('');\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      const bone2 = bones2[i];\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n\n      if (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      const pArray = position.sub(bone2.position).toArray();\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray(); // right to left\n\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(`Bone${i}{${bone.name}`);\n      array.push(`  ${toStringsFromArray(pArray)};`);\n      array.push(`  ${toStringsFromArray(qArray)};`);\n      array.push('}');\n      array.push('');\n    }\n\n    array.push('');\n    const lines = array.join('\\n');\n    return outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n  };\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n\n};\n\nexport { MMDExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}