{"ast":null,"code":"import { END_OF_FILE } from \"../parser\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */function () {\n  function LexerAdapter() {}\n  LexerAdapter.prototype.initLexerAdapter = function () {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  };\n  Object.defineProperty(LexerAdapter.prototype, \"input\", {\n    get: function () {\n      return this.tokVector;\n    },\n    set: function (newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n      }\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      this.reset();\n      this.tokVector = newInput;\n      this.tokVectorLength = newInput.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // skips a token and returns the next token\n  LexerAdapter.prototype.SKIP_TOKEN = function () {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  };\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LexerAdapter.prototype.LA = function (howMuch) {\n    var soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  };\n  LexerAdapter.prototype.consumeToken = function () {\n    this.currIdx++;\n  };\n  LexerAdapter.prototype.exportLexerState = function () {\n    return this.currIdx;\n  };\n  LexerAdapter.prototype.importLexerState = function (newState) {\n    this.currIdx = newState;\n  };\n  LexerAdapter.prototype.resetLexerState = function () {\n    this.currIdx = -1;\n  };\n  LexerAdapter.prototype.moveToTerminatedState = function () {\n    this.currIdx = this.tokVector.length - 1;\n  };\n  LexerAdapter.prototype.getLexerPosition = function () {\n    return this.exportLexerState();\n  };\n  return LexerAdapter;\n}();\nexport { LexerAdapter };","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/lexer_adapter.ts"],"names":[],"mappings":"AAAA,SAAS,WAAW,QAAQ,WAAW;AAIvC;;;;;;AAMG;AACH,IAAA,YAAA,GAAA,aAAA,YAAA;EAAA,SAAA,YAAA,CAAA,EAAA,CA0EA;EArEE,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,YAAA;IACE,IAAI,CAAC,SAAS,GAAG,EAAE;IACnB,IAAI,CAAC,eAAe,GAAG,CAAC;IACxB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;EACnB,CAAC;EAED,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAA,EAAA,OAAK,EAAA;SAeT,SAAA,CAAA,EAAA;MACE,OAAO,IAAI,CAAC,SAAS;IACvB,CAAC;SAjBD,SAAA,CAAU,QAAkB,EAAA;MAC1B;MACA;MACA,IAAI,IAAI,CAAC,gBAAgB,KAAK,IAAI,EAAE;QAClC,MAAM,KAAK,CACT,kFAAkF,CACnF;MACF;MACD;MACA;MACA,IAAI,CAAC,KAAK,CAAA,CAAE;MACZ,IAAI,CAAC,SAAS,GAAG,QAAQ;MACzB,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,MAAM;IACxC,CAAC;;;IAAA;EAMD;EACA,YAAA,CAAA,SAAA,CAAA,UAAU,GAAV,YAAA;IACE,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;MAC7C,IAAI,CAAC,YAAY,CAAA,CAAE;MACnB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;KAClB,MAAM;MACL,OAAO,WAAW;IACnB;EACH,CAAC;EAED;EACA;EACA,YAAA,CAAA,SAAA,CAAA,EAAE,GAAF,UAAwB,OAAe,EAAA;IACrC,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,GAAG,OAAO;IACxC,IAAI,SAAS,GAAG,CAAC,IAAI,IAAI,CAAC,eAAe,IAAI,SAAS,EAAE;MACtD,OAAO,WAAW;KACnB,MAAM;MACL,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;IACjC;EACH,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,YAAY,GAAZ,YAAA;IACE,IAAI,CAAC,OAAO,EAAE;EAChB,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,YAAA;IACE,OAAO,IAAI,CAAC,OAAO;EACrB,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,UAAsC,QAAgB,EAAA;IACpD,IAAI,CAAC,OAAO,GAAG,QAAQ;EACzB,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,eAAe,GAAf,YAAA;IACE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;EACnB,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,qBAAqB,GAArB,YAAA;IACE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC;EAC1C,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,YAAA;IACE,OAAO,IAAI,CAAC,gBAAgB,CAAA,CAAE;EAChC,CAAC;EACH,OAAA,YAAC;AAAD,CAAC,CAAA,CAAA","sourceRoot":"","sourcesContent":["import { END_OF_FILE } from \"../parser\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */ (function () {\n    function LexerAdapter() {\n    }\n    LexerAdapter.prototype.initLexerAdapter = function () {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    };\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\n        get: function () {\n            return this.tokVector;\n        },\n        set: function (newInput) {\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            if (this.selfAnalysisDone !== true) {\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n            }\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            this.reset();\n            this.tokVector = newInput;\n            this.tokVectorLength = newInput.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // skips a token and returns the next token\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    };\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LexerAdapter.prototype.LA = function (howMuch) {\n        var soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    };\n    LexerAdapter.prototype.consumeToken = function () {\n        this.currIdx++;\n    };\n    LexerAdapter.prototype.exportLexerState = function () {\n        return this.currIdx;\n    };\n    LexerAdapter.prototype.importLexerState = function (newState) {\n        this.currIdx = newState;\n    };\n    LexerAdapter.prototype.resetLexerState = function () {\n        this.currIdx = -1;\n    };\n    LexerAdapter.prototype.moveToTerminatedState = function () {\n        this.currIdx = this.tokVector.length - 1;\n    };\n    LexerAdapter.prototype.getLexerPosition = function () {\n        return this.exportLexerState();\n    };\n    return LexerAdapter;\n}());\nexport { LexerAdapter };\n//# sourceMappingURL=lexer_adapter.js.map"]},"metadata":{},"sourceType":"module"}