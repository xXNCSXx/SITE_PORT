{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Alternative as AlternativeGAST, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = every(alts, function (currAlt) {\n    return every(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  });\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = map(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = map(alts, function (currAlt) {\n      return flatten(currAlt);\n    });\n    var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n      forEach(currAlt, function (currTokType) {\n        if (!has(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          if (!has(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, []);\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = every(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length;\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = flatten(alt);\n    if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        }\n        // found a full path that matches.\n        return true;\n      }\n      // none of the paths matched\n      return false;\n    };\n  }\n}\nvar RestDefinitionFinderWalker = /** @class */function (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false;\n  };\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n  return RestDefinitionFinderWalker;\n}(RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */function (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n  return InsideDefinitionFinderVisitor;\n}(GAstVisitor);\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = map(altsDefs, function (currAlt) {\n    return possiblePathsFrom([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = map(partialAlts, function (currAltPaths) {\n    var dict = {};\n    forEach(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      forEach(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts;\n  // maxLookahead loop\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    var _loop_1 = function (altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx];\n      // paths in current alternative loop\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx];\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            // Update all new  keys for the current path.\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    };\n    // alternatives loop\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n  return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new AlternativeGAST({\n    definition: insideDef\n  });\n  var afterFlat = new AlternativeGAST({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every(lookAheadPaths, function (singleAltPaths) {\n    return every(singleAltPaths, function (singlePath) {\n      return every(singlePath, function (token) {\n        return isEmpty(token.categoryMatches);\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/lookahead.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Alternative as AlternativeGAST, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = every(alts, function (currAlt) {\n        return every(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = map(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = map(alts, function (currAlt) {\n            return flatten(currAlt);\n        });\n        var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n            forEach(currAlt, function (currTokType) {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = every(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = map(altsDefs, function (currAlt) { return possiblePathsFrom([currAlt], 1); });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        forEach(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            forEach(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new AlternativeGAST({ definition: insideDef });\n    var afterFlat = new AlternativeGAST({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, function (singleAltPaths) {\n        return every(singleAltPaths, function (singlePath) {\n            return every(singlePath, function (token) { return isEmpty(token.categoryMatches); });\n        });\n    });\n}\n//# sourceMappingURL=lookahead.js.map"]},"metadata":{},"sourceType":"module"}