{"ast":null,"code":"import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nconst hilbert2D = (center, size, iterations, v0, v1, v2, v3) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n    size = size !== undefined ? size : 10,\n    half = size / 2,\n    iterations = iterations !== undefined ? iterations : 1,\n    v0 = v0 !== undefined ? v0 : 0,\n    v1 = v1 !== undefined ? v1 : 1,\n    v2 = v2 !== undefined ? v2 : 2,\n    v3 = v3 !== undefined ? v3 : 3;\n  var vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\nconst hilbert3D = (center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n    size = size !== undefined ? size : 10,\n    half = size / 2,\n    iterations = iterations !== undefined ? iterations : 1,\n    v0 = v0 !== undefined ? v0 : 0,\n    v1 = v1 !== undefined ? v1 : 1,\n    v2 = v2 !== undefined ? v2 : 2,\n    v3 = v3 !== undefined ? v3 : 3,\n    v4 = v4 !== undefined ? v4 : 4,\n    v5 = v5 !== undefined ? v5 : 5,\n    v6 = v6 !== undefined ? v6 : 6,\n    v7 = v7 !== undefined ? v7 : 7;\n  var vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\nconst gosper = size => {\n  size = size !== undefined ? size : 1;\n  function fractalize(config) {\n    var output;\n    var input = config.axiom;\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        var char = input[j];\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n      input = output;\n    }\n    return output;\n  }\n  function toPoints(config) {\n    var currX = 0,\n      currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      var char = fractal[i];\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n    return path;\n  } //\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n  });\n  return points;\n};\nexport { gosper, hilbert2D, hilbert3D };","map":{"version":3,"names":["Vector3","hilbert2D","center","size","iterations","v0","v1","v2","v3","undefined","half","vec_s","x","y","z","vec","tmp","Array","prototype","push","apply","hilbert3D","v4","v5","v6","v7","gosper","fractalize","config","output","input","axiom","i","il","steps","j","jl","length","char","rules","toPoints","currX","currY","angle","path","fractal","l","Math","cos","sin","A","B","points","PI"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/utils/GeometryUtils.js"],"sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nconst hilbert2D = (center, size, iterations, v0, v1, v2, v3) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3;\n  var vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nconst hilbert3D = (center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) => {\n  // Default Vars\n  var center = center !== undefined ? center : new Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3,\n      v4 = v4 !== undefined ? v4 : 4,\n      v5 = v5 !== undefined ? v5 : 5,\n      v6 = v6 !== undefined ? v6 : 6,\n      v7 = v7 !== undefined ? v7 : 7;\n  var vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nconst gosper = size => {\n  size = size !== undefined ? size : 1;\n\n  function fractalize(config) {\n    var output;\n    var input = config.axiom;\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        var char = input[j];\n\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    var currX = 0,\n        currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      var char = fractal[i];\n\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nexport { gosper, hilbert2D, hilbert3D };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}