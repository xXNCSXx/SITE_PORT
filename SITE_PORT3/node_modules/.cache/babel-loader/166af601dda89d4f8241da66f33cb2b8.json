{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new Vector3();\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function (points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n      return this;\n    },\n    setFromObject: function (object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function (point) {\n      var faces = this.faces;\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n      return true;\n    },\n    intersectRay: function (ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n      return target;\n    },\n    intersectsRay: function (ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function () {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function (vertex, face) {\n      vertex.face = face;\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function (vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function (face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function (face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function (newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n          for (let i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function () {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new Line3();\n          plane = new Plane();\n          closestPoint = new Vector3();\n        }\n        var vertex,\n          vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n          maxDistance = 0;\n        var index = 0;\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n        var faces = [];\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function () {\n      var activeFaces = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function () {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function (eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n        edge = edge.next;\n      } while (edge !== crossEdge);\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function (eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function (eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n      for (let i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function (eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function () {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function () {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n  Object.assign(Face, {\n    create: function (a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function (i) {\n      var edge = this.edge;\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function (point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  Object.assign(HalfEdge.prototype, {\n    head: function () {\n      return this.vertex;\n    },\n    tail: function () {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function () {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n      return -1;\n    },\n    lengthSquared: function () {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n      return -1;\n    },\n    setTwin: function (edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n  Object.assign(VertexList.prototype, {\n    first: function () {\n      return this.head;\n    },\n    last: function () {\n      return this.tail;\n    },\n    clear: function () {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function (target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function (target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function (vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function (a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n      return this;\n    },\n    isEmpty: function () {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\nexport { ConvexHull };","map":{"version":3,"names":["Vector3","Line3","Plane","Triangle","ConvexHull","Visible","Deleted","v1","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","point","geometry","undefined","isGeometry","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","j","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","line3","plane","closestPoint","extremes","v0","v2","v3","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/math/ConvexHull.js"],"sourcesContent":["import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new Vector3();\n\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function (points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n      return this;\n    },\n    setFromObject: function (object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function (point) {\n      var faces = this.faces;\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    },\n    intersectRay: function (ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    },\n    intersectsRay: function (ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function () {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function (vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function (vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function (face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function (face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function (newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (let i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function () {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new Line3();\n          plane = new Plane();\n          closestPoint = new Vector3();\n        }\n\n        var vertex,\n            vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n            maxDistance = 0;\n        var index = 0;\n\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n\n        var faces = [];\n\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function () {\n      var activeFaces = [];\n\n      for (let i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function () {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function (eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function (eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function (eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (let i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function (eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function () {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function () {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  Object.assign(Face, {\n    create: function (a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function (i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function (point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  Object.assign(HalfEdge.prototype, {\n    head: function () {\n      return this.vertex;\n    },\n    tail: function () {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function () {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    },\n    lengthSquared: function () {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    },\n    setTwin: function (edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  Object.assign(VertexList.prototype, {\n    first: function () {\n      return this.head;\n    },\n    last: function () {\n      return this.tail;\n    },\n    clear: function () {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function (target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function (target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function (vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function (vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function (a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    },\n    isEmpty: function () {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\n\nexport { ConvexHull };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}