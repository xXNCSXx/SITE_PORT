{"ast":null,"code":"import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, keys, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */function () {\n  function TreeBuilder() {}\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = [];\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP;\n      this.cstFinallyStateUpdate = NOOP;\n      this.cstPostTerminal = NOOP;\n      this.cstPostNonTerminal = NOOP;\n      this.cstPostRule = NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP;\n        this.setNodeLocationFromNode = NOOP;\n        this.cstPostRule = NOOP;\n        this.setInitialNodeLocation = NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n  return TreeBuilder;\n}();\nexport { TreeBuilder };","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/tree_builder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, keys, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = NOOP;\n            this.cstFinallyStateUpdate = NOOP;\n            this.cstPostTerminal = NOOP;\n            this.cstPostNonTerminal = NOOP;\n            this.cstPostRule = NOOP;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = NOOP;\n                this.setNodeLocationFromNode = NOOP;\n                this.cstPostRule = NOOP;\n                this.setInitialNodeLocation = NOOP;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    return TreeBuilder;\n}());\nexport { TreeBuilder };\n//# sourceMappingURL=tree_builder.js.map"]},"metadata":{},"sourceType":"module"}