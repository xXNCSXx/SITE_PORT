{"ast":null,"code":"import { Vector3, Matrix3 } from 'three';\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nconst PLYExporter = () => {};\nPLYExporter.prototype = {\n  constructor: PLYExporter,\n  parse: function (object, onDone, options) {\n    if (onDone && typeof onDone === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Iterate over the valid meshes in the object\n\n    function traverseMeshes(cb) {\n      object.traverse(child => {\n        if (child.isMesh === true) {\n          const mesh = child;\n          const geometry = mesh.geometry;\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    } // Default options\n\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        if (vertices === undefined) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    const includeIndices = excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n    const indexByteCount = 4;\n    let header =\n    // position\n    `ply\\n${`format ${options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii'} 1.0\\n`}${`element vertex ${vertexCount}\\n`}property float x\\nproperty float y\\nproperty float z\\n`;\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n    if (includeIndices === true) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`;\n    }\n    header += 'end_header\\n'; // Generate attribute data\n\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary === true) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      var writtenVertices = 0;\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (includeUVs !== false) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n          if (includeColors === true) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices === true) {\n          // Create the face list\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      var writtenVertices = 0;\n      let vertexList = '';\n      let faceList = '';\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          let line = `${vertex.x} ${vertex.y} ${vertex.z}`; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += ` ${vertex.x} ${vertex.y} ${vertex.z}`;\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += ` ${uvs.getX(i)} ${uvs.getY(i)}`;\n            } else if (includeUVs !== false) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n          if (includeColors === true) {\n            if (colors != null) {\n              line += ` ${Math.floor(colors.getX(i) * 255)} ${Math.floor(colors.getY(i) * 255)} ${Math.floor(colors.getZ(i) * 255)}`;\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n          vertexList += `${line}\\n`;\n        } // Create the face list\n\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`;\n    }\n    if (typeof onDone === 'function') requestAnimationFrame(() => onDone(result));\n    return result;\n  }\n};\nexport { PLYExporter };","map":{"version":3,"names":["Vector3","Matrix3","PLYExporter","prototype","constructor","parse","object","onDone","options","console","warn","undefined","traverseMeshes","cb","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","hasAttribute","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/PLYExporter.js"],"sourcesContent":["import { Vector3, Matrix3 } from 'three';\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nconst PLYExporter = () => {};\n\nPLYExporter.prototype = {\n  constructor: PLYExporter,\n  parse: function (object, onDone, options) {\n    if (onDone && typeof onDone === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Iterate over the valid meshes in the object\n\n\n    function traverseMeshes(cb) {\n      object.traverse(child => {\n        if (child.isMesh === true) {\n          const mesh = child;\n          const geometry = mesh.geometry;\n\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    } // Default options\n\n\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(child => {\n      if (child.isMesh === true) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n\n        if (vertices === undefined) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    const includeIndices = excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n\n    const indexByteCount = 4;\n    let header = // position\n    `ply\\n${`format ${options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii'} 1.0\\n`}${`element vertex ${vertexCount}\\n`}property float x\\nproperty float y\\nproperty float z\\n`;\n\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n\n    if (includeIndices === true) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`;\n    }\n\n    header += 'end_header\\n'; // Generate attribute data\n\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n\n    if (options.binary === true) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      var writtenVertices = 0;\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (includeUVs !== false) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices === true) {\n          // Create the face list\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      var writtenVertices = 0;\n      let vertexList = '';\n      let faceList = '';\n      traverseMeshes((mesh, geometry) => {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          let line = `${vertex.x} ${vertex.y} ${vertex.z}`; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += ` ${vertex.x} ${vertex.y} ${vertex.z}`;\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += ` ${uvs.getX(i)} ${uvs.getY(i)}`;\n            } else if (includeUVs !== false) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              line += ` ${Math.floor(colors.getX(i) * 255)} ${Math.floor(colors.getY(i) * 255)} ${Math.floor(colors.getZ(i) * 255)}`;\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n\n          vertexList += `${line}\\n`;\n        } // Create the face list\n\n\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`;\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`;\n    }\n\n    if (typeof onDone === 'function') requestAnimationFrame(() => onDone(result));\n    return result;\n  }\n};\n\nexport { PLYExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}