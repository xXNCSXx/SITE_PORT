{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function (msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = reject(tokenTypes, function (currType) {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n      if (isRegExp(currPattern)) {\n        var regExpSource = currPattern.source;\n        if (regExpSource.length === 1 &&\n        // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" &&\n        // not a meta character\n        !contains([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true;\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return {\n          exec: currPattern\n        };\n      } else if (has(currPattern, \"exec\")) {\n        hasCustom = true;\n        // ICustomPattern\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdx;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = map(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n        return longerAltIdx;\n      }\n    });\n    patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n      return has(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS;\n        } else {\n          if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n            return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          }\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n      if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            // Avoid adding the config multiple times\n            /* istanbul ignore else */\n            // - Difficult to check this scenario effects as it is only a performance\n            //   optimization that does not change correctness\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n            if (isEmpty(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n            forEach(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  tracer(\"ArrayPacking\", function () {\n    charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n  });\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n    return isRegExp(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n    return !has(currType, PATTERN);\n  });\n  var errors = map(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexport function findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !isRegExp(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n  });\n  var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder = /** @class */function (_super) {\n    __extends(EndAnchorFinder, _super);\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n    return EndAnchorFinder;\n  }(BaseRegExpVisitor);\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern.test(\"\");\n  });\n  var errors = map(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder = /** @class */function (_super) {\n    __extends(StartAnchorFinder, _super);\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.found = false;\n      return _this;\n    }\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n    return StartAnchorFinder;\n  }(BaseRegExpVisitor);\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = map(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = map(tokenTypes, function (outerType) {\n    return reduce(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !contains(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact(identicalPatterns);\n  var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = map(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = map(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = first(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" + (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n  var invalidTypes = filter(tokenTypes, function (clazz) {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n    var group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n  var errors = map(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = filter(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !contains(validModes, clazz.PUSH_MODE);\n  });\n  var errors = map(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" + \"which does not exist\";\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n    if (pattern === Lexer.NA) {\n      return result;\n    }\n    // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n    if (isString(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n    return result;\n  }, []);\n  forEach(tokenTypes, function (tokType, testIdx) {\n    forEach(canBeTested, function (_a) {\n      var str = _a.str,\n        idx = _a.idx,\n        tokenType = _a.tokenType;\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" + (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") + \"in the lexer's definition.\\n\" + \"See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return find(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\nexport function addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = [];\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" + \"which does not exist\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n      forEach(currModeValue, function (currTokType, currIdx) {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) {\n    return tokTypes;\n  })));\n  var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n    return currType[PATTERN] === Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = keys(emptyGroups);\n  forEach(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function isShortPattern(pattern) {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport var LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    var len = text.length;\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + (\"\\t Root cause: \" + details.errMsg + \".\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = map(charsOrCodes, function (numOrString) {\n    if (isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nexport function charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (var i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n      /* tslint:enable */\n    }\n  }\n}","map":{"version":3,"names":["BaseRegExpVisitor","Lexer","LexerDefinitionErrorType","compact","contains","defaults","difference","filter","find","first","flatten","forEach","has","indexOf","isArray","isEmpty","isFunction","isRegExp","isString","isUndefined","keys","map","mapValues","packArray","PRINT_ERROR","reduce","reject","canMatchCharCode","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","getRegExpAst","PATTERN","DEFAULT_MODE","MODES","SUPPORT_STICKY","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","ignoreCase","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdx","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdx","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","toString","optimizedCodes","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","concat","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","type","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","EndAnchorFinder","_super","__extends","_this","apply","arguments","found","prototype","visitEndAnchor","node","invalidRegex","regexpAst","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","flags","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","tokTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","key","value","minOptimizationVal","charCodeToOptimizedIdxMap","Array"],"sources":["../../../src/scan/lexer.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}