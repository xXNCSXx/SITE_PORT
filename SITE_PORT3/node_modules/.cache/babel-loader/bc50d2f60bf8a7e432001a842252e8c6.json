{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n        uint8Array = new Uint8Array(buffer),\n        uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n      result;\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n        getMethod = getMethods[viewType.name],\n        littleEndian = !fromBigEndian,\n        i = 0;\n      result = new viewType(length);\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n    return result;\n  }\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n      version = array[0],\n      flags = array[1],\n      indexedGeometry = !!(flags >> 7 & 0x01),\n      indicesType = flags >> 6 & 0x01,\n      bigEndian = (flags >> 5 & 0x01) === 1,\n      attributesNumber = flags & 0x1f,\n      valuesNumber = 0,\n      indicesNumber = 0;\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n    var pos = 8;\n    var attributes = {},\n      attributeName,\n      char,\n      attributeType,\n      cardinality,\n      encodingType,\n      arrayType,\n      values,\n      indices,\n      i;\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n        attributesKey = Object.keys(data.attributes),\n        bufferGeometry = new BufferGeometry(),\n        attribute,\n        i;\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n      return bufferGeometry;\n    }\n  });\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n  return PRWMLoader;\n}();\nexport { PRWMLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","PRWMLoader","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","bytesPerElement","BYTES_PER_ELEMENT","result","readView","DataView","getMethod","name","littleEndian","i","decodePrwm","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","pos","attributes","attributeName","char","attributeType","cardinality","encodingType","arrayType","values","indices","String","fromCharCode","Math","ceil","type","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","replace","arrayBuffer","parse","e","console","error","itemError","data","attributesKey","keys","bufferGeometry","attribute","setAttribute","normalized","setIndex"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/PRWMLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nvar PRWMLoader = function () {\n  var bigEndianPlatform = null;\n  /**\n   * Check if the endianness of the platform is big-endian (most significant bit first)\n   * @returns {boolean} True if big-endian, false if little-endian\n   */\n\n  function isBigEndianPlatform() {\n    if (bigEndianPlatform === null) {\n      var buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n      uint8Array[0] = 0xaa; // set first byte\n\n      uint8Array[1] = 0xbb; // set second byte\n\n      bigEndianPlatform = uint16Array[0] === 0xaabb;\n    }\n\n    return bigEndianPlatform;\n  } // match the values defined in the spec to the TypedArray types\n\n\n  var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\n  var getMethods = {\n    Uint16Array: 'getUint16',\n    Uint32Array: 'getUint32',\n    Int16Array: 'getInt16',\n    Int32Array: 'getInt32',\n    Float32Array: 'getFloat32',\n    Float64Array: 'getFloat64'\n  };\n\n  function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n    var bytesPerElement = viewType.BYTES_PER_ELEMENT,\n        result;\n\n    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n      result = new viewType(sourceArrayBuffer, position, length);\n    } else {\n      var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian,\n          i = 0;\n      result = new viewType(length);\n\n      for (; i < length; i++) {\n        result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n      }\n    }\n\n    return result;\n  }\n\n  function decodePrwm(buffer) {\n    var array = new Uint8Array(buffer),\n        version = array[0],\n        flags = array[1],\n        indexedGeometry = !!(flags >> 7 & 0x01),\n        indicesType = flags >> 6 & 0x01,\n        bigEndian = (flags >> 5 & 0x01) === 1,\n        attributesNumber = flags & 0x1f,\n        valuesNumber = 0,\n        indicesNumber = 0;\n\n    if (bigEndian) {\n      valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n      indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n    } else {\n      valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n      indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n    }\n    /** PRELIMINARY CHECKS **/\n\n\n    if (version === 0) {\n      throw new Error('PRWM decoder: Invalid format version: 0');\n    } else if (version !== 1) {\n      throw new Error('PRWM decoder: Unsupported format version: ' + version);\n    }\n\n    if (!indexedGeometry) {\n      if (indicesType !== 0) {\n        throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n      } else if (indicesNumber !== 0) {\n        throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n      }\n    }\n    /** PARSING **/\n\n\n    var pos = 8;\n    var attributes = {},\n        attributeName,\n        char,\n        attributeType,\n        cardinality,\n        encodingType,\n        arrayType,\n        values,\n        indices,\n        i;\n\n    for (i = 0; i < attributesNumber; i++) {\n      attributeName = '';\n\n      while (pos < array.length) {\n        char = array[pos];\n        pos++;\n\n        if (char === 0) {\n          break;\n        } else {\n          attributeName += String.fromCharCode(char);\n        }\n      }\n\n      flags = array[pos];\n      attributeType = flags >> 7 & 0x01;\n      cardinality = (flags >> 4 & 0x03) + 1;\n      encodingType = flags & 0x0f;\n      arrayType = InvertedEncodingTypes[encodingType];\n      pos++; // padding to next multiple of 4\n\n      pos = Math.ceil(pos / 4) * 4;\n      values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n      pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n      attributes[attributeName] = {\n        type: attributeType,\n        cardinality: cardinality,\n        values: values\n      };\n    }\n\n    pos = Math.ceil(pos / 4) * 4;\n    indices = null;\n\n    if (indexedGeometry) {\n      indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n    }\n\n    return {\n      version: version,\n      attributes: attributes,\n      indices: indices\n    };\n  } // Define the public interface\n\n\n  function PRWMLoader(manager) {\n    Loader.call(this, manager);\n  }\n\n  PRWMLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: PRWMLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry(),\n          attribute,\n          i;\n\n      for (i = 0; i < attributesKey.length; i++) {\n        attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  });\n\n  PRWMLoader.isBigEndianPlatform = function () {\n    return isBigEndianPlatform();\n  };\n\n  return PRWMLoader;\n}();\n\nexport { PRWMLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}