{"ast":null,"code":"import { DataTextureLoader, FloatType, HalfFloatType, UnsignedByteType, RGBEFormat, RGBAFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = FloatType;\n};\nEXRLoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: EXRLoader,\n  parse: function (buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    var tmpDataView = new DataView(new ArrayBuffer(8));\n    function frexp(value) {\n      if (value === 0) return [value, 0];\n      tmpDataView.setFloat64(0, value);\n      var bits = tmpDataView.getUint32(0) >>> 20 & 0x7ff;\n      if (bits === 0) {\n        // denormal\n        tmpDataView.setFloat64(0, value * Math.pow(2, 64)); // exp + 64\n\n        bits = (tmpDataView.getUint32(0) >>> 20 & 0x7ff) - 64;\n      }\n      var exponent = bits - 1022;\n      var mantissa = ldexp(value, -exponent);\n      return [mantissa, exponent];\n    }\n    function ldexp(mantissa, exponent) {\n      var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n      var result = mantissa;\n      for (let i = 0; i < steps; i++) result *= Math.pow(2, Math.floor((exponent + i) / steps));\n      return result;\n    }\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (let i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE) lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (let i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (let i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (let i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (let i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n) p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (let i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (let t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (let i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (let i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n        let offset = 0;\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n        for (let y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n          for (let x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n          for (let x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (let row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (let column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (let i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (let i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var tmpBufSize = info.width * scanlineBlockSize * (EXRHeader.channels.length * info.type);\n      var outBuffer = new Uint16Array(tmpBufSize);\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (let i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n      if (minNonZero <= maxNonZero) {\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      if (typeof fflate === 'undefined') {\n        console.error('THREE.EXRLoader: External library fflate.min.js required.');\n      }\n      var rawBuffer = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (EXRHeader.channels.length * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'; // Read channel ruleset information\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (let offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n        for (let i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (let i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (let y = 0; y < info.lines; ++y) {\n        for (let chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (let i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (let y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (let x = 0; x < cd.width; ++x) {\n                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n    function parseUlong(dataView, offset) {\n      var uLong = dataView.getUint32(0, true);\n      offset.value = offset.value + ULONG_SIZE;\n      return uLong;\n    }\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseInt64(dataView, offset) {\n      var int = Number(dataView.getBigInt64(offset.value, true));\n      offset.value += ULONG_SIZE;\n      return int;\n    }\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n      offset.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n    var bufferDataView = new DataView(buffer);\n    var uInt8Array = new Uint8Array(buffer);\n    var EXRHeader = {};\n    bufferDataView.getUint32(0, true); // magic\n\n    bufferDataView.getUint8(4, true); // versionByteZero\n\n    bufferDataView.getUint8(5, true); // fullMask\n    // start of header\n\n    var offset = {\n      value: 8\n    }; // start at 8, after magic stuff\n\n    var keepReading = true;\n    while (keepReading) {\n      var attributeName = parseNullTerminatedString(buffer, offset);\n      if (attributeName == 0) {\n        keepReading = false;\n      } else {\n        var attributeType = parseNullTerminatedString(buffer, offset);\n        var attributeSize = parseUint32(bufferDataView, offset);\n        var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n        if (attributeValue === undefined) {\n          console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n        } else {\n          EXRHeader[attributeName] = attributeValue;\n        }\n      }\n    } // offsets\n\n    var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n    var uncompress;\n    var scanlineBlockSize;\n    switch (EXRHeader.compression) {\n      case 'NO_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRAW;\n        break;\n      case 'RLE_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRLE;\n        break;\n      case 'ZIPS_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressZIP;\n        break;\n      case 'ZIP_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressZIP;\n        break;\n      case 'PIZ_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressPIZ;\n        break;\n      case 'PXR24_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressPXR;\n        break;\n      case 'DWAA_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressDWA;\n        break;\n      case 'DWAB_COMPRESSION':\n        scanlineBlockSize = 256;\n        uncompress = uncompressDWA;\n        break;\n      default:\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n    }\n    var size_t;\n    var getValue; // mixed pixelType not supported\n\n    var pixelType = EXRHeader.channels[0].pixelType;\n    if (pixelType === 1) {\n      // half\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat16;\n          size_t = INT16_SIZE;\n          break;\n        case HalfFloatType:\n          getValue = parseUint16;\n          size_t = INT16_SIZE;\n          break;\n      }\n    } else if (pixelType === 2) {\n      // float\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat32;\n          size_t = FLOAT32_SIZE;\n          break;\n        case HalfFloatType:\n          getValue = decodeFloat32;\n          size_t = FLOAT32_SIZE;\n      }\n    } else {\n      throw 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n    }\n    var numBlocks = dataWindowHeight / scanlineBlockSize;\n    for (let i = 0; i < numBlocks; i++) {\n      parseUlong(bufferDataView, offset); // scanlineOffset\n    } // we should be passed the scanline offset table, start reading pixel data\n\n    var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n    var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1; // Firefox only supports RGBA (half) float textures\n    // var numChannels = EXRHeader.channels.length;\n\n    var numChannels = 4;\n    var size = width * height * numChannels; // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n    switch (this.type) {\n      case UnsignedByteType:\n      case FloatType:\n        var byteArray = new Float32Array(size);\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(1, 0, size);\n        }\n        break;\n      case HalfFloatType:\n        var byteArray = new Uint16Array(size);\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n        }\n        break;\n      default:\n        console.error('THREE.EXRLoader: unsupported type: ', this.type);\n        break;\n    }\n    var channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3\n    };\n    var compressionInfo = {\n      size: 0,\n      width: width,\n      lines: scanlineBlockSize,\n      offset: offset,\n      array: uInt8Array,\n      viewer: bufferDataView,\n      type: pixelType,\n      channels: EXRHeader.channels.length\n    };\n    var line;\n    var size;\n    var viewer;\n    var tmpOffset = {\n      value: 0\n    };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n      line = parseUint32(bufferDataView, offset); // line_no\n\n      size = parseUint32(bufferDataView, offset); // data_len\n\n      compressionInfo.lines = line + scanlineBlockSize > height ? height - line : scanlineBlockSize;\n      compressionInfo.offset = offset;\n      compressionInfo.size = size;\n      viewer = uncompress(compressionInfo);\n      offset.value += size;\n      for (let line_y = 0; line_y < scanlineBlockSize; line_y++) {\n        var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n        if (true_y >= height) break;\n        for (let channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n          var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < width; x++) {\n            var idx = line_y * (EXRHeader.channels.length * width) + channelID * width + x;\n            tmpOffset.value = idx * size_t;\n            var val = getValue(viewer, tmpOffset);\n            byteArray[(height - 1 - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n          }\n        }\n      }\n    }\n    if (this.type === UnsignedByteType) {\n      let v, i;\n      const size = byteArray.length;\n      const RGBEArray = new Uint8Array(size);\n      for (let h = 0; h < height; ++h) {\n        for (let w = 0; w < width; ++w) {\n          i = h * width * 4 + w * 4;\n          const red = byteArray[i];\n          const green = byteArray[i + 1];\n          const blue = byteArray[i + 2];\n          v = red > green ? red : green;\n          v = blue > v ? blue : v;\n          if (v < 1e-32) {\n            RGBEArray[i] = RGBEArray[i + 1] = RGBEArray[i + 2] = RGBEArray[i + 3] = 0;\n          } else {\n            const res = frexp(v);\n            v = res[0] * 256 / v;\n            RGBEArray[i] = red * v;\n            RGBEArray[i + 1] = green * v;\n            RGBEArray[i + 2] = blue * v;\n            RGBEArray[i + 3] = res[1] + 128;\n          }\n        }\n      }\n      byteArray = RGBEArray;\n    }\n    const format = this.type === UnsignedByteType ? RGBEFormat : RGBAFormat;\n    return {\n      header: EXRHeader,\n      width: width,\n      height: height,\n      data: byteArray,\n      format: format,\n      type: this.type\n    };\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n        case FloatType:\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n      }\n      if (onLoad) onLoad(texture, texData);\n    }\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","FloatType","HalfFloatType","UnsignedByteType","RGBEFormat","RGBAFormat","LinearEncoding","LinearFilter","RGBEEncoding","NearestFilter","DataUtils","unzlibSync","EXRLoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","tmpDataView","DataView","ArrayBuffer","frexp","value","setFloat64","bits","getUint32","exponent","mantissa","ldexp","steps","min","ceil","abs","result","i","floor","reverseLutFromBitmap","bitmap","lut","k","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","stop","decodeRunLength","size","byteLength","reader","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","tmpBufSize","scanlineBlockSize","EXRHeader","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","fflate","console","error","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseUlong","uLong","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","Uint8","int","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","undefined","bufferDataView","keepReading","attributeName","attributeType","attributeSize","attributeValue","warn","dataWindowHeight","dataWindow","uncompress","size_t","getValue","numBlocks","numChannels","byteArray","channelOffsets","R","G","B","A","compressionInfo","line","scanlineBlockIdx","line_y","true_y","channelID","cOff","val","v","RGBEArray","w","red","green","blue","res","format","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"sources":["C:/Users/drncs/OneDrive/rea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/EXRLoader.js"],"sourcesContent":["import { DataTextureLoader, FloatType, HalfFloatType, UnsignedByteType, RGBEFormat, RGBAFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = FloatType;\n};\n\nEXRLoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: EXRLoader,\n  parse: function (buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    var tmpDataView = new DataView(new ArrayBuffer(8));\n\n    function frexp(value) {\n      if (value === 0) return [value, 0];\n      tmpDataView.setFloat64(0, value);\n      var bits = tmpDataView.getUint32(0) >>> 20 & 0x7ff;\n\n      if (bits === 0) {\n        // denormal\n        tmpDataView.setFloat64(0, value * Math.pow(2, 64)); // exp + 64\n\n        bits = (tmpDataView.getUint32(0) >>> 20 & 0x7ff) - 64;\n      }\n\n      var exponent = bits - 1022;\n      var mantissa = ldexp(value, -exponent);\n      return [mantissa, exponent];\n    }\n\n    function ldexp(mantissa, exponent) {\n      var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n      var result = mantissa;\n\n      for (let i = 0; i < steps; i++) result *= Math.pow(2, Math.floor((exponent + i) / steps));\n\n      return result;\n    }\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (let i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (let i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (let i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (let i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (let i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (let i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (let t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (let i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (let i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n\n        let offset = 0;\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (let y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n\n          for (let x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n\n          for (let x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (let row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (let column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (let i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (let i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var tmpBufSize = info.width * scanlineBlockSize * (EXRHeader.channels.length * info.type);\n      var outBuffer = new Uint16Array(tmpBufSize);\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (let i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n\n      if (typeof fflate === 'undefined') {\n        console.error('THREE.EXRLoader: External library fflate.min.js required.');\n      }\n\n      var rawBuffer = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (EXRHeader.channels.length * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'; // Read channel ruleset information\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (let i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (let offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n\n        for (let i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = fflate.unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (let i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (let y = 0; y < info.lines; ++y) {\n        for (let chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (let i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (let y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (let x = 0; x < cd.width; ++x) {\n                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseUlong(dataView, offset) {\n      var uLong = dataView.getUint32(0, true);\n      offset.value = offset.value + ULONG_SIZE;\n      return uLong;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseInt64(dataView, offset) {\n      var int = Number(dataView.getBigInt64(offset.value, true));\n      offset.value += ULONG_SIZE;\n      return int;\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    var bufferDataView = new DataView(buffer);\n    var uInt8Array = new Uint8Array(buffer);\n    var EXRHeader = {};\n    bufferDataView.getUint32(0, true); // magic\n\n    bufferDataView.getUint8(4, true); // versionByteZero\n\n    bufferDataView.getUint8(5, true); // fullMask\n    // start of header\n\n    var offset = {\n      value: 8\n    }; // start at 8, after magic stuff\n\n    var keepReading = true;\n\n    while (keepReading) {\n      var attributeName = parseNullTerminatedString(buffer, offset);\n\n      if (attributeName == 0) {\n        keepReading = false;\n      } else {\n        var attributeType = parseNullTerminatedString(buffer, offset);\n        var attributeSize = parseUint32(bufferDataView, offset);\n        var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n\n        if (attributeValue === undefined) {\n          console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n        } else {\n          EXRHeader[attributeName] = attributeValue;\n        }\n      }\n    } // offsets\n\n\n    var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n    var uncompress;\n    var scanlineBlockSize;\n\n    switch (EXRHeader.compression) {\n      case 'NO_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRAW;\n        break;\n\n      case 'RLE_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressRLE;\n        break;\n\n      case 'ZIPS_COMPRESSION':\n        scanlineBlockSize = 1;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'ZIP_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressZIP;\n        break;\n\n      case 'PIZ_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressPIZ;\n        break;\n\n      case 'PXR24_COMPRESSION':\n        scanlineBlockSize = 16;\n        uncompress = uncompressPXR;\n        break;\n\n      case 'DWAA_COMPRESSION':\n        scanlineBlockSize = 32;\n        uncompress = uncompressDWA;\n        break;\n\n      case 'DWAB_COMPRESSION':\n        scanlineBlockSize = 256;\n        uncompress = uncompressDWA;\n        break;\n\n      default:\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n    }\n\n    var size_t;\n    var getValue; // mixed pixelType not supported\n\n    var pixelType = EXRHeader.channels[0].pixelType;\n\n    if (pixelType === 1) {\n      // half\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat16;\n          size_t = INT16_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = parseUint16;\n          size_t = INT16_SIZE;\n          break;\n      }\n    } else if (pixelType === 2) {\n      // float\n      switch (this.type) {\n        case UnsignedByteType:\n        case FloatType:\n          getValue = parseFloat32;\n          size_t = FLOAT32_SIZE;\n          break;\n\n        case HalfFloatType:\n          getValue = decodeFloat32;\n          size_t = FLOAT32_SIZE;\n      }\n    } else {\n      throw 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n    }\n\n    var numBlocks = dataWindowHeight / scanlineBlockSize;\n\n    for (let i = 0; i < numBlocks; i++) {\n      parseUlong(bufferDataView, offset); // scanlineOffset\n    } // we should be passed the scanline offset table, start reading pixel data\n\n\n    var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n    var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1; // Firefox only supports RGBA (half) float textures\n    // var numChannels = EXRHeader.channels.length;\n\n    var numChannels = 4;\n    var size = width * height * numChannels; // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n    switch (this.type) {\n      case UnsignedByteType:\n      case FloatType:\n        var byteArray = new Float32Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(1, 0, size);\n        }\n\n        break;\n\n      case HalfFloatType:\n        var byteArray = new Uint16Array(size);\n\n        if (EXRHeader.channels.length < numChannels) {\n          byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n        }\n\n        break;\n\n      default:\n        console.error('THREE.EXRLoader: unsupported type: ', this.type);\n        break;\n    }\n\n    var channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3\n    };\n    var compressionInfo = {\n      size: 0,\n      width: width,\n      lines: scanlineBlockSize,\n      offset: offset,\n      array: uInt8Array,\n      viewer: bufferDataView,\n      type: pixelType,\n      channels: EXRHeader.channels.length\n    };\n    var line;\n    var size;\n    var viewer;\n    var tmpOffset = {\n      value: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n      line = parseUint32(bufferDataView, offset); // line_no\n\n      size = parseUint32(bufferDataView, offset); // data_len\n\n      compressionInfo.lines = line + scanlineBlockSize > height ? height - line : scanlineBlockSize;\n      compressionInfo.offset = offset;\n      compressionInfo.size = size;\n      viewer = uncompress(compressionInfo);\n      offset.value += size;\n\n      for (let line_y = 0; line_y < scanlineBlockSize; line_y++) {\n        var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n        if (true_y >= height) break;\n\n        for (let channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n          var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < width; x++) {\n            var idx = line_y * (EXRHeader.channels.length * width) + channelID * width + x;\n            tmpOffset.value = idx * size_t;\n            var val = getValue(viewer, tmpOffset);\n            byteArray[(height - 1 - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n          }\n        }\n      }\n    }\n\n    if (this.type === UnsignedByteType) {\n      let v, i;\n      const size = byteArray.length;\n      const RGBEArray = new Uint8Array(size);\n\n      for (let h = 0; h < height; ++h) {\n        for (let w = 0; w < width; ++w) {\n          i = h * width * 4 + w * 4;\n          const red = byteArray[i];\n          const green = byteArray[i + 1];\n          const blue = byteArray[i + 2];\n          v = red > green ? red : green;\n          v = blue > v ? blue : v;\n\n          if (v < 1e-32) {\n            RGBEArray[i] = RGBEArray[i + 1] = RGBEArray[i + 2] = RGBEArray[i + 3] = 0;\n          } else {\n            const res = frexp(v);\n            v = res[0] * 256 / v;\n            RGBEArray[i] = red * v;\n            RGBEArray[i + 1] = green * v;\n            RGBEArray[i + 2] = blue * v;\n            RGBEArray[i + 3] = res[1] + 128;\n          }\n        }\n      }\n\n      byteArray = RGBEArray;\n    }\n\n    const format = this.type === UnsignedByteType ? RGBEFormat : RGBAFormat ;\n    return {\n      header: EXRHeader,\n      width: width,\n      height: height,\n      data: byteArray,\n      format: format,\n      type: this.type\n    };\n  },\n  setDataType: function (value) {\n    this.type = value;\n    return this;\n  },\n  load: function (url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n\n        case FloatType:\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = false;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\n\nexport { EXRLoader };\n"],"mappings":"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AAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAA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","ignoreList":[]},"metadata":{},"sourceType":"module"}