{"ast":null,"code":"import { MeshBasicMaterial, Matrix4, Color, DoubleSide } from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  var exporter = new ColladaExporter();\n *\n *  var data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nconst ColladaExporter = () => {};\nColladaExporter.prototype = {\n  constructor: ColladaExporter,\n  parse: function (object, onDone, options) {\n    options = options || {};\n    options = Object.assign({\n      version: '1.4.1',\n      author: null,\n      textureDirectory: ''\n    }, options);\n    if (options.textureDirectory !== '') {\n      options.textureDirectory = `${options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n    const version = options.version;\n    if (version !== '1.4.1' && version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    } // Convert the urdf xml into a well-formatted, indented format\n\n    function format(urdf) {\n      const IS_END_TAG = /^<\\//;\n      const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n      const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n      let tagnum = 0;\n      return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(tag => {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n        const res = `${pad('  ', tagnum)}${tag}`;\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n        return res;\n      }).join('\\n');\n    } // Convert an image into a png format for saving\n\n    function base64ToBuffer(str) {\n      const b = atob(str);\n      const buf = new Uint8Array(b.length);\n      for (let i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n      return buf;\n    }\n    let canvas, ctx;\n    function imageToData(image, ext) {\n      canvas = canvas || document.createElement('canvas');\n      ctx = ctx || canvas.getContext('2d');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n      const base64data = canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n      return base64ToBuffer(base64data);\n    } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n    const getFuncs = ['getX', 'getY', 'getZ', 'getW'];\n    function attrBufferToArray(attr) {\n      if (attr.isInterleavedBufferAttribute) {\n        // use the typed array constructor to save on memory\n        const arr = new attr.array.constructor(attr.count * attr.itemSize);\n        const size = attr.itemSize;\n        for (let i = 0, l = attr.count; i < l; i++) {\n          for (let j = 0; j < size; j++) {\n            arr[i * size + j] = attr[getFuncs[j]](i);\n          }\n        }\n        return arr;\n      } else {\n        return attr.array;\n      }\n    } // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n\n    function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) return arr.slice(st, st + ct);else return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    } // Returns the string for a geometry's attribute\n\n    function getAttribute(attr, name, params, type) {\n      const array = attrBufferToArray(attr);\n      const res = `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>`;\n      return res;\n    } // Returns the string for a node's transform information\n\n    let transMat;\n    function getTransform(o) {\n      // ensure the object's matrix is up to date\n      // before saving the transform\n      o.updateMatrix();\n      transMat = transMat || new Matrix4();\n      transMat.copy(o.matrix);\n      transMat.transpose();\n      return `<matrix>${transMat.toArray().join(' ')}</matrix>`;\n    } // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n\n    function processGeometry(g) {\n      let info = geometryInfo.get(g);\n      if (!info) {\n        // convert the geometry to bufferGeometry if it isn't already\n        const bufferGeometry = g;\n        if (bufferGeometry.isBufferGeometry !== true) {\n          throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n        const meshid = `Mesh${libraryGeometries.length + 1}`;\n        const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        const gname = g.name ? ` name=\"${g.name}\"` : '';\n        let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n        const posName = `${meshid}-position`;\n        const vertName = `${meshid}-vertices`;\n        gnode += getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n        gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n        // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n        // models with attributes that share an offset.\n        // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n        // serialize normals\n\n        let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n        if ('normal' in bufferGeometry.attributes) {\n          const normName = `${meshid}-normal`;\n          gnode += getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n          triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n        } // serialize uvs\n\n        if ('uv' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord`;\n          gnode += getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n        } // serialize lightmap uvs\n\n        if ('uv2' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord2`;\n          gnode += getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n        } // serialize colors\n\n        if ('color' in bufferGeometry.attributes) {\n          const colName = `${meshid}-color`;\n          gnode += getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n          triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n        }\n        let indexArray = null;\n        if (bufferGeometry.index) {\n          indexArray = attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n          for (let i = 0, l = indexArray.length; i < l; i++) indexArray[i] = i;\n        }\n        for (let i = 0, l = groups.length; i < l; i++) {\n          const group = groups[i];\n          const subarr = subArray(indexArray, group.start, group.count);\n          const polycount = subarr.length / 3;\n          gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n          gnode += triangleInputs;\n          gnode += `<p>${subarr.join(' ')}</p>`;\n          gnode += '</triangles>';\n        }\n        gnode += '</mesh></geometry>';\n        libraryGeometries.push(gnode);\n        info = {\n          meshid,\n          bufferGeometry\n        };\n        geometryInfo.set(g, info);\n      }\n      return info;\n    } // Process the given texture into the image library\n    // Returns the image library\n\n    function processTexture(tex) {\n      let texid = imageMap.get(tex);\n      if (texid == null) {\n        texid = `image-${libraryImages.length + 1}`;\n        const ext = 'png';\n        const name = tex.name || texid;\n        let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n        if (version === '1.5.0') {\n          imageNode += `<init_from><ref>${options.textureDirectory}${name}.${ext}</ref></init_from>`;\n        } else {\n          // version image node 1.4.1\n          imageNode += `<init_from>${options.textureDirectory}${name}.${ext}</init_from>`;\n        }\n        imageNode += '</image>';\n        libraryImages.push(imageNode);\n        imageMap.set(tex, texid);\n        textures.push({\n          directory: options.textureDirectory,\n          name,\n          ext,\n          data: imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n      return texid;\n    } // Process the given material into the material and effect libraries\n    // Returns the material id\n\n    function processMaterial(m) {\n      let matid = materialMap.get(m);\n      if (matid == null) {\n        matid = `Mat${libraryEffects.length + 1}`;\n        let type = 'phong';\n        if (m.isMeshLambertMaterial === true) {\n          type = 'lambert';\n        } else if (m.isMeshBasicMaterial === true) {\n          type = 'constant';\n          if (m.map !== null) {\n            // The Collada spec does not support diffuse texture maps with the\n            // constant shader type.\n            // mrdoob/three.js#15469\n            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n          }\n        }\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n        if (m.transparent === true) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        libraryMaterials.push(materialNode);\n        libraryEffects.push(effectnode);\n        materialMap.set(m, matid);\n      }\n      return matid;\n    } // Recursively process the object into a scene\n\n    function processObject(o) {\n      let node = `<node name=\"${o.name}\">`;\n      node += getTransform(o);\n      if (o.isMesh === true && o.geometry !== null) {\n        // function returns the id associated with the mesh and a \"BufferGeometry\" version\n        // of the geometry in case it's not a geometry.\n        const geomInfo = processGeometry(o.geometry);\n        const meshid = geomInfo.meshid;\n        const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n        let matids = null;\n        let matidsArray = []; // get a list of materials to bind to the sub groups of the geometry.\n        // If the amount of subgroups is greater than the materials, than reuse\n        // the materials.\n\n        const mat = o.material || new MeshBasicMaterial();\n        const materials = Array.isArray(mat) ? mat : [mat];\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n        matids = matidsArray.fill().map((v, i) => processMaterial(materials[i % materials.length]));\n        node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n      }\n      o.children.forEach(c => node += processObject(c));\n      node += '</node>';\n      return node;\n    }\n    var geometryInfo = new WeakMap();\n    var materialMap = new WeakMap();\n    var imageMap = new WeakMap();\n    var textures = [];\n    var libraryImages = [];\n    var libraryGeometries = [];\n    var libraryEffects = [];\n    var libraryMaterials = [];\n    const libraryVisualScenes = processObject(object);\n    const specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${options.author !== null ? `<author>${options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: format(dae),\n      textures\n    };\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n};\nexport { ColladaExporter };","map":{"version":3,"names":["MeshBasicMaterial","Matrix4","Color","DoubleSide","ColladaExporter","prototype","constructor","parse","object","onDone","options","Object","assign","version","author","textureDirectory","replace","console","warn","format","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","match","map","tag","test","res","join","base64ToBuffer","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","canvas","ctx","imageToData","image","ext","document","createElement","getContext","width","height","drawImage","base64data","toDataURL","getFuncs","attrBufferToArray","attr","isInterleavedBufferAttribute","arr","array","count","itemSize","size","j","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","transMat","getTransform","o","updateMatrix","copy","matrix","transpose","toArray","processGeometry","g","info","geometryInfo","get","bufferGeometry","isBufferGeometry","Error","meshid","libraryGeometries","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","uv2","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageMap","libraryImages","imageNode","textures","directory","data","original","processMaterial","m","matid","materialMap","libraryEffects","isMeshLambertMaterial","isMeshBasicMaterial","emissive","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","materialName","materialNode","libraryMaterials","processObject","node","isMesh","geometry","geomInfo","matids","matidsArray","mat","material","materials","fill","v","id","children","forEach","c","WeakMap","libraryVisualScenes","specLink","dae","Date","toISOString","requestAnimationFrame"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/exporters/ColladaExporter.js"],"sourcesContent":["import { MeshBasicMaterial, Matrix4, Color, DoubleSide } from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  var exporter = new ColladaExporter();\n *\n *  var data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nconst ColladaExporter = () => {};\n\nColladaExporter.prototype = {\n  constructor: ColladaExporter,\n  parse: function (object, onDone, options) {\n    options = options || {};\n    options = Object.assign({\n      version: '1.4.1',\n      author: null,\n      textureDirectory: ''\n    }, options);\n\n    if (options.textureDirectory !== '') {\n      options.textureDirectory = `${options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    const version = options.version;\n\n    if (version !== '1.4.1' && version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    } // Convert the urdf xml into a well-formatted, indented format\n\n\n    function format(urdf) {\n      const IS_END_TAG = /^<\\//;\n      const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n      const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n\n      let tagnum = 0;\n      return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(tag => {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n\n        const res = `${pad('  ', tagnum)}${tag}`;\n\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n\n        return res;\n      }).join('\\n');\n    } // Convert an image into a png format for saving\n\n\n    function base64ToBuffer(str) {\n      const b = atob(str);\n      const buf = new Uint8Array(b.length);\n\n      for (let i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n\n      return buf;\n    }\n\n    let canvas, ctx;\n\n    function imageToData(image, ext) {\n      canvas = canvas || document.createElement('canvas');\n      ctx = ctx || canvas.getContext('2d');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n      const base64data = canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n      return base64ToBuffer(base64data);\n    } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n    const getFuncs = ['getX', 'getY', 'getZ', 'getW'];\n\n    function attrBufferToArray(attr) {\n      if (attr.isInterleavedBufferAttribute) {\n        // use the typed array constructor to save on memory\n        const arr = new attr.array.constructor(attr.count * attr.itemSize);\n        const size = attr.itemSize;\n\n        for (let i = 0, l = attr.count; i < l; i++) {\n          for (let j = 0; j < size; j++) {\n            arr[i * size + j] = attr[getFuncs[j]](i);\n          }\n        }\n\n        return arr;\n      } else {\n        return attr.array;\n      }\n    } // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n\n\n    function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) return arr.slice(st, st + ct);else return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    } // Returns the string for a geometry's attribute\n\n\n    function getAttribute(attr, name, params, type) {\n      const array = attrBufferToArray(attr);\n      const res = `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>`;\n      return res;\n    } // Returns the string for a node's transform information\n\n\n    let transMat;\n\n    function getTransform(o) {\n      // ensure the object's matrix is up to date\n      // before saving the transform\n      o.updateMatrix();\n      transMat = transMat || new Matrix4();\n      transMat.copy(o.matrix);\n      transMat.transpose();\n      return `<matrix>${transMat.toArray().join(' ')}</matrix>`;\n    } // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n\n\n    function processGeometry(g) {\n      let info = geometryInfo.get(g);\n\n      if (!info) {\n        // convert the geometry to bufferGeometry if it isn't already\n        const bufferGeometry = g;\n\n        if (bufferGeometry.isBufferGeometry !== true) {\n          throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        const meshid = `Mesh${libraryGeometries.length + 1}`;\n        const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        const gname = g.name ? ` name=\"${g.name}\"` : '';\n        let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n        const posName = `${meshid}-position`;\n        const vertName = `${meshid}-vertices`;\n        gnode += getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n        gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n        // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n        // models with attributes that share an offset.\n        // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n        // serialize normals\n\n        let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n\n        if ('normal' in bufferGeometry.attributes) {\n          const normName = `${meshid}-normal`;\n          gnode += getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n          triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n        } // serialize uvs\n\n\n        if ('uv' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord`;\n          gnode += getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n        } // serialize lightmap uvs\n\n\n        if ('uv2' in bufferGeometry.attributes) {\n          var uvName = `${meshid}-texcoord2`;\n          gnode += getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n          triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n        } // serialize colors\n\n\n        if ('color' in bufferGeometry.attributes) {\n          const colName = `${meshid}-color`;\n          gnode += getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n          triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n        }\n\n        let indexArray = null;\n\n        if (bufferGeometry.index) {\n          indexArray = attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n\n          for (let i = 0, l = indexArray.length; i < l; i++) indexArray[i] = i;\n        }\n\n        for (let i = 0, l = groups.length; i < l; i++) {\n          const group = groups[i];\n          const subarr = subArray(indexArray, group.start, group.count);\n          const polycount = subarr.length / 3;\n          gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n          gnode += triangleInputs;\n          gnode += `<p>${subarr.join(' ')}</p>`;\n          gnode += '</triangles>';\n        }\n\n        gnode += '</mesh></geometry>';\n        libraryGeometries.push(gnode);\n        info = {\n          meshid,\n          bufferGeometry\n        };\n        geometryInfo.set(g, info);\n      }\n\n      return info;\n    } // Process the given texture into the image library\n    // Returns the image library\n\n\n    function processTexture(tex) {\n      let texid = imageMap.get(tex);\n\n      if (texid == null) {\n        texid = `image-${libraryImages.length + 1}`;\n        const ext = 'png';\n        const name = tex.name || texid;\n        let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n\n        if (version === '1.5.0') {\n          imageNode += `<init_from><ref>${options.textureDirectory}${name}.${ext}</ref></init_from>`;\n        } else {\n          // version image node 1.4.1\n          imageNode += `<init_from>${options.textureDirectory}${name}.${ext}</init_from>`;\n        }\n\n        imageNode += '</image>';\n        libraryImages.push(imageNode);\n        imageMap.set(tex, texid);\n        textures.push({\n          directory: options.textureDirectory,\n          name,\n          ext,\n          data: imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n\n      return texid;\n    } // Process the given material into the material and effect libraries\n    // Returns the material id\n\n\n    function processMaterial(m) {\n      let matid = materialMap.get(m);\n\n      if (matid == null) {\n        matid = `Mat${libraryEffects.length + 1}`;\n        let type = 'phong';\n\n        if (m.isMeshLambertMaterial === true) {\n          type = 'lambert';\n        } else if (m.isMeshBasicMaterial === true) {\n          type = 'constant';\n\n          if (m.map !== null) {\n            // The Collada spec does not support diffuse texture maps with the\n            // constant shader type.\n            // mrdoob/three.js#15469\n            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n          }\n        }\n\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n\n        if (m.transparent === true) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        libraryMaterials.push(materialNode);\n        libraryEffects.push(effectnode);\n        materialMap.set(m, matid);\n      }\n\n      return matid;\n    } // Recursively process the object into a scene\n\n\n    function processObject(o) {\n      let node = `<node name=\"${o.name}\">`;\n      node += getTransform(o);\n\n      if (o.isMesh === true && o.geometry !== null) {\n        // function returns the id associated with the mesh and a \"BufferGeometry\" version\n        // of the geometry in case it's not a geometry.\n        const geomInfo = processGeometry(o.geometry);\n        const meshid = geomInfo.meshid;\n        const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n        let matids = null;\n        let matidsArray = []; // get a list of materials to bind to the sub groups of the geometry.\n        // If the amount of subgroups is greater than the materials, than reuse\n        // the materials.\n\n        const mat = o.material || new MeshBasicMaterial();\n        const materials = Array.isArray(mat) ? mat : [mat];\n\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n\n        matids = matidsArray.fill().map((v, i) => processMaterial(materials[i % materials.length]));\n        node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n      }\n\n      o.children.forEach(c => node += processObject(c));\n      node += '</node>';\n      return node;\n    }\n\n    var geometryInfo = new WeakMap();\n    var materialMap = new WeakMap();\n    var imageMap = new WeakMap();\n    var textures = [];\n    var libraryImages = [];\n    var libraryGeometries = [];\n    var libraryEffects = [];\n    var libraryMaterials = [];\n    const libraryVisualScenes = processObject(object);\n    const specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${options.author !== null ? `<author>${options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: format(dae),\n      textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n\n    return res;\n  }\n};\n\nexport { ColladaExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}