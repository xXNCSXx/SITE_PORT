{"ast":null,"code":"import { InputNode } from '../core/InputNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nfunction CubeTextureNode(value, uv, bias) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new ReflectNode();\n  this.bias = bias;\n}\nCubeTextureNode.prototype = Object.create(InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\nCubeTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { CubeTextureNode };","map":{"version":3,"names":["InputNode","ReflectNode","ColorSpaceNode","ExpressionNode","CubeTextureNode","value","uv","bias","call","shared","prototype","Object","create","constructor","nodeType","getTexture","builder","output","generate","uuid","cubetex","build","undefined","context","setTexture","code","include","isShader","ignoreCache","outputType","getType","addContext","colorSpace","fromDecoding","getTextureEncodingFromMap","input","parse","removeContext","format","copy","source","toJSON","meta","data","getJSONNode","createJSONNode"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/inputs/CubeTextureNode.js"],"sourcesContent":["import { InputNode } from '../core/InputNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\n\nfunction CubeTextureNode(value, uv, bias) {\n  InputNode.call(this, 'v4', {\n    shared: true\n  });\n  this.value = value;\n  this.uv = uv || new ReflectNode();\n  this.bias = bias;\n}\n\nCubeTextureNode.prototype = Object.create(InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\n\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\n\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new ColorSpaceNode(new ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nCubeTextureNode.prototype.copy = function (source) {\n  InputNode.prototype.copy.call(this, source);\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\n\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { CubeTextureNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}