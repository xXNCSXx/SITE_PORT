{"ast":null,"code":"import { compact, contains, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map } from \"../../utils/utils\";\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\";\nexport function defaultVisit(ctx, param) {\n  var childrenNames = keys(ctx);\n  var childrenNamesLength = childrenNames.length;\n  for (var i = 0; i < childrenNamesLength; i++) {\n    var currChildName = childrenNames[i];\n    var currChildArray = ctx[currChildName];\n    var currChildArrayLength = currChildArray.length;\n    for (var j = 0; j < currChildArrayLength; j++) {\n      var currChild = currChildArray[j];\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n  return undefined;\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  var derivedConstructor = function () {};\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  var semanticProto = {\n    visit: function (cstNode, param) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      }\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined;\n      }\n      return this[cstNode.name](cstNode.children, param);\n    },\n    validateVisitor: function () {\n      var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty(semanticDefinitionErrors)) {\n        var errorMessages = map(semanticDefinitionErrors, function (currDefError) {\n          return currDefError.msg;\n        });\n        throw Error(\"Errors Detected in CST Visitor <\" + functionName(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  var derivedConstructor = function () {};\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  var withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, function (ruleName) {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n  var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n  return missingErrors.concat(redundantErrors);\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n  var errors = map(ruleNames, function (currRuleName) {\n    if (!isFunction(visitorInstance[currRuleName])) {\n      return {\n        msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor.\",\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      };\n    }\n  });\n  return compact(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nexport function validateRedundantMethods(visitorInstance, ruleNames) {\n  var errors = [];\n  for (var prop in visitorInstance) {\n    if (isFunction(visitorInstance[prop]) && !contains(VALID_PROP_NAMES, prop) && !contains(ruleNames, prop)) {\n      errors.push({\n        msg: \"Redundant visitor method: <\" + prop + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor\\n\" + \"There is no Grammar Rule corresponding to this method's name.\\n\",\n        type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n        methodName: prop\n      });\n    }\n  }\n  return errors;\n}","map":{"version":3,"sources":["../../../../src/parse/cst/cst_visitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { compact, contains, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map } from \"../../utils/utils\";\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\";\nexport function defaultVisit(ctx, param) {\n    var childrenNames = keys(ctx);\n    var childrenNamesLength = childrenNames.length;\n    for (var i = 0; i < childrenNamesLength; i++) {\n        var currChildName = childrenNames[i];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n            var currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n    return undefined;\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    var semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                var errorMessages = map(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });\n                throw Error(\"Errors Detected in CST Visitor <\" + functionName(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    var withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n    return missingErrors.concat(redundantErrors);\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    var errors = map(ruleNames, function (currRuleName) {\n        if (!isFunction(visitorInstance[currRuleName])) {\n            return {\n                msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor.\",\n                type: CstVisitorDefinitionError.MISSING_METHOD,\n                methodName: currRuleName\n            };\n        }\n    });\n    return compact(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nexport function validateRedundantMethods(visitorInstance, ruleNames) {\n    var errors = [];\n    for (var prop in visitorInstance) {\n        if (isFunction(visitorInstance[prop]) &&\n            !contains(VALID_PROP_NAMES, prop) &&\n            !contains(ruleNames, prop)) {\n            errors.push({\n                msg: \"Redundant visitor method: <\" + prop + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor\\n\" +\n                    \"There is no Grammar Rule corresponding to this method's name.\\n\",\n                type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n                methodName: prop\n            });\n        }\n    }\n    return errors;\n}\n//# sourceMappingURL=cst_visitor.js.map"]},"metadata":{},"sourceType":"module"}