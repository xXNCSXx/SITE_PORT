{"ast":null,"code":"import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */function () {\n  function Lexer(lexerDefinition, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.config = undefined;\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    }\n    // todo: defaults func?\n    this.config = merge(DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: {}\n          };\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = cloneObj(lexerDefinition);\n        }\n      });\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      }\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n          return isUndefined(currTokType);\n        });\n      });\n      var allModeNames = keys(actualDefinition.modes);\n      forEach(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n          _this.modes.push(currModName);\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          }\n          // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n          if (isEmpty(_this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            var currAnalyzeResult_1;\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT.bind(_this)\n              });\n            });\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n      if (!isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          _this.chopInput = IDENTITY;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = NOOP;\n          _this.match = _this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          _this.handleModes = NOOP;\n        }\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = IDENTITY;\n        }\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = NOOP;\n        }\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n        }\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        clearRegExpParserCache();\n      });\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        toFastProperties(_this);\n      });\n    });\n  }\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    var lexResult = this.tokenizeInternal(text, initialMode);\n    return lexResult;\n  };\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n    var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = cloneEmptyGroups(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns = undefined;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    var pop_mode = function (popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 &&\n      // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = last(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n    var currConfig;\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null;\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        var singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt;\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltConfig = patternIdxToConfig[longerAltIdx];\n            var longerAltPattern = longerAltConfig.pattern;\n            altPayload = null;\n            // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n              if (match !== null) {\n                matchAltImage = match[0];\n                if (match.payload !== undefined) {\n                  altPayload = match.payload;\n                }\n              } else {\n                matchAltImage = null;\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset);\n              matchAltImage = this.match(longerAltPattern, text, offset);\n            }\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage;\n              payload = altPayload;\n              currConfig = longerAltConfig;\n            }\n          }\n          break;\n        }\n      }\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset);\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern;\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            var singleCharCode = currConfig_1.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    }\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  };\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  };\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.createTokenInstance = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return null;\n  };\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n    return 666;\n  };\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  };\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.handlePayload = function (token, payload) {};\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n  Lexer.prototype.match = function (pattern, text, offset) {\n    return null;\n  };\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  };\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : regExpArray;\n  };\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(indent + \"--> <\" + phaseDesc + \">\");\n      }\n      var _a = timer(phaseImpl),\n        time = _a.time,\n        value = _a.value;\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      var traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\nexport { Lexer };","map":{"version":3,"sources":["../../../src/scan/lexer_public.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        var _this = this;\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.config = undefined;\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = merge(DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = { modes: {} };\n                    actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n                    actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = cloneObj(lexerDefinition);\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) { return isUndefined(currTokType); });\n            });\n            var allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(_this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: _this.config\n                                    .lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT.bind(_this)\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    _this.chopInput = IDENTITY;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = NOOP;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = NOOP;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = IDENTITY;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = NOOP;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                clearRegExpParserCache();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                toFastProperties(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        var lexResult = this.tokenizeInternal(text, initialMode);\n        return lexResult;\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = cloneEmptyGroups(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns = undefined;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n                    column: popToken.startColumn !== undefined\n                        ? popToken.startColumn\n                        : undefined,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = last(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAltIdx = currConfig.longerAlt;\n                    if (longerAltIdx !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltConfig = patternIdxToConfig[longerAltIdx];\n                        var longerAltPattern = longerAltConfig.pattern;\n                        altPayload = null;\n                        // single Char can never be a longer alt so no need to test it.\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        if (longerAltConfig.isCustom === true) {\n                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                            if (match !== null) {\n                                matchAltImage = match[0];\n                                if (match.payload !== undefined) {\n                                    altPayload = match.payload;\n                                }\n                            }\n                            else {\n                                matchAltImage = null;\n                            }\n                        }\n                        else {\n                            this.updateLastIndex(longerAltPattern, offset);\n                            matchAltImage = this.match(longerAltPattern, text, offset);\n                        }\n                        if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                            matchedImage = matchAltImage;\n                            payload = altPayload;\n                            currConfig = longerAltConfig;\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !==\n                                    null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.createTokenInstance = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return null;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n        return 666;\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.handlePayload = function (token, payload) { };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n    Lexer.prototype.match = function (pattern, text, offset) {\n        return null;\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : regExpArray;\n    };\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = timer(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\nexport { Lexer };\n//# sourceMappingURL=lexer_public.js.map"]},"metadata":{},"sourceType":"module"}