{"ast":null,"code":"import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\nvar LDrawLoader = function () {\n  var conditionalLineVertShader = /* glsl */\n  `\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\n  var conditionalLineFragShader = /* glsl */\n  `\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n  var tempVec0 = new Vector3();\n  var tempVec1 = new Vector3();\n  function smoothNormals(triangles, lineSegments) {\n    function hashVertex(v) {\n      // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n      // to be smoothed as expected (see minifig arms). The errors between edges\n      // could be due to matrix multiplication.\n      var x = ~~(v.x * 1e2);\n      var y = ~~(v.y * 1e2);\n      var z = ~~(v.z * 1e2);\n      return `${x},${y},${z}`;\n    }\n    function hashEdge(v0, v1) {\n      return `${hashVertex(v0)}_${hashVertex(v1)}`;\n    }\n    var hardEdges = new Set();\n    var halfEdgeList = {};\n    var fullHalfEdgeList = {};\n    var normals = []; // Save the list of hard edges by hash\n\n    for (let i = 0, l = lineSegments.length; i < l; i++) {\n      var ls = lineSegments[i];\n      var v0 = ls.v0;\n      var v1 = ls.v1;\n      hardEdges.add(hashEdge(v0, v1));\n      hardEdges.add(hashEdge(v1, v0));\n    } // track the half edges associated with each triangle\n\n    for (let i = 0, l = triangles.length; i < l; i++) {\n      var tri = triangles[i];\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        var index = i2;\n        var next = (i2 + 1) % 3;\n        var v0 = tri[`v${index}`];\n        var v1 = tri[`v${next}`];\n        var hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n        if (hardEdges.has(hash)) continue;\n        halfEdgeList[hash] = tri;\n        fullHalfEdgeList[hash] = tri;\n      }\n    } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n    // quads provide more \"influence\" to some vertex normals than a triangle due to\n    // the fact that a quad is made up of two triangles and all triangles are weighted\n    // equally. To fix this quads could be tracked separately so their vertex normals\n    // are weighted appropriately or we could try only adding a normal direction\n    // once per normal.\n    // Iterate until we've tried to connect all triangles to share normals\n\n    while (true) {\n      // Stop if there are no more triangles left\n      var halfEdges = Object.keys(halfEdgeList);\n      if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n      var i = 0;\n      var queue = [fullHalfEdgeList[halfEdges[0]]];\n      while (i < queue.length) {\n        // initialize all vertex normals in this triangle\n        var tri = queue[i];\n        i++;\n        var faceNormal = tri.faceNormal;\n        if (tri.n0 === null) {\n          tri.n0 = faceNormal.clone();\n          normals.push(tri.n0);\n        }\n        if (tri.n1 === null) {\n          tri.n1 = faceNormal.clone();\n          normals.push(tri.n1);\n        }\n        if (tri.n2 === null) {\n          tri.n2 = faceNormal.clone();\n          normals.push(tri.n2);\n        } // Check if any edge is connected to another triangle edge\n\n        for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n          var index = i2;\n          var next = (i2 + 1) % 3;\n          var v0 = tri[`v${index}`];\n          var v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n          var hash = hashEdge(v0, v1);\n          delete halfEdgeList[hash];\n          var reverseHash = hashEdge(v1, v0);\n          var otherTri = fullHalfEdgeList[reverseHash];\n          if (otherTri) {\n            // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n            // hard edge. There are some cases where the line segments do not line up exactly\n            // with or span multiple triangle edges (see Lunar Vehicle wheels).\n            if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n              continue;\n            } // if this triangle has already been traversed then it won't be in\n            // the halfEdgeList. If it has not then add it to the queue and delete\n            // it so it won't be found again.\n\n            if (reverseHash in halfEdgeList) {\n              queue.push(otherTri);\n              delete halfEdgeList[reverseHash];\n            } // Find the matching edge in this triangle and copy the normal vector over\n\n            for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n              var otherIndex = i3;\n              var otherNext = (i3 + 1) % 3;\n              var otherV0 = otherTri[`v${otherIndex}`];\n              var otherV1 = otherTri[`v${otherNext}`];\n              var otherHash = hashEdge(otherV0, otherV1);\n              if (otherHash === reverseHash) {\n                if (otherTri[`n${otherIndex}`] === null) {\n                  var norm = tri[`n${next}`];\n                  otherTri[`n${otherIndex}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n                if (otherTri[`n${otherNext}`] === null) {\n                  var norm = tri[`n${index}`];\n                  otherTri[`n${otherNext}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n    for (let i = 0, l = normals.length; i < l; i++) {\n      normals[i].normalize();\n    }\n  }\n  function isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === 'Subpart';\n  }\n  function LineParser(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n  LineParser.prototype = {\n    constructor: LineParser,\n    seekNonSpace: function () {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n        this.currentCharIndex++;\n      }\n    },\n    getToken: function () {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n        this.currentCharIndex++;\n      }\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    },\n    getRemainingString: function () {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    },\n    isAtTheEnd: function () {\n      return this.currentCharIndex >= this.lineLength;\n    },\n    setToEnd: function () {\n      this.currentCharIndex = this.lineLength;\n    },\n    getLineNumberString: function () {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  };\n  function sortByMaterial(a, b) {\n    if (a.colourCode === b.colourCode) {\n      return 0;\n    }\n    if (a.colourCode < b.colourCode) {\n      return -1;\n    }\n    return 1;\n  }\n  function createObject(elements, elementSize, isConditionalSegments) {\n    // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the triangles or line segments by colour code to make later the mesh groups\n    elements.sort(sortByMaterial);\n    var positions = [];\n    var normals = [];\n    var materials = [];\n    var bufferGeometry = new BufferGeometry();\n    var prevMaterial = null;\n    var index0 = 0;\n    var numGroupVerts = 0;\n    for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n      var elem = elements[iElem];\n      var v0 = elem.v0;\n      var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n      positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n      if (elementSize === 3) {\n        positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n        var n0 = elem.n0 || elem.faceNormal;\n        var n1 = elem.n1 || elem.faceNormal;\n        var n2 = elem.n2 || elem.faceNormal;\n        normals.push(n0.x, n0.y, n0.z);\n        normals.push(n1.x, n1.y, n1.z);\n        normals.push(n2.x, n2.y, n2.z);\n      }\n      if (prevMaterial !== elem.material) {\n        if (prevMaterial !== null) {\n          bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n        }\n        materials.push(elem.material);\n        prevMaterial = elem.material;\n        index0 = iElem * elementSize;\n        numGroupVerts = elementSize;\n      } else {\n        numGroupVerts += elementSize;\n      }\n    }\n    if (numGroupVerts > 0) {\n      bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    }\n    bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    if (elementSize === 3) {\n      bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    }\n    var object3d = null;\n    if (elementSize === 2) {\n      object3d = new LineSegments(bufferGeometry, materials);\n    } else if (elementSize === 3) {\n      object3d = new Mesh(bufferGeometry, materials);\n    }\n    if (isConditionalSegments) {\n      object3d.isConditionalLine = true;\n      var controlArray0 = new Float32Array(elements.length * 3 * 2);\n      var controlArray1 = new Float32Array(elements.length * 3 * 2);\n      var directionArray = new Float32Array(elements.length * 3 * 2);\n      for (let i = 0, l = elements.length; i < l; i++) {\n        var os = elements[i];\n        var c0 = os.c0;\n        var c1 = os.c1;\n        var v0 = os.v0;\n        var v1 = os.v1;\n        var index = i * 3 * 2;\n        controlArray0[index + 0] = c0.x;\n        controlArray0[index + 1] = c0.y;\n        controlArray0[index + 2] = c0.z;\n        controlArray0[index + 3] = c0.x;\n        controlArray0[index + 4] = c0.y;\n        controlArray0[index + 5] = c0.z;\n        controlArray1[index + 0] = c1.x;\n        controlArray1[index + 1] = c1.y;\n        controlArray1[index + 2] = c1.z;\n        controlArray1[index + 3] = c1.x;\n        controlArray1[index + 4] = c1.y;\n        controlArray1[index + 5] = c1.z;\n        directionArray[index + 0] = v1.x - v0.x;\n        directionArray[index + 1] = v1.y - v0.y;\n        directionArray[index + 2] = v1.z - v0.z;\n        directionArray[index + 3] = v1.x - v0.x;\n        directionArray[index + 4] = v1.y - v0.y;\n        directionArray[index + 5] = v1.z - v0.z;\n      }\n      bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n      bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n      bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n    }\n    return object3d;\n  } //\n\n  function LDrawLoader(manager) {\n    Loader.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  } // Special surface finish tag types.\n  // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\n  LDrawLoader.FINISH_TYPE_DEFAULT = 0;\n  LDrawLoader.FINISH_TYPE_CHROME = 1;\n  LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;\n  LDrawLoader.FINISH_TYPE_RUBBER = 3;\n  LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;\n  LDrawLoader.FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n  // The LDraw standard establishes these various possible subfolders.\n\n  LDrawLoader.FILE_LOCATION_AS_IS = 0;\n  LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;\n  LDrawLoader.FILE_LOCATION_TRY_P = 2;\n  LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;\n  LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;\n  LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;\n  LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;\n  LDrawLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: LDrawLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n      var scope = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    },\n    parse: function (text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    },\n    setMaterials: function (materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    },\n    setFileMap: function (fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    },\n    newParseScopeLevel: function (materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n      if (materials) {\n        for (let i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new Matrix4(),\n        matrix: new Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    },\n    removeScopeLevel: function () {\n      this.parseScopesStack.pop();\n      return this;\n    },\n    addMaterial: function (material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n      matLib[material.userData.code] = material;\n      return this;\n    },\n    getMaterial: function (colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n      for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n      return null;\n    },\n    getParentParseScope: function () {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n      return null;\n    },\n    getCurrentParseScope: function () {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n      return null;\n    },\n    parseColourMetaDirective: function (lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n      var token = null;\n      while (true) {\n        token = lineParser.getToken();\n        if (!token) {\n          break;\n        }\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n          case 'VALUE':\n            colour = lineParser.getToken();\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n            break;\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n            break;\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n            break;\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n          case 'CHROME':\n            finishType = LDrawLoader.FINISH_TYPE_CHROME;\n            break;\n          case 'PEARLESCENT':\n            finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;\n            break;\n          case 'RUBBER':\n            finishType = LDrawLoader.FINISH_TYPE_RUBBER;\n            break;\n          case 'MATTE_METALLIC':\n            finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;\n            break;\n          case 'METAL':\n            finishType = LDrawLoader.FINISH_TYPE_METAL;\n            break;\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n      var material = null;\n      switch (finishType) {\n        case LDrawLoader.FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n        case LDrawLoader.FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n        case LDrawLoader.FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n        case LDrawLoader.FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n        case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n        case LDrawLoader.FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: UniformsUtils.merge([UniformsLib.fog, {\n            diffuse: {\n              value: new Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    },\n    //\n    objectParse: function (text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var lineIndex = 0;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n        var material = scope.getMaterial(colourCode);\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n        return material;\n      }\n      function parseVector(lp) {\n        var v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n        return v;\n      } // Parse all line commands\n\n      for (lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n          continue;\n        }\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n        var lineType = lp.getToken();\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n                  var matrix = currentParseScope.matrix;\n                  if (matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n                case '!COLOUR':\n                  var material = this.parseColourMetaDirective(lp);\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n                  break;\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n                  break;\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n                  break;\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n                  break;\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            var material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: LDrawLoader.FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, faceNormal;\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, v3, faceNormal;\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n            break;\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    },\n    computeConstructionSteps: function (model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(c => {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    },\n    processObject: function (text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n      var currentFileName = parentParseScope.currentFileName;\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n      function onSubobjectFinish() {\n        finishedCount++;\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n        var isRoot = !parentParseScope.isFromParse;\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          const objGroup = parseScope.groupObject;\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n          for (let i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n            parentLineSegments.push(ls);\n          }\n          for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n            var os = conditionalSegments[i];\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n            parentConditionalSegments.push(os);\n          }\n          for (let i = 0, l = triangles.length; i < l; i++) {\n            var tri = triangles[i];\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n              tempVec0.subVectors(tri.v1, tri.v0);\n              tempVec1.subVectors(tri.v2, tri.v1);\n              tri.faceNormal.crossVectors(tempVec0, tempVec1).normalize();\n            }\n            parentTriangles.push(tri);\n          }\n        }\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n        switch (subobject.locationState) {\n          case LDrawLoader.FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n          case LDrawLoader.FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n          case LDrawLoader.FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n          case LDrawLoader.FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n          case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n          case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;\n            }\n            break;\n          case LDrawLoader.FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  });\n  return LDrawLoader;\n}();\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","Loader","FileLoader","Matrix4","MeshStandardMaterial","Color","MeshPhongMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Group","BufferGeometry","Float32BufferAttribute","LineSegments","Mesh","BufferAttribute","LDrawLoader","conditionalLineVertShader","conditionalLineFragShader","tempVec0","tempVec1","smoothNormals","triangles","lineSegments","hashVertex","v","x","y","z","hashEdge","v0","v1","hardEdges","Set","halfEdgeList","fullHalfEdgeList","normals","i","l","length","ls","add","tri","i2","l2","index","next","hash","has","halfEdges","Object","keys","queue","faceNormal","n0","clone","push","n1","n2","reverseHash","otherTri","Math","abs","dot","i3","l3","otherIndex","otherNext","otherV0","otherV1","otherHash","norm","normalize","isPrimitiveType","type","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","prototype","constructor","seekNonSpace","charAt","getToken","pos0","pos1","substring","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","sortByMaterial","a","b","colourCode","createObject","elements","elementSize","isConditionalSegments","sort","positions","materials","bufferGeometry","prevMaterial","index0","numGroupVerts","iElem","nElem","elem","v2","material","addGroup","Infinity","setAttribute","object3d","isConditionalLine","controlArray0","Float32Array","controlArray1","directionArray","os","c0","c1","manager","call","parseScopesStack","subobjectCache","fileMap","setMaterials","parseColourMetaDirective","separateObjects","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","assign","create","load","url","onLoad","onProgress","onError","scope","fileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","processObject","parse","newParseScopeLevel","getCurrentParseScope","isFromParse","setFileMap","matLib","n","userData","code","topParseScope","newParseScope","lib","subobjects","numSubobjects","subobjectIndex","inverted","category","keywords","currentFileName","mainColourCode","mainEdgeColourCode","currentMatrix","matrix","conditionalSegments","startingConstructionStep","removeScopeLevel","pop","addMaterial","getMaterial","startsWith","colour","getParentParseScope","lineParser","edgeColour","alpha","isTransparent","luminance","finishType","canHaveEnvMap","edgeMaterial","name","token","toUpperCase","parseInt","isNaN","max","min","color","roughness","envMapIntensity","metalness","specular","hsl","getHSL","h","s","setHSL","shininess","reflectivity","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","set","multiplyScalar","conditionalEdgeMaterial","vertexShader","fragmentShader","uniforms","merge","fog","diffuse","value","objectParse","parentParseScope","currentParseScope","indexOf","replace","lines","split","numLines","lineIndex","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","parseColourCode","forEdge","parseVector","lp","parseFloat","applyMatrix4","toLowerCase","lineType","meta","isRoot","groupObject","determinant","console","warn","newKeywords","forEach","keyword","trim","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","fileName","originalFileName","locationState","triedLowerCase","segment","ccw","doubleSided","subVectors","crossVectors","v3","computeConstructionSteps","model","stepNumber","traverse","c","isGroup","constructionStep","numConstructionSteps","onProcessed","subobject","parseScope","multiplyMatrices","copy","undefined","finishedCount","onSubobjectFinish","finalizeObject","Promise","resolve","then","loadSubobject","objGroup","decompose","position","quaternion","scale","parentLineSegments","parentConditionalSegments","parentTriangles","cached","subobjectGroup","onSubobjectLoaded","subobjectURL","newLocationState","lastIndexOf","err","onSubobjectError"],"sources":["C:/Users/drncs/OneDrive/rea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\nvar LDrawLoader = function () {\n  var conditionalLineVertShader =\n  /* glsl */\n  `\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\n  var conditionalLineFragShader =\n  /* glsl */\n  `\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n  var tempVec0 = new Vector3();\n  var tempVec1 = new Vector3();\n\n  function smoothNormals(triangles, lineSegments) {\n    function hashVertex(v) {\n      // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n      // to be smoothed as expected (see minifig arms). The errors between edges\n      // could be due to matrix multiplication.\n      var x = ~~(v.x * 1e2);\n      var y = ~~(v.y * 1e2);\n      var z = ~~(v.z * 1e2);\n      return `${x},${y},${z}`;\n    }\n\n    function hashEdge(v0, v1) {\n      return `${hashVertex(v0)}_${hashVertex(v1)}`;\n    }\n\n    var hardEdges = new Set();\n    var halfEdgeList = {};\n    var fullHalfEdgeList = {};\n    var normals = []; // Save the list of hard edges by hash\n\n    for (let i = 0, l = lineSegments.length; i < l; i++) {\n      var ls = lineSegments[i];\n      var v0 = ls.v0;\n      var v1 = ls.v1;\n      hardEdges.add(hashEdge(v0, v1));\n      hardEdges.add(hashEdge(v1, v0));\n    } // track the half edges associated with each triangle\n\n\n    for (let i = 0, l = triangles.length; i < l; i++) {\n      var tri = triangles[i];\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        var index = i2;\n        var next = (i2 + 1) % 3;\n        var v0 = tri[`v${index}`];\n        var v1 = tri[`v${next}`];\n        var hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n        if (hardEdges.has(hash)) continue;\n        halfEdgeList[hash] = tri;\n        fullHalfEdgeList[hash] = tri;\n      }\n    } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n    // quads provide more \"influence\" to some vertex normals than a triangle due to\n    // the fact that a quad is made up of two triangles and all triangles are weighted\n    // equally. To fix this quads could be tracked separately so their vertex normals\n    // are weighted appropriately or we could try only adding a normal direction\n    // once per normal.\n    // Iterate until we've tried to connect all triangles to share normals\n\n\n    while (true) {\n      // Stop if there are no more triangles left\n      var halfEdges = Object.keys(halfEdgeList);\n      if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n      var i = 0;\n      var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n      while (i < queue.length) {\n        // initialize all vertex normals in this triangle\n        var tri = queue[i];\n        i++;\n        var faceNormal = tri.faceNormal;\n\n        if (tri.n0 === null) {\n          tri.n0 = faceNormal.clone();\n          normals.push(tri.n0);\n        }\n\n        if (tri.n1 === null) {\n          tri.n1 = faceNormal.clone();\n          normals.push(tri.n1);\n        }\n\n        if (tri.n2 === null) {\n          tri.n2 = faceNormal.clone();\n          normals.push(tri.n2);\n        } // Check if any edge is connected to another triangle edge\n\n\n        for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n          var index = i2;\n          var next = (i2 + 1) % 3;\n          var v0 = tri[`v${index}`];\n          var v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n          var hash = hashEdge(v0, v1);\n          delete halfEdgeList[hash];\n          var reverseHash = hashEdge(v1, v0);\n          var otherTri = fullHalfEdgeList[reverseHash];\n\n          if (otherTri) {\n            // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n            // hard edge. There are some cases where the line segments do not line up exactly\n            // with or span multiple triangle edges (see Lunar Vehicle wheels).\n            if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n              continue;\n            } // if this triangle has already been traversed then it won't be in\n            // the halfEdgeList. If it has not then add it to the queue and delete\n            // it so it won't be found again.\n\n\n            if (reverseHash in halfEdgeList) {\n              queue.push(otherTri);\n              delete halfEdgeList[reverseHash];\n            } // Find the matching edge in this triangle and copy the normal vector over\n\n\n            for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n              var otherIndex = i3;\n              var otherNext = (i3 + 1) % 3;\n              var otherV0 = otherTri[`v${otherIndex}`];\n              var otherV1 = otherTri[`v${otherNext}`];\n              var otherHash = hashEdge(otherV0, otherV1);\n\n              if (otherHash === reverseHash) {\n                if (otherTri[`n${otherIndex}`] === null) {\n                  var norm = tri[`n${next}`];\n                  otherTri[`n${otherIndex}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                if (otherTri[`n${otherNext}`] === null) {\n                  var norm = tri[`n${index}`];\n                  otherTri[`n${otherNext}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n    for (let i = 0, l = normals.length; i < l; i++) {\n      normals[i].normalize();\n    }\n  }\n\n  function isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === 'Subpart';\n  }\n\n  function LineParser(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  LineParser.prototype = {\n    constructor: LineParser,\n    seekNonSpace: function () {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    },\n    getToken: function () {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    },\n    getRemainingString: function () {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    },\n    isAtTheEnd: function () {\n      return this.currentCharIndex >= this.lineLength;\n    },\n    setToEnd: function () {\n      this.currentCharIndex = this.lineLength;\n    },\n    getLineNumberString: function () {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  };\n\n  function sortByMaterial(a, b) {\n    if (a.colourCode === b.colourCode) {\n      return 0;\n    }\n\n    if (a.colourCode < b.colourCode) {\n      return -1;\n    }\n\n    return 1;\n  }\n\n  function createObject(elements, elementSize, isConditionalSegments) {\n    // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the triangles or line segments by colour code to make later the mesh groups\n    elements.sort(sortByMaterial);\n    var positions = [];\n    var normals = [];\n    var materials = [];\n    var bufferGeometry = new BufferGeometry();\n    var prevMaterial = null;\n    var index0 = 0;\n    var numGroupVerts = 0;\n\n    for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n      var elem = elements[iElem];\n      var v0 = elem.v0;\n      var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n      positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n      if (elementSize === 3) {\n        positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n        var n0 = elem.n0 || elem.faceNormal;\n        var n1 = elem.n1 || elem.faceNormal;\n        var n2 = elem.n2 || elem.faceNormal;\n        normals.push(n0.x, n0.y, n0.z);\n        normals.push(n1.x, n1.y, n1.z);\n        normals.push(n2.x, n2.y, n2.z);\n      }\n\n      if (prevMaterial !== elem.material) {\n        if (prevMaterial !== null) {\n          bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n        }\n\n        materials.push(elem.material);\n        prevMaterial = elem.material;\n        index0 = iElem * elementSize;\n        numGroupVerts = elementSize;\n      } else {\n        numGroupVerts += elementSize;\n      }\n    }\n\n    if (numGroupVerts > 0) {\n      bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    }\n\n    bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n    if (elementSize === 3) {\n      bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    }\n\n    var object3d = null;\n\n    if (elementSize === 2) {\n      object3d = new LineSegments(bufferGeometry, materials);\n    } else if (elementSize === 3) {\n      object3d = new Mesh(bufferGeometry, materials);\n    }\n\n    if (isConditionalSegments) {\n      object3d.isConditionalLine = true;\n      var controlArray0 = new Float32Array(elements.length * 3 * 2);\n      var controlArray1 = new Float32Array(elements.length * 3 * 2);\n      var directionArray = new Float32Array(elements.length * 3 * 2);\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        var os = elements[i];\n        var c0 = os.c0;\n        var c1 = os.c1;\n        var v0 = os.v0;\n        var v1 = os.v1;\n        var index = i * 3 * 2;\n        controlArray0[index + 0] = c0.x;\n        controlArray0[index + 1] = c0.y;\n        controlArray0[index + 2] = c0.z;\n        controlArray0[index + 3] = c0.x;\n        controlArray0[index + 4] = c0.y;\n        controlArray0[index + 5] = c0.z;\n        controlArray1[index + 0] = c1.x;\n        controlArray1[index + 1] = c1.y;\n        controlArray1[index + 2] = c1.z;\n        controlArray1[index + 3] = c1.x;\n        controlArray1[index + 4] = c1.y;\n        controlArray1[index + 5] = c1.z;\n        directionArray[index + 0] = v1.x - v0.x;\n        directionArray[index + 1] = v1.y - v0.y;\n        directionArray[index + 2] = v1.z - v0.z;\n        directionArray[index + 3] = v1.x - v0.x;\n        directionArray[index + 4] = v1.y - v0.y;\n        directionArray[index + 5] = v1.z - v0.z;\n      }\n\n      bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n      bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n      bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n    }\n\n    return object3d;\n  } //\n\n\n  function LDrawLoader(manager) {\n    Loader.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  } // Special surface finish tag types.\n  // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\n\n  LDrawLoader.FINISH_TYPE_DEFAULT = 0;\n  LDrawLoader.FINISH_TYPE_CHROME = 1;\n  LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;\n  LDrawLoader.FINISH_TYPE_RUBBER = 3;\n  LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;\n  LDrawLoader.FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n  // The LDraw standard establishes these various possible subfolders.\n\n  LDrawLoader.FILE_LOCATION_AS_IS = 0;\n  LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;\n  LDrawLoader.FILE_LOCATION_TRY_P = 2;\n  LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;\n  LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;\n  LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;\n  LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;\n  LDrawLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: LDrawLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    },\n    parse: function (text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    },\n    setMaterials: function (materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    },\n    setFileMap: function (fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    },\n    newParseScopeLevel: function (materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (let i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new Matrix4(),\n        matrix: new Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    },\n    removeScopeLevel: function () {\n      this.parseScopesStack.pop();\n      return this;\n    },\n    addMaterial: function (material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    },\n    getMaterial: function (colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n\n      for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    },\n    getParentParseScope: function () {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    },\n    getCurrentParseScope: function () {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    },\n    parseColourMetaDirective: function (lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = LDrawLoader.FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = LDrawLoader.FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = LDrawLoader.FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case LDrawLoader.FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: UniformsUtils.merge([UniformsLib.fog, {\n            diffuse: {\n              value: new Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    },\n    //\n    objectParse: function (text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var lineIndex = 0;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  var matrix = currentParseScope.matrix;\n\n                  if (matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  var material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            var material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: LDrawLoader.FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, v3, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    },\n    computeConstructionSteps: function (model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(c => {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    },\n    processObject: function (text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          const objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (let i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n            var os = conditionalSegments[i];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (let i = 0, l = triangles.length; i < l; i++) {\n            var tri = triangles[i];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n              tempVec0.subVectors(tri.v1, tri.v0);\n              tempVec1.subVectors(tri.v2, tri.v1);\n              tri.faceNormal.crossVectors(tempVec0, tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case LDrawLoader.FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case LDrawLoader.FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  });\n  return LDrawLoader;\n}();\n\nexport { LDrawLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}