{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nfunction SpriteNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.spherical = true;\n}\nSpriteNode.prototype = Object.create(Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;',\n    // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n    output.push(\n    // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n    if (this.spherical) {\n      output.push(\n      // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n    output.push(\n    // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n      alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n      color = this.color.flow(builder, 'c', {\n        slot: 'color'\n      }),\n      output = [];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n  return output.join('\\n');\n};\nSpriteNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { SpriteNode };","map":{"version":3,"names":["UniformsUtils","UniformsLib","Node","ColorNode","SpriteNode","call","color","spherical","prototype","Object","create","constructor","nodeType","build","builder","output","define","requires","lights","transparent","alpha","undefined","isShader","position","analyzeAndFlow","cache","mergeUniform","merge","fog","addParsCode","join","push","code","result","addCode","mask","analyze","slot","flow","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/materials/nodes/SpriteNode.js"],"sourcesContent":["import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\n\nfunction SpriteNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.spherical = true;\n}\n\nSpriteNode.prototype = Object.create(Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\n\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n\n    output.push( // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n\n    if (this.spherical) {\n      output.push( // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n\n    output.push( // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n        alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n        color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    }),\n        output = [];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n\n  return output.join('\\n');\n};\n\nSpriteNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\n\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { SpriteNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}