{"ast":null,"code":"import { Vector2 } from 'three';\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n    var i,\n      values,\n      sum,\n      halfWidth,\n      kMaxKernelSize = 25,\n      kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n    for (i = 0; i < kernelSize; ++i) values[i] /= sum;\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"names":["Vector2","ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kMaxKernelSize","kernelSize","ceil","Array"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/shaders/ConvolutionShader.js"],"sourcesContent":["import { Vector2 } from 'three';\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    var i,\n        values,\n        sum,\n        halfWidth,\n        kMaxKernelSize = 25,\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\n\nexport { ConvolutionShader };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;;AAE/B;AACA;AACA;AACA;AACA;;AAEA,IAAIC,iBAAiB,GAAG;EACtBC,OAAO,EAAE;IACPC,iBAAiB,EAAE,MAAM;IACzBC,eAAe,EAAE;EACnB,CAAC;EACDC,QAAQ,EAAE;IACRC,QAAQ,EAAE;MACRC,KAAK,EAAE;IACT,CAAC;IACDC,eAAe,EAAE;MACfD,KAAK,EAAE,IAAIP,OAAO,CAAC,WAAW,EAAE,GAAG;IACrC,CAAC;IACDS,OAAO,EAAE;MACPF,KAAK,EAAE;IACT;EACF,CAAC;EACDG,YAAY,EAAE,CAAC,+BAA+B,EAAE,mBAAmB,EAAE,eAAe,EAAE,sEAAsE,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAC3PC,cAAc,EAAE,CAAC,2CAA2C,EAAE,6BAA6B,EAAE,+BAA+B,EAAE,mBAAmB,EAAE,eAAe,EAAE,yBAAyB,EAAE,yCAAyC,EAAE,gDAAgD,EAAE,4DAA4D,EAAE,kCAAkC,EAAE,IAAI,EAAE,sBAAsB,EAAE,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI,CAAC;EAC3aE,WAAW,EAAE,SAAAA,CAAUC,KAAK,EAAE;IAC5B;IACA,SAASC,KAAKA,CAACC,CAAC,EAAEF,KAAK,EAAE;MACvB,OAAOG,IAAI,CAACC,GAAG,CAAC,EAAEF,CAAC,GAAGA,CAAC,CAAC,IAAI,GAAG,GAAGF,KAAK,GAAGA,KAAK,CAAC,CAAC;IACnD;IAEA,IAAIK,CAAC;MACDC,MAAM;MACNC,GAAG;MACHC,SAAS;MACTC,cAAc,GAAG,EAAE;MACnBC,UAAU,GAAG,CAAC,GAAGP,IAAI,CAACQ,IAAI,CAACX,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC;IAC/C,IAAIU,UAAU,GAAGD,cAAc,EAAEC,UAAU,GAAGD,cAAc;IAC5DD,SAAS,GAAG,CAACE,UAAU,GAAG,CAAC,IAAI,GAAG;IAClCJ,MAAM,GAAG,IAAIM,KAAK,CAACF,UAAU,CAAC;IAC9BH,GAAG,GAAG,GAAG;IAET,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,UAAU,EAAE,EAAEL,CAAC,EAAE;MAC/BC,MAAM,CAACD,CAAC,CAAC,GAAGJ,KAAK,CAACI,CAAC,GAAGG,SAAS,EAAER,KAAK,CAAC;MACvCO,GAAG,IAAID,MAAM,CAACD,CAAC,CAAC;IAClB,CAAC,CAAC;;IAGF,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,UAAU,EAAE,EAAEL,CAAC,EAAEC,MAAM,CAACD,CAAC,CAAC,IAAIE,GAAG;IAEjD,OAAOD,MAAM;EACf;AACF,CAAC;AAED,SAASnB,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module"}