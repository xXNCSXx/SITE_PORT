{"ast":null,"code":"import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\nfunction PhongNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.specular = new ColorNode(0x111111);\n  this.shininess = new FloatNode(30);\n}\nPhongNode.prototype = Object.create(Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif',\n    //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED',\n    // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [\n    // prevent undeclared normal\n    '#include <normal_fragment_begin>',\n    // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push(\n    // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n    if (environment) {\n      output.push(environment.code);\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n  return code;\n};\nPhongNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { PhongNode };","map":{"version":3,"names":["UniformsUtils","UniformsLib","Node","ColorNode","FloatNode","PhongNode","call","color","specular","shininess","prototype","Object","create","constructor","nodeType","build","builder","code","define","requires","lights","isShader","position","analyzeAndFlow","cache","undefined","mergeUniform","merge","fog","addParsCode","join","output","push","result","mask","analyze","slot","alpha","normal","light","ao","ambient","shadow","emissive","environment","environmentAlpha","flow","transparent","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"sources":["C:/Users/drncs/OneDrive/√Årea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/materials/nodes/PhongNode.js"],"sourcesContent":["import { UniformsUtils, UniformsLib } from 'three';\nimport { Node } from '../../core/Node.js';\nimport { ColorNode } from '../../inputs/ColorNode.js';\nimport { FloatNode } from '../../inputs/FloatNode.js';\n\nfunction PhongNode() {\n  Node.call(this);\n  this.color = new ColorNode(0xeeeeee);\n  this.specular = new ColorNode(0x111111);\n  this.shininess = new FloatNode(30);\n}\n\nPhongNode.prototype = Object.create(Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\n\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif', //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [// prevent undeclared normal\n    '#include <normal_fragment_begin>', // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push( // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n\n    if (environment) {\n      output.push(environment.code);\n\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nPhongNode.prototype.copy = function (source) {\n  Node.prototype.copy.call(this, source); // vertex\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\n\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { PhongNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}