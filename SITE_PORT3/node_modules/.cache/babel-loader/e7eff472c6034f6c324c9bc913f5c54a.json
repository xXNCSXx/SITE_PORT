{"ast":null,"code":"import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\nimport * as utils from \"../utils/utils\";\nimport { first, map, reduce } from \"../utils/utils\";\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\nimport { getProductionDslName } from \"./grammar/gast/gast\";\nexport var defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function (_a) {\n    var expected = _a.expected,\n      actual = _a.actual,\n      previous = _a.previous,\n      ruleName = _a.ruleName;\n    var hasLabel = hasTokenLabel(expected);\n    var expectedMsg = hasLabel ? \"--> \" + tokenLabel(expected) + \" <--\" : \"token of type --> \" + expected.name + \" <--\";\n    var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function (_a) {\n    var firstRedundant = _a.firstRedundant,\n      ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function (_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n      actual = _a.actual,\n      previous = _a.previous,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\", \") + \"]\";\n      });\n      var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \" + (idx + 1) + \". \" + itemMsg;\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function (_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n      actual = _a.actual,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\",\") + \"]\";\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nexport var defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexport var defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = first(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = getProductionDslName(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function (rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currTok) {\n      return tokenLabel(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" + (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currtok) {\n      return tokenLabel(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" + (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function (options) {\n    var dslName = getProductionDslName(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function (options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function (options) {\n    var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" + (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function (options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = utils.map(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = ruleName + \" --> \" + pathNames.concat([ruleName]).join(\" --> \");\n    var errMsg = \"Left Recursion found in grammar.\\n\" + (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") + (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function (options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function (options) {\n    var ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n    return errMsg;\n  }\n};","map":{"version":3,"sources":["../../../src/parse/errors_public.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\nimport * as utils from \"../utils/utils\";\nimport { first, map, reduce } from \"../utils/utils\";\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\nimport { getProductionDslName } from \"./grammar/gast/gast\";\nexport var defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = hasTokenLabel(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \" + tokenLabel(expected) + \" <--\"\n            : \"token of type --> \" + expected.name + \" <--\";\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = first(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n                return \"[\" + map(currPath, function (currTokenType) { return tokenLabel(currTokenType); }).join(\", \") + \"]\";\n            });\n            var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = first(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n                return \"[\" + map(currPath, function (currTokenType) { return tokenLabel(currTokenType); }).join(\",\") + \"]\";\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(defaultParserErrorProvider);\nexport var defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nexport var defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = first(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = getProductionDslName(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = map(options.prefixPath, function (currTok) {\n            return tokenLabel(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = map(options.prefixPath, function (currtok) {\n            return tokenLabel(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = utils.map(options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\n            .concat([ruleName])\n            .join(\" --> \");\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map"]},"metadata":{},"sourceType":"module"}