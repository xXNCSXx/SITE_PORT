{"ast":null,"code":"import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\nvar ReflectorForSSRPass = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get() {\n      return scope._isDistanceAttenuation;\n    },\n    set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get() {\n      return scope._isFresnel;\n    },\n    set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n  this.material = material;\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n  };\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnel;\n\t\tvarying vec4 vUv;\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tfloat op=opacity;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tif(depth>maxDistance) discard;\n\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\tfloat ratio=1.-(depth/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef isFresnel\n\t\t\t\t\top*=fresnel;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["Mesh","Color","Vector3","Plane","Matrix4","Vector4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","LinearFilter","RGBFormat","ReflectorForSSRPass","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","_isDistanceAttenuation","defines","isDistanceAttenuation","Object","defineProperty","get","set","val","material","_isFresnel","isFresnel","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","depthTexture","minFilter","maxFilter","parameters","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","transparent","assign","clone","fragmentShader","vertexShader","doRender","renderer","scene","camera","position","length","y","copy","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","create","constructor","tDiffuse","tDepth","fresnel","join"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"sourcesContent":["import { Mesh, Color, Vector3, Plane, Matrix4, Vector4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'ReflectorForSSRPass';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n  var useDepthTexture = options.useDepthTexture;\n  var yAxis = new Vector3(0, 1, 0);\n  var vecTemp0 = new Vector3();\n  var vecTemp1 = new Vector3(); //\n\n  scope.needsUpdate = false;\n  scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n  scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n  scope._isDistanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.isDistanceAttenuation;\n  Object.defineProperty(scope, 'isDistanceAttenuation', {\n    get() {\n      return scope._isDistanceAttenuation;\n    },\n\n    set(val) {\n      if (scope._isDistanceAttenuation === val) return;\n      scope._isDistanceAttenuation = val;\n      scope.material.defines.isDistanceAttenuation = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  scope._isFresnel = ReflectorForSSRPass.ReflectorShader.defines.isFresnel;\n  Object.defineProperty(scope, 'isFresnel', {\n    get() {\n      return scope._isFresnel;\n    },\n\n    set(val) {\n      if (scope._isFresnel === val) return;\n      scope._isFresnel = val;\n      scope.material.defines.isFresnel = val;\n      scope.material.needsUpdate = true;\n    }\n\n  });\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n\n  if (useDepthTexture) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    depthTexture.minFilter = NearestFilter;\n    depthTexture.maxFilter = NearestFilter;\n  }\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat,\n    depthTexture: useDepthTexture ? depthTexture : null\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    transparent: useDepthTexture,\n    defines: Object.assign({\n      useDepthTexture: useDepthTexture\n    }, ReflectorForSSRPass.ReflectorShader.defines),\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms['tDiffuse'].value = renderTarget.texture;\n  material.uniforms['color'].value = color;\n  material.uniforms['textureMatrix'].value = textureMatrix;\n\n  if (useDepthTexture) {\n    material.uniforms['tDepth'].value = renderTarget.depthTexture;\n  }\n\n  this.material = material;\n\n  this.doRender = function (renderer, scene, camera) {\n    material.uniforms['maxDistance'].value = scope.maxDistance * (camera.position.length() / camera.position.y); ///todo: Temporary hack,\n    // need precise calculation like this https://github.com/mrdoob/three.js/pull/20156/commits/8181946068e386d14a283cbd4f8877bc7ae066d3 ,\n    // after fully understand http://www.terathon.com/lengyel/Lengyel-Oblique.pdf .\n\n    material.uniforms['opacity'].value = scope.opacity;\n    vecTemp0.copy(camera.position).normalize();\n    vecTemp1.copy(vecTemp0).reflect(yAxis);\n    material.uniforms['fresnel'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; ///todo: Also need to use glsl viewPosition and viewNormal per pixel.\n    // console.log(material.uniforms['fresnel'].value)\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    } // scope.visible = true;\n\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflectorForSSRPass.prototype = Object.create(Mesh.prototype);\nReflectorForSSRPass.prototype.constructor = ReflectorForSSRPass;\nReflectorForSSRPass.ReflectorShader = {\n  ///todo: Will conflict with ReflectorForSSRPass.js?\n  defines: {\n    isDistanceAttenuation: true,\n    isFresnel: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnel: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnel;\n\t\tvarying vec4 vUv;\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tfloat op=opacity;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tif(depth>maxDistance) discard;\n\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\tfloat ratio=1.-(depth/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef isFresnel\n\t\t\t\t\top*=fresnel;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,iBAAiB,EAAEC,SAAS,EAAEC,cAAc,EAAEC,aAAa,EAAEC,YAAY,EAAEC,SAAS,QAAQ,OAAO;AAE9N,IAAIC,mBAAmB,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,OAAO,EAAE;EACrDlB,IAAI,CAACmB,IAAI,CAAC,IAAI,EAAEF,QAAQ,CAAC;EACzB,IAAI,CAACG,IAAI,GAAG,qBAAqB;EACjC,IAAIC,KAAK,GAAG,IAAI;EAChBH,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAII,KAAK,GAAGJ,OAAO,CAACI,KAAK,KAAKC,SAAS,GAAG,IAAItB,KAAK,CAACiB,OAAO,CAACI,KAAK,CAAC,GAAG,IAAIrB,KAAK,CAAC,QAAQ,CAAC;EACxF,IAAIuB,YAAY,GAAGN,OAAO,CAACM,YAAY,IAAI,GAAG;EAC9C,IAAIC,aAAa,GAAGP,OAAO,CAACO,aAAa,IAAI,GAAG;EAChD,IAAIC,QAAQ,GAAGR,OAAO,CAACQ,QAAQ,IAAI,CAAC;EACpC,IAAIC,MAAM,GAAGT,OAAO,CAACS,MAAM,IAAIX,mBAAmB,CAACY,eAAe;EAClE,IAAIC,eAAe,GAAGX,OAAO,CAACW,eAAe;EAC7C,IAAIC,KAAK,GAAG,IAAI5B,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChC,IAAI6B,QAAQ,GAAG,IAAI7B,OAAO,CAAC,CAAC;EAC5B,IAAI8B,QAAQ,GAAG,IAAI9B,OAAO,CAAC,CAAC,CAAC,CAAC;;EAE9BmB,KAAK,CAACY,WAAW,GAAG,KAAK;EACzBZ,KAAK,CAACa,WAAW,GAAGlB,mBAAmB,CAACY,eAAe,CAACO,QAAQ,CAACD,WAAW,CAACE,KAAK;EAClFf,KAAK,CAACgB,OAAO,GAAGrB,mBAAmB,CAACY,eAAe,CAACO,QAAQ,CAACE,OAAO,CAACD,KAAK;EAC1Ef,KAAK,CAACiB,sBAAsB,GAAGtB,mBAAmB,CAACY,eAAe,CAACW,OAAO,CAACC,qBAAqB;EAChGC,MAAM,CAACC,cAAc,CAACrB,KAAK,EAAE,uBAAuB,EAAE;IACpDsB,GAAGA,CAAA,EAAG;MACJ,OAAOtB,KAAK,CAACiB,sBAAsB;IACrC,CAAC;IAEDM,GAAGA,CAACC,GAAG,EAAE;MACP,IAAIxB,KAAK,CAACiB,sBAAsB,KAAKO,GAAG,EAAE;MAC1CxB,KAAK,CAACiB,sBAAsB,GAAGO,GAAG;MAClCxB,KAAK,CAACyB,QAAQ,CAACP,OAAO,CAACC,qBAAqB,GAAGK,GAAG;MAClDxB,KAAK,CAACyB,QAAQ,CAACb,WAAW,GAAG,IAAI;IACnC;EAEF,CAAC,CAAC;EACFZ,KAAK,CAAC0B,UAAU,GAAG/B,mBAAmB,CAACY,eAAe,CAACW,OAAO,CAACS,SAAS;EACxEP,MAAM,CAACC,cAAc,CAACrB,KAAK,EAAE,WAAW,EAAE;IACxCsB,GAAGA,CAAA,EAAG;MACJ,OAAOtB,KAAK,CAAC0B,UAAU;IACzB,CAAC;IAEDH,GAAGA,CAACC,GAAG,EAAE;MACP,IAAIxB,KAAK,CAAC0B,UAAU,KAAKF,GAAG,EAAE;MAC9BxB,KAAK,CAAC0B,UAAU,GAAGF,GAAG;MACtBxB,KAAK,CAACyB,QAAQ,CAACP,OAAO,CAACS,SAAS,GAAGH,GAAG;MACtCxB,KAAK,CAACyB,QAAQ,CAACb,WAAW,GAAG,IAAI;IACnC;EAEF,CAAC,CAAC;EACF,IAAIgB,cAAc,GAAG,IAAI9C,KAAK,CAAC,CAAC;EAChC,IAAI+C,MAAM,GAAG,IAAIhD,OAAO,CAAC,CAAC;EAC1B,IAAIiD,sBAAsB,GAAG,IAAIjD,OAAO,CAAC,CAAC;EAC1C,IAAIkD,mBAAmB,GAAG,IAAIlD,OAAO,CAAC,CAAC;EACvC,IAAImD,cAAc,GAAG,IAAIjD,OAAO,CAAC,CAAC;EAClC,IAAIkD,cAAc,GAAG,IAAIpD,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC1C,IAAIqD,SAAS,GAAG,IAAIlD,OAAO,CAAC,CAAC;EAC7B,IAAImD,IAAI,GAAG,IAAItD,OAAO,CAAC,CAAC;EACxB,IAAIuD,MAAM,GAAG,IAAIvD,OAAO,CAAC,CAAC;EAC1B,IAAIwD,CAAC,GAAG,IAAIrD,OAAO,CAAC,CAAC;EACrB,IAAIsD,aAAa,GAAG,IAAIvD,OAAO,CAAC,CAAC;EACjC,IAAIwD,aAAa,GAAG,IAAItD,iBAAiB,CAAC,CAAC;EAE3C,IAAIuB,eAAe,EAAE;IACnB,IAAIgC,YAAY,GAAG,IAAItD,YAAY,CAAC,CAAC;IACrCsD,YAAY,CAACzC,IAAI,GAAGZ,iBAAiB;IACrCqD,YAAY,CAACC,SAAS,GAAGrD,aAAa;IACtCoD,YAAY,CAACE,SAAS,GAAGtD,aAAa;EACxC;EAEA,IAAIuD,UAAU,GAAG;IACfF,SAAS,EAAEhD,YAAY;IACvBmD,SAAS,EAAEnD,YAAY;IACvBoD,MAAM,EAAEnD,SAAS;IACjB8C,YAAY,EAAEhC,eAAe,GAAGgC,YAAY,GAAG;EACjD,CAAC;EACD,IAAIM,YAAY,GAAG,IAAIzD,iBAAiB,CAACc,YAAY,EAAEC,aAAa,EAAEuC,UAAU,CAAC;EAEjF,IAAI,CAACrD,SAAS,CAACyD,YAAY,CAAC5C,YAAY,CAAC,IAAI,CAACb,SAAS,CAACyD,YAAY,CAAC3C,aAAa,CAAC,EAAE;IACnF0C,YAAY,CAACE,OAAO,CAACC,eAAe,GAAG,KAAK;EAC9C;EAEA,IAAIxB,QAAQ,GAAG,IAAIlC,cAAc,CAAC;IAChC2D,WAAW,EAAE1C,eAAe;IAC5BU,OAAO,EAAEE,MAAM,CAAC+B,MAAM,CAAC;MACrB3C,eAAe,EAAEA;IACnB,CAAC,EAAEb,mBAAmB,CAACY,eAAe,CAACW,OAAO,CAAC;IAC/CJ,QAAQ,EAAEtB,aAAa,CAAC4D,KAAK,CAAC9C,MAAM,CAACQ,QAAQ,CAAC;IAC9CuC,cAAc,EAAE/C,MAAM,CAAC+C,cAAc;IACrCC,YAAY,EAAEhD,MAAM,CAACgD;EACvB,CAAC,CAAC;EACF7B,QAAQ,CAACX,QAAQ,CAAC,UAAU,CAAC,CAACC,KAAK,GAAG+B,YAAY,CAACE,OAAO;EAC1DvB,QAAQ,CAACX,QAAQ,CAAC,OAAO,CAAC,CAACC,KAAK,GAAGd,KAAK;EACxCwB,QAAQ,CAACX,QAAQ,CAAC,eAAe,CAAC,CAACC,KAAK,GAAGuB,aAAa;EAExD,IAAI9B,eAAe,EAAE;IACnBiB,QAAQ,CAACX,QAAQ,CAAC,QAAQ,CAAC,CAACC,KAAK,GAAG+B,YAAY,CAACN,YAAY;EAC/D;EAEA,IAAI,CAACf,QAAQ,GAAGA,QAAQ;EAExB,IAAI,CAAC8B,QAAQ,GAAG,UAAUC,QAAQ,EAAEC,KAAK,EAAEC,MAAM,EAAE;IACjDjC,QAAQ,CAACX,QAAQ,CAAC,aAAa,CAAC,CAACC,KAAK,GAAGf,KAAK,CAACa,WAAW,IAAI6C,MAAM,CAACC,QAAQ,CAACC,MAAM,CAAC,CAAC,GAAGF,MAAM,CAACC,QAAQ,CAACE,CAAC,CAAC,CAAC,CAAC;IAC7G;IACA;;IAEApC,QAAQ,CAACX,QAAQ,CAAC,SAAS,CAAC,CAACC,KAAK,GAAGf,KAAK,CAACgB,OAAO;IAClDN,QAAQ,CAACoD,IAAI,CAACJ,MAAM,CAACC,QAAQ,CAAC,CAACI,SAAS,CAAC,CAAC;IAC1CpD,QAAQ,CAACmD,IAAI,CAACpD,QAAQ,CAAC,CAACsD,OAAO,CAACvD,KAAK,CAAC;IACtCgB,QAAQ,CAACX,QAAQ,CAAC,SAAS,CAAC,CAACC,KAAK,GAAG,CAACL,QAAQ,CAACuD,GAAG,CAACtD,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;IACvE;;IAEAmB,sBAAsB,CAACoC,qBAAqB,CAAClE,KAAK,CAACmE,WAAW,CAAC;IAC/DpC,mBAAmB,CAACmC,qBAAqB,CAACR,MAAM,CAACS,WAAW,CAAC;IAC7DnC,cAAc,CAACoC,eAAe,CAACpE,KAAK,CAACmE,WAAW,CAAC;IACjDtC,MAAM,CAACN,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnBM,MAAM,CAACwC,YAAY,CAACrC,cAAc,CAAC;IACnCG,IAAI,CAACmC,UAAU,CAACxC,sBAAsB,EAAEC,mBAAmB,CAAC,CAAC,CAAC;;IAE9D,IAAII,IAAI,CAAC8B,GAAG,CAACpC,MAAM,CAAC,GAAG,CAAC,EAAE;IAC1BM,IAAI,CAAC6B,OAAO,CAACnC,MAAM,CAAC,CAAC0C,MAAM,CAAC,CAAC;IAC7BpC,IAAI,CAACqC,GAAG,CAAC1C,sBAAsB,CAAC;IAChCE,cAAc,CAACoC,eAAe,CAACV,MAAM,CAACS,WAAW,CAAC;IAClDlC,cAAc,CAACV,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5BU,cAAc,CAACoC,YAAY,CAACrC,cAAc,CAAC;IAC3CC,cAAc,CAACuC,GAAG,CAACzC,mBAAmB,CAAC;IACvCK,MAAM,CAACkC,UAAU,CAACxC,sBAAsB,EAAEG,cAAc,CAAC;IACzDG,MAAM,CAAC4B,OAAO,CAACnC,MAAM,CAAC,CAAC0C,MAAM,CAAC,CAAC;IAC/BnC,MAAM,CAACoC,GAAG,CAAC1C,sBAAsB,CAAC;IAClCS,aAAa,CAACoB,QAAQ,CAACG,IAAI,CAAC3B,IAAI,CAAC;IACjCI,aAAa,CAACkC,EAAE,CAAClD,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC7BgB,aAAa,CAACkC,EAAE,CAACJ,YAAY,CAACrC,cAAc,CAAC;IAC7CO,aAAa,CAACkC,EAAE,CAACT,OAAO,CAACnC,MAAM,CAAC;IAChCU,aAAa,CAACmC,MAAM,CAACtC,MAAM,CAAC;IAC5BG,aAAa,CAACoC,GAAG,GAAGjB,MAAM,CAACiB,GAAG,CAAC,CAAC;;IAEhCpC,aAAa,CAACqC,iBAAiB,CAAC,CAAC;IACjCrC,aAAa,CAACsC,gBAAgB,CAACf,IAAI,CAACJ,MAAM,CAACmB,gBAAgB,CAAC,CAAC,CAAC;;IAE9DvC,aAAa,CAACf,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACjGe,aAAa,CAACwC,QAAQ,CAACvC,aAAa,CAACsC,gBAAgB,CAAC;IACtDvC,aAAa,CAACwC,QAAQ,CAACvC,aAAa,CAACwC,kBAAkB,CAAC;IACxDzC,aAAa,CAACwC,QAAQ,CAAC9E,KAAK,CAACmE,WAAW,CAAC,CAAC,CAAC;IAC3C;;IAEAvC,cAAc,CAACoD,6BAA6B,CAACnD,MAAM,EAAEC,sBAAsB,CAAC;IAC5EF,cAAc,CAACyC,YAAY,CAAC9B,aAAa,CAACwC,kBAAkB,CAAC;IAC7D7C,SAAS,CAACX,GAAG,CAACK,cAAc,CAACC,MAAM,CAACoD,CAAC,EAAErD,cAAc,CAACC,MAAM,CAACgC,CAAC,EAAEjC,cAAc,CAACC,MAAM,CAACqD,CAAC,EAAEtD,cAAc,CAACuD,QAAQ,CAAC;IACjH,IAAIN,gBAAgB,GAAGtC,aAAa,CAACsC,gBAAgB;IACrDxC,CAAC,CAAC4C,CAAC,GAAG,CAACG,IAAI,CAACC,IAAI,CAACnD,SAAS,CAAC+C,CAAC,CAAC,GAAGJ,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC,IAAIT,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC;IAC5FjD,CAAC,CAACwB,CAAC,GAAG,CAACuB,IAAI,CAACC,IAAI,CAACnD,SAAS,CAAC2B,CAAC,CAAC,GAAGgB,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC,IAAIT,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC;IAC5FjD,CAAC,CAAC6C,CAAC,GAAG,CAAC,GAAG;IACV7C,CAAC,CAACkD,CAAC,GAAG,CAAC,GAAG,GAAGV,gBAAgB,CAACS,QAAQ,CAAC,EAAE,CAAC,IAAIT,gBAAgB,CAACS,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;;IAE7EpD,SAAS,CAACsD,cAAc,CAAC,GAAG,GAAGtD,SAAS,CAAC+B,GAAG,CAAC5B,CAAC,CAAC,CAAC,CAAC,CAAC;;IAElDwC,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC,GAAGpD,SAAS,CAAC+C,CAAC;IAC1CJ,gBAAgB,CAACS,QAAQ,CAAC,CAAC,CAAC,GAAGpD,SAAS,CAAC2B,CAAC;IAC1CgB,gBAAgB,CAACS,QAAQ,CAAC,EAAE,CAAC,GAAGpD,SAAS,CAACgD,CAAC,GAAG,GAAG,GAAG7E,QAAQ;IAC5DwE,gBAAgB,CAACS,QAAQ,CAAC,EAAE,CAAC,GAAGpD,SAAS,CAACqD,CAAC,CAAC,CAAC;;IAE7CzC,YAAY,CAACE,OAAO,CAACyC,QAAQ,GAAGjC,QAAQ,CAACkC,cAAc,CAAC,CAAC;;IAEzD,IAAIC,mBAAmB,GAAGnC,QAAQ,CAACoC,eAAe,CAAC,CAAC;IACpD,IAAIC,gBAAgB,GAAGrC,QAAQ,CAACsC,EAAE,CAACC,OAAO;IAC1C,IAAIC,uBAAuB,GAAGxC,QAAQ,CAACyC,SAAS,CAACC,UAAU;IAC3D1C,QAAQ,CAACsC,EAAE,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;;IAE7BvC,QAAQ,CAACyC,SAAS,CAACC,UAAU,GAAG,KAAK,CAAC,CAAC;;IAEvC1C,QAAQ,CAAC2C,eAAe,CAACrD,YAAY,CAAC;IACtCU,QAAQ,CAAC4C,KAAK,CAACC,OAAO,CAACC,KAAK,CAACC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;;IAE5C,IAAI/C,QAAQ,CAACgD,SAAS,KAAK,KAAK,EAAEhD,QAAQ,CAACiD,KAAK,CAAC,CAAC;IAClDjD,QAAQ,CAACkD,MAAM,CAACjD,KAAK,EAAElB,aAAa,CAAC;IACrCiB,QAAQ,CAACsC,EAAE,CAACC,OAAO,GAAGF,gBAAgB;IACtCrC,QAAQ,CAACyC,SAAS,CAACC,UAAU,GAAGF,uBAAuB;IACvDxC,QAAQ,CAAC2C,eAAe,CAACR,mBAAmB,CAAC,CAAC,CAAC;;IAE/C,IAAIgB,QAAQ,GAAGjD,MAAM,CAACiD,QAAQ;IAE9B,IAAIA,QAAQ,KAAKzG,SAAS,EAAE;MAC1BsD,QAAQ,CAAC4C,KAAK,CAACO,QAAQ,CAACA,QAAQ,CAAC;IACnC,CAAC,CAAC;EAEJ,CAAC;EAED,IAAI,CAACf,eAAe,GAAG,YAAY;IACjC,OAAO9C,YAAY;EACrB,CAAC;AACH,CAAC;AAEDnD,mBAAmB,CAACiH,SAAS,GAAGxF,MAAM,CAACyF,MAAM,CAAClI,IAAI,CAACiI,SAAS,CAAC;AAC7DjH,mBAAmB,CAACiH,SAAS,CAACE,WAAW,GAAGnH,mBAAmB;AAC/DA,mBAAmB,CAACY,eAAe,GAAG;EACpC;EACAW,OAAO,EAAE;IACPC,qBAAqB,EAAE,IAAI;IAC3BQ,SAAS,EAAE;EACb,CAAC;EACDb,QAAQ,EAAE;IACRb,KAAK,EAAE;MACLc,KAAK,EAAE;IACT,CAAC;IACDgG,QAAQ,EAAE;MACRhG,KAAK,EAAE;IACT,CAAC;IACDiG,MAAM,EAAE;MACNjG,KAAK,EAAE;IACT,CAAC;IACDuB,aAAa,EAAE;MACbvB,KAAK,EAAE;IACT,CAAC;IACDF,WAAW,EAAE;MACXE,KAAK,EAAE;IACT,CAAC;IACDC,OAAO,EAAE;MACPD,KAAK,EAAE;IACT,CAAC;IACDkG,OAAO,EAAE;MACPlG,KAAK,EAAE;IACT;EACF,CAAC;EACDuC,YAAY,EAAE,CAAC,6BAA6B,EAAE,mBAAmB,EAAE,eAAe,EAAE,+CAA+C,EAAE,4EAA4E,EAAE,GAAG,CAAC,CAAC4D,IAAI,CAAC,IAAI,CAAC;EAClO7D,cAAc,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,SAAS1D,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module"}