{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\nvar lwoTree;\nvar LWOLoader = function (manager, parameters) {\n  Loader.call(this, manager);\n  parameters = parameters || {};\n  this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n};\nLWOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: LWOLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    var modelName = url.split(path).pop().split('.')[0];\n    var loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n    }, onProgress, onError);\n  },\n  parse: function (iffBuffer, path, modelName) {\n    lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}); // Parse the lwoTree object\n\nfunction LWOTreeParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\nLWOTreeParser.prototype = {\n  constructor: LWOTreeParser,\n  parse: function (modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  },\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    var finalMeshes = [];\n    var geometryParser = new GeometryParser();\n    var scope = this;\n    lwoTree.layers.forEach(function (layer) {\n      var geometry = geometryParser.parse(layer.geometry, layer);\n      var mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  },\n  parseMesh(geometry, layer) {\n    var mesh;\n    var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  },\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        var pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          var parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  },\n  getMaterials(namesArray, type) {\n    var materials = [];\n    var scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        var spec = {\n          color: mat.color\n        };\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n    var filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  },\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  },\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    var duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n};\nfunction MaterialParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\nMaterialParser.prototype = {\n  constructor: MaterialParser,\n  parse: function () {\n    var materials = [];\n    this.textures = {};\n    for (let name in lwoTree.materials) {\n      if (lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(lwoTree.materials[name], name, lwoTree.textures));\n      } else if (lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(lwoTree.materials[name], name, lwoTree.textures));\n      }\n    }\n    return materials;\n  },\n  parseMaterial(materialData, name, textures) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var connections = this.parseConnections(materialData.connections, materialData.nodes);\n    var maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    var attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    var materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  },\n  parseMaterialLwo2(materialData, name\n  /*, textures*/) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  },\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  },\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  },\n  parseConnections(connections, nodes) {\n    var materialConnections = {\n      maps: {}\n    };\n    var inputName = connections.inputName;\n    var inputNodeName = connections.inputNodeName;\n    var nodeName = connections.nodeName;\n    var scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  },\n  getNodeByRefName(refName, nodes) {\n    for (let name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  },\n  parseTextureNodes(textureNodes) {\n    var maps = {};\n    for (let name in textureNodes) {\n      var node = textureNodes[name];\n      var path = node.fileName;\n      if (!path) return;\n      var texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  },\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (let name in attributes) {\n      var attribute = attributes[name];\n      if (attribute.maps) {\n        var mapData = attribute.maps[0];\n        var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  },\n  parseAttributes(attributes, maps) {\n    var params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else params.color = new Color();\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  },\n  parsePhysicalAttributes(params, attributes\n  /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  },\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  },\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  },\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      var envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else envMap.mapping = EquirectangularReflectionMapping;\n      maps.envMap = envMap;\n    }\n  },\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    var fileName = '';\n    if (!lwoTree.textures) return fileName;\n    lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  },\n  loadTexture(path) {\n    if (!path) return null;\n    var texture;\n    texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  },\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  },\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n};\nfunction GeometryParser() {}\nGeometryParser.prototype = {\n  constructor: GeometryParser,\n  parse(geoData, layer) {\n    var geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // var userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  },\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    var remappedIndices = [];\n    var i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  },\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    var tags = lwoTree.tags;\n    var matNames = [];\n    var elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    var indexNum = 0; // create new indices in numerical order\n\n    var indexPairs = {}; // original indices mapped to numerical indices\n\n    var prevMaterialIndex;\n    var prevStart = 0;\n    var currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      var materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        var currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n    if (geometry.groups.length > 0) {\n      var currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n    geometry.userData.matNames = matNames;\n  },\n  splitMaterialIndices(polygonDimensions, indices) {\n    var remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  },\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (let name in layer.uvs) {\n      var uvs = layer.uvs[name].uvs;\n      var uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  },\n  parseMorphTargets(geometry, layer) {\n    var num = 0;\n    for (let name in layer.morphTargets) {\n      var remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      var morphPoints = layer.morphTargets[name].points;\n      var morphIndices = layer.morphTargets[name].indices;\n      var type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","lwoTree","LWOLoader","manager","parameters","call","resourcePath","undefined","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","length","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","value","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","prevStart","currentCount","materialIndex","currentIndex","addGroup","groups","remappedUVs","from","count","uvs","uvIndices","j","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/loaders/LWOLoader.js"],"sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\nvar lwoTree;\n\nvar LWOLoader = function (manager, parameters) {\n  Loader.call(this, manager);\n  parameters = parameters || {};\n  this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n};\n\nLWOLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: LWOLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    var modelName = url.split(path).pop().split('.')[0];\n    var loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n\n    }, onProgress, onError);\n  },\n  parse: function (iffBuffer, path, modelName) {\n    lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}); // Parse the lwoTree object\n\nfunction LWOTreeParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nLWOTreeParser.prototype = {\n  constructor: LWOTreeParser,\n  parse: function (modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  },\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    var finalMeshes = [];\n    var geometryParser = new GeometryParser();\n    var scope = this;\n    lwoTree.layers.forEach(function (layer) {\n      var geometry = geometryParser.parse(layer.geometry, layer);\n      var mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  },\n\n  parseMesh(geometry, layer) {\n    var mesh;\n    var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  },\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        var pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          var parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  },\n\n  getMaterials(namesArray, type) {\n    var materials = [];\n    var scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        var spec = {\n          color: mat.color\n        };\n\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n\n    var filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  },\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  },\n\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    var duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n\n};\n\nfunction MaterialParser(textureLoader) {\n  this.textureLoader = textureLoader;\n}\n\nMaterialParser.prototype = {\n  constructor: MaterialParser,\n  parse: function () {\n    var materials = [];\n    this.textures = {};\n\n    for (let name in lwoTree.materials) {\n      if (lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(lwoTree.materials[name], name, lwoTree.textures));\n      } else if (lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(lwoTree.materials[name], name, lwoTree.textures));\n      }\n    }\n\n    return materials;\n  },\n\n  parseMaterial(materialData, name, textures) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var connections = this.parseConnections(materialData.connections, materialData.nodes);\n    var maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    var attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    var materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  },\n\n  parseMaterialLwo2(materialData, name\n  /*, textures*/\n  ) {\n    var params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    var attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  },\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  },\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  },\n\n  parseConnections(connections, nodes) {\n    var materialConnections = {\n      maps: {}\n    };\n    var inputName = connections.inputName;\n    var inputNodeName = connections.inputNodeName;\n    var nodeName = connections.nodeName;\n    var scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  },\n\n  getNodeByRefName(refName, nodes) {\n    for (let name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  },\n\n  parseTextureNodes(textureNodes) {\n    var maps = {};\n\n    for (let name in textureNodes) {\n      var node = textureNodes[name];\n      var path = node.fileName;\n      if (!path) return;\n      var texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  },\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (let name in attributes) {\n      var attribute = attributes[name];\n\n      if (attribute.maps) {\n        var mapData = attribute.maps[0];\n        var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  },\n\n  parseAttributes(attributes, maps) {\n    var params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else params.color = new Color();\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  },\n\n  parsePhysicalAttributes(params, attributes\n  /*, maps*/\n  ) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  },\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  },\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  },\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      var envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else envMap.mapping = EquirectangularReflectionMapping;\n\n      maps.envMap = envMap;\n    }\n  },\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    var fileName = '';\n    if (!lwoTree.textures) return fileName;\n    lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  },\n\n  loadTexture(path) {\n    if (!path) return null;\n    var texture;\n    texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  },\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  },\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n\n};\n\nfunction GeometryParser() {}\n\nGeometryParser.prototype = {\n  constructor: GeometryParser,\n\n  parse(geoData, layer) {\n    var geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // var userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  },\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    var remappedIndices = [];\n    var i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  },\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    var tags = lwoTree.tags;\n    var matNames = [];\n    var elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    var indexNum = 0; // create new indices in numerical order\n\n    var indexPairs = {}; // original indices mapped to numerical indices\n\n    var prevMaterialIndex;\n    var prevStart = 0;\n    var currentCount = 0;\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      var materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        var currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n\n    if (geometry.groups.length > 0) {\n      var currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n    geometry.userData.matNames = matNames;\n  },\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    var remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  },\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (let name in layer.uvs) {\n      var uvs = layer.uvs[name].uvs;\n      var uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  },\n\n  parseMorphTargets(geometry, layer) {\n    var num = 0;\n\n    for (let name in layer.morphTargets) {\n      var remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      var morphPoints = layer.morphTargets[name].points;\n      var morphIndices = layer.morphTargets[name].indices;\n      var type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}