{"ast":null,"code":"import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, LinearFilter, RGBFormat } from 'three';\nvar Refractor = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Refractor';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Refractor.RefractorShader; //\n\n  var virtualCamera = new PerspectiveCamera();\n  virtualCamera.matrixAutoUpdate = false;\n  virtualCamera.userData.refractor = true; //\n\n  var refractorPlane = new Plane();\n  var textureMatrix = new Matrix4(); // render target\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  } // material\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true // ensures, refractors are drawn from farthest to closest\n  });\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n  var visible = function () {\n    var refractorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var view = new Vector3();\n    var normal = new Vector3();\n    return function visible(camera) {\n      refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      view.subVectors(refractorWorldPosition, cameraWorldPosition);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      return view.dot(normal) < 0;\n    };\n  }();\n  var updateRefractorPlane = function () {\n    var normal = new Vector3();\n    var position = new Vector3();\n    var quaternion = new Quaternion();\n    var scale = new Vector3();\n    return function updateRefractorPlane() {\n      scope.matrixWorld.decompose(position, quaternion, scale);\n      normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n      normal.negate();\n      refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n    };\n  }();\n  var updateVirtualCamera = function () {\n    var clipPlane = new Plane();\n    var clipVector = new Vector4();\n    var q = new Vector4();\n    return function updateVirtualCamera(camera) {\n      virtualCamera.matrixWorld.copy(camera.matrixWorld);\n      virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      virtualCamera.far = camera.far; // used in WebGLBackground\n      // The following code creates an oblique view frustum for clipping.\n      // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n      // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n      clipPlane.copy(refractorPlane);\n      clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n      // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n      clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipVector.x;\n      projectionMatrix.elements[6] = clipVector.y;\n      projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipVector.w;\n    };\n  }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n  // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n  function updateTextureMatrix(camera) {\n    // this matrix does range mapping to [ 0, 1 ]\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n    // (matrix above) with the projection and view matrix of the virtual camera\n    // and the model matrix of the refractor\n\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  } //\n\n  function render(renderer, scene, camera) {\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n    var viewport = camera.viewport;\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n    scope.visible = true;\n  } //\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    // Render\n    renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n    if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n    if (!visible(camera) === true) return; // update\n\n    updateRefractorPlane();\n    updateTextureMatrix(camera);\n    updateVirtualCamera(camera);\n    render(renderer, scene, camera);\n  };\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\nRefractor.prototype = Object.create(Mesh.prototype);\nRefractor.prototype.constructor = Refractor;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Refractor };","map":{"version":3,"names":["Mesh","Color","PerspectiveCamera","Plane","Matrix4","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","LinearFilter","RGBFormat","Refractor","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","vertexShader","fragmentShader","transparent","value","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","encoding","outputEncoding","prototype","Object","create","constructor","tDiffuse","join"],"sources":["C:/Users/drncs/OneDrive/Área de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/objects/Refractor.js"],"sourcesContent":["import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, LinearFilter, RGBFormat } from 'three';\n\nvar Refractor = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Refractor';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Refractor.RefractorShader; //\n\n  var virtualCamera = new PerspectiveCamera();\n  virtualCamera.matrixAutoUpdate = false;\n  virtualCamera.userData.refractor = true; //\n\n  var refractorPlane = new Plane();\n  var textureMatrix = new Matrix4(); // render target\n\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  } // material\n\n\n  this.material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    transparent: true // ensures, refractors are drawn from farthest to closest\n\n  });\n  this.material.uniforms['color'].value = color;\n  this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n  this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n  var visible = function () {\n    var refractorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var view = new Vector3();\n    var normal = new Vector3();\n    return function visible(camera) {\n      refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      view.subVectors(refractorWorldPosition, cameraWorldPosition);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      return view.dot(normal) < 0;\n    };\n  }();\n\n  var updateRefractorPlane = function () {\n    var normal = new Vector3();\n    var position = new Vector3();\n    var quaternion = new Quaternion();\n    var scale = new Vector3();\n    return function updateRefractorPlane() {\n      scope.matrixWorld.decompose(position, quaternion, scale);\n      normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n      normal.negate();\n      refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n    };\n  }();\n\n  var updateVirtualCamera = function () {\n    var clipPlane = new Plane();\n    var clipVector = new Vector4();\n    var q = new Vector4();\n    return function updateVirtualCamera(camera) {\n      virtualCamera.matrixWorld.copy(camera.matrixWorld);\n      virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      virtualCamera.far = camera.far; // used in WebGLBackground\n      // The following code creates an oblique view frustum for clipping.\n      // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n      // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n      clipPlane.copy(refractorPlane);\n      clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n      // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n      clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipVector.x;\n      projectionMatrix.elements[6] = clipVector.y;\n      projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipVector.w;\n    };\n  }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n  // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n  function updateTextureMatrix(camera) {\n    // this matrix does range mapping to [ 0, 1 ]\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n    // (matrix above) with the projection and view matrix of the virtual camera\n    // and the model matrix of the refractor\n\n    textureMatrix.multiply(camera.projectionMatrix);\n    textureMatrix.multiply(camera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n  } //\n\n\n  function render(renderer, scene, camera) {\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  } //\n\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    // Render\n    renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n    if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n    if (!visible(camera) === true) return; // update\n\n    updateRefractorPlane();\n    updateTextureMatrix(camera);\n    updateVirtualCamera(camera);\n    render(renderer, scene, camera);\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nRefractor.prototype = Object.create(Mesh.prototype);\nRefractor.prototype.constructor = Refractor;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexport { Refractor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}