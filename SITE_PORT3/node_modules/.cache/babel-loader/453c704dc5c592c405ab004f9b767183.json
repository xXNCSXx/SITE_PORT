{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { StructNode } from '../core/StructNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { FunctionCallNode } from '../core/FunctionCallNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { MathNode } from '../math/MathNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\nfunction TextureCubeUVNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new StructNode(`struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}`);\n  var cubeUV_maxMipLevel = new ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new FunctionNode(`float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}`);\n  getFace.useKeywords = false;\n  var getUV = new FunctionNode(`vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}`);\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new FunctionNode(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}`, [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new ConstNode('float r0 1.0', true);\n  var v0 = new ConstNode('float v0 0.339', true);\n  var m0 = new ConstNode('float m0 -2.0', true);\n  var r1 = new ConstNode('float r1 0.8', true);\n  var v1 = new ConstNode('float v1 0.276', true);\n  var m1 = new ConstNode('float m1 -1.0', true);\n  var r4 = new ConstNode('float r4 0.4', true);\n  var v4 = new ConstNode('float v4 0.046', true);\n  var m4 = new ConstNode('float m4 2.0', true);\n  var r5 = new ConstNode('float r5 0.305', true);\n  var v5 = new ConstNode('float v5 0.016', true);\n  var m5 = new ConstNode('float m5 3.0', true);\n  var r6 = new ConstNode('float r6 0.21', true);\n  var v6 = new ConstNode('float v6 0.0038', true);\n  var m6 = new ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new FunctionNode(`float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}`, defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\nTextureCubeUVNode.prototype = Object.create(TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n    var mipInt = new MathNode(mip, MathNode.FLOOR);\n    var mipF = new MathNode(mip, MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n    var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n  return data;\n};\nexport { TextureCubeUVNode };","map":{"version":3,"names":["TempNode","ConstNode","StructNode","FunctionNode","FunctionCallNode","ExpressionNode","FloatNode","OperatorNode","MathNode","ColorSpaceNode","TextureCubeUVNode","value","uv","bias","call","Nodes","TextureCubeUVData","cubeUV_maxMipLevel","cubeUV_minMipLevel","cubeUV_maxTileSize","cubeUV_minTileSize","getFace","useKeywords","getUV","bilinearCubeUV","r0","v0","m0","r1","v1","m1","r4","v4","m4","r5","v5","m5","r6","v6","m6","defines","roughnessToMip","prototype","Object","create","constructor","nodeType","builder","texture","mipInt","colorSpaceTL","fromDecoding","getTextureEncodingFromMap","input","parse","build","colorSpaceTR","colorSpaceBL","colorSpaceBR","context","include","isShader","ignoreCache","addContext","colorSpaceTLExp","colorSpaceTRExp","colorSpaceBLExp","colorSpaceBRExp","removeContext","output","keywords","generate","roughness","mipV","mip","CLAMP","FLOOR","mipF","FRACT","color0","color1","setReadonly","ADD","color1Mix","MIX","format","console","warn","shader","getType","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"sources":["C:/Users/drncs/OneDrive/Ãrea de Trabalho/PORTIFOLIO/SITE3/node_modules/three-stdlib/nodes/misc/TextureCubeUVNode.js"],"sourcesContent":["import { TempNode } from '../core/TempNode.js';\nimport { ConstNode } from '../core/ConstNode.js';\nimport { StructNode } from '../core/StructNode.js';\nimport { FunctionNode } from '../core/FunctionNode.js';\nimport { FunctionCallNode } from '../core/FunctionCallNode.js';\nimport { ExpressionNode } from '../core/ExpressionNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { OperatorNode } from '../math/OperatorNode.js';\nimport { MathNode } from '../math/MathNode.js';\nimport { ColorSpaceNode } from '../utils/ColorSpaceNode.js';\n\nfunction TextureCubeUVNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\n\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new StructNode(`struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}`);\n  var cubeUV_maxMipLevel = new ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new FunctionNode(`float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}`);\n  getFace.useKeywords = false;\n  var getUV = new FunctionNode(`vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}`);\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new FunctionNode(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}`, [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new ConstNode('float r0 1.0', true);\n  var v0 = new ConstNode('float v0 0.339', true);\n  var m0 = new ConstNode('float m0 -2.0', true);\n  var r1 = new ConstNode('float r1 0.8', true);\n  var v1 = new ConstNode('float v1 0.276', true);\n  var m1 = new ConstNode('float m1 -1.0', true);\n  var r4 = new ConstNode('float r4 0.4', true);\n  var v4 = new ConstNode('float v4 0.046', true);\n  var m4 = new ConstNode('float m4 2.0', true);\n  var r5 = new ConstNode('float r5 0.305', true);\n  var v5 = new ConstNode('float v5 0.016', true);\n  var m5 = new ConstNode('float m5 3.0', true);\n  var r6 = new ConstNode('float r6 0.21', true);\n  var v6 = new ConstNode('float v6 0.0038', true);\n  var m6 = new ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new FunctionNode(`float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}`, defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\n\nTextureCubeUVNode.prototype = Object.create(TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\n\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\n\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n    var mipInt = new MathNode(mip, MathNode.FLOOR);\n    var mipF = new MathNode(mip, MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n    var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeUVNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}